{$S FICHIERS}{ include de DragsterEdit }PROCEDURE SaveUnder;	FORWARD;FUNCTION Abort:INTEGER;BEGIN	IF Screen^.filename = '' THEN	BEGIN		GetIndString(gResStr,rSTRErrors,18);		ParamText(gResStr,'','','');	END	ELSE		ParamText(Screen^.Filename,'','','');	Abort := MyAlert(259);END;{ cette fonction teste si un écran figure déjà parmis les écrans ouverts ! }FUNCTION VerifScreen(vRefNum:INTEGER; parID:LONGINT; Name:Str255; forSave: BOOLEAN):BOOLEAN;VAR	i: INTEGER;		fndrInfo: FInfo;		BEGIN	{ c'est bien un écran Dragster ? }	Err := HGetFInfo(vRefNum,parID,name,fndrInfo);	IF (Err=NoErr) & ((fndrInfo.fdCreator<>'DRG9') | (fndrInfo.fdType<>'VCOD')) THEN	BEGIN		Err := MyAlert(139);		VerifScreen := TRUE;		EXIT(VerifScreen);	END;		IF (forSave=FALSE) & (Err<>NoErr) THEN	BEGIN		VerifScreen := TRUE;		EXIT(VerifScreen);	END;		{ il n'est pas déjà ouvert ? }	VerifScreen := FALSE;	FOR i := 1 TO Pecr.NbEcran DO	WITH PEcr.Ecrans[i]^^ DO	BEGIN		IF (VolNumber=vRefNum) & (DirID=ParID) & EqualString(FileName,Name,FALSE,TRUE) THEN		BEGIN			SelectWindow(PEcr.Ecrans[i]^^.WEdit);			VerifScreen := TRUE;			Leave;		END;	END;	{ WITH }END;	{ VerifScreen }{========================================================================                        R E A D S C R E E N ========================================================================}PROCEDURE ReadScreen(NumEcran: integer);    VAR count: longint; refw: integer; lgtext: longint; hTe: TEHandle;        SavePort: GrafPtr;        XLgCode,        XNbVar,        XNbCst	     : integer;        XCodeHdle    : TParamHandle;        XVarHdle     : HVarRes;        XCstHdle     : HCstRes;        XErrFlag     : Boolean;        XhTE	     : TEHandle;        CodePos	     : Longint;        NbVar,        NbCst,        LgCode,        i	    : Integer;        TheVCode    : Handle;        Vlg	    : longint;		fndrInfo: FInfo;		BEGIN	{ lire l'ecran courant }	IF PEcr.Ecrans[NumEcran]^^.Filename='' THEN EXIT(ReadScreen);	SetCursor(WCurs^^);	Psel:=0;	DSel:=0;	HTe:=PEcr.Ecrans[NumEcran]^^.HTE;		WITH PEcr.Ecrans[NumEcran]^^ DO   BEGIN		Err := HGetFInfo(VolNumber,DirID,filename,fndrInfo);		IF fndrInfo.fdCreator<>MonCreator THEN EXIT(ReadScreen);		Err:=HOpen(VolNumber,DirID,filename,fsRdPerm,RefW);	END;		IF (Err<>0) THEN	BEGIN		ErrorManager(Err,0);		EXIT(ReadScreen);	END;(*    If not CompFlag then        begin { mode non compacte }           Count:=SizeOf(ACar);           Err:=FSRead(RefW,count,Ptr(PEcr.Ecrans[NumEcran]^));           If (Err<>0) then              Begin               ErrorManager(Err,101);              End;        end    else*)	  BEGIN { mode compacte }            Count:=SizeOf(Longint);            Err:=FSRead(RefW,count,@Vlg);            IF (Err<>0) THEN               BEGIN                ErrorManager(Err,102);                Vlg:=0;               END;            TheVCode:=NewHandle(Vlg);            HNopurge(TheVCode);            Err:=FSRead(RefW,Vlg,TheVCode^);            IF (Err<>0) THEN               BEGIN                ErrorManager(Err,103);                SetHSize (TheVCode,0);               END;            HLock(Handle(PEcr.Ecrans[NumEcran]));            Decompact(PEcr.Ecrans[NumEcran]^^.Cars,TheVCode);            UnloadSeg(@InitVWork);	{ COMPOSEUR }            DisposHandle(TheVCode);    END;    Count:=SizeOf(Longint);    Err:=FSRead(RefW,count,@lgtext);    IF (Err<>0) THEN       BEGIN        ErrorManager(Err,102);        lgText:=0;       END;    SetHSize (hTE^^.hText, lgtext);    Err:=FSRead(RefW,lgtext,hTE^^.hText^);    IF (Err<>0) THEN       BEGIN        ErrorManager(Err,103);        SetHSize (hTE^^.hText, lgtext);       END;    hTE^^.teLength := lgtext;    PEcr.Ecrans[NumEcran]^^.ErrFlag:=lgtext<>0;    { lecture de la table de variables }    Count:=SizeOf(Integer);    Err:=FSRead(RefW,count,@NbVar);    IF (Err<>0) THEN       BEGIN        ErrorManager(Err,104);        NbVar:=0;       END;    count:=SizeOf(TVar)*NbVar;    SetHSize (Handle(PEcr.Ecrans[NumEcran]^^.VarTab), SizeOf(TVar)*NbVar);    Err:=FSRead(RefW,count,Ptr(PEcr.Ecrans[NumEcran]^^.VarTab^));    IF (Err<>0) THEN       BEGIN        ErrorManager(Err,105);        NbVar:=0;        SetHSize (Handle(PEcr.Ecrans[NumEcran]^^.VarTab), SizeOf(TVar)*NbVar);       END;    PEcr.Ecrans[NumEcran]^^.NbVar:=NbVar;    { lecture de la table de constantes }    Count:=SizeOf(Integer);    Err:=FSRead(RefW,count,@NbCst);    IF (Err<>0) THEN       BEGIN        ErrorManager(Err,106);        NbCst:=0;       END;    count:=SizeOf(Str64)*NbCst;    SetHSize (Handle(PEcr.Ecrans[NumEcran]^^.CstTab), SizeOf(Str64)*NbCst);    Err:=FSRead(RefW,count,Ptr(PEcr.Ecrans[NumEcran]^^.CstTab^));    IF (Err<>0) THEN       BEGIN        ErrorManager(Err,107);        NbCst:=0;        SetHSize (Handle(PEcr.Ecrans[NumEcran]^^.CstTab), SizeOf(Str64)*NbCst);       END;    PEcr.Ecrans[NumEcran]^^.NbCst:=NbCst;    { lecture du code tokenise }    Count:=SizeOf(Integer);    Err:=FSRead(RefW,count,@LgCode);    IF (Err<>0) THEN       BEGIN        ErrorManager(Err,108);        LgCode:=0;       END;    count:=LgCode;    SetHSize (Handle(PEcr.Ecrans[NumEcran]^^.CodeHdle), LgCode);    Err:=FSRead(RefW,count,Ptr(PEcr.Ecrans[NumEcran]^^.CodeHdle^));    IF (Err<>0) THEN       BEGIN        ErrorManager(Err,109);        LgCode:=0;        SetHSize (Handle(PEcr.Ecrans[NumEcran]^^.CodeHdle), LgCode);       END;    PEcr.Ecrans[NumEcran]^^.LgCode:=LgCode;    Err:=FSClose(RefW);    IF (Err<>0) THEN       BEGIN        ErrorManager(Err,1);       END;    GetPort(SavePort);    SetPort(PEcr.Ecrans[NumEcran]^^.Wecran);    IF NOT PEcr.Ecrans[NumEcran]^^.ErrFlag THEN        BEGIN   { il faut detokeniser pour l'edition }            { sauvegarde de l'ecran en cours }            XLgCode:=LgCode;            XNbVar:=NbVar;            XNbCst:=NbCst;            XCodeHdle:=CodeHdle;            XVarHdle:=VarTab;            XCstHdle:=CstTab;            XErrFlag:=ErrFlag;            XhTE:=hTe;            { activation du code a detokeniser }            LgCode:=PEcr.Ecrans[NumEcran]^^.LgCode;            NbVar:=PEcr.Ecrans[NumEcran]^^.NbVar;            NbCst:=PEcr.Ecrans[NumEcran]^^.NbCst;            CodeHdle:=PEcr.Ecrans[NumEcran]^^.CodeHdle;            VarTab:=PEcr.Ecrans[NumEcran]^^.VarTab;            CstTab:=PEcr.Ecrans[NumEcran]^^.CstTab;            ErrFlag:=PEcr.Ecrans[NumEcran]^^.ErrFlag;            hTE:=PEcr.Ecrans[NumEcran]^^.hTe;            { detokenisation }                { remise du texte a zero }								HUnLock(Handle(Hte));								SetHSize(hTE^^.hText, 0);                hTE^^.teLength := 0;                        { boucle de detokenisation }                Hlock(Handle(CodeHdle));                CodePos:=0;                WHILE CodePos<LgCode DO                BEGIN                  SetHSize(Handle(Resliste),TParamPtr(Ord4(CodeHdle^)+CodePos)^.LParam);                  BlockMoveData(Ptr(Ord4(CodeHdle^)+CodePos),Ptr(ResListe^),TParamPtr(Ord4(CodeHdle^)+CodePos)^.LParam);                  Detokenize;                  TempOut:=Concat(Tempout,chr($0D));                  SetHSize(hte^^.htext,hte^^.TeLength+Length(TempOut));                  BlockMoveData(@TempOut[1],Ptr(Ord4(Hte^^.hText^)+hTe^^.TeLength),Length(Tempout));                  hte^^.TeLength:=hte^^.TeLength+Length(TempOut);                  CodePos:=CodePos+TParamPtr(Ord4(CodeHdle^)+CodePos)^.LParam                END;                UnloadSeg(@Detokenize);			{ DETOKENISEUR }                HUnlock(Handle(CodeHdle));                HUnLock(Handle(Hte));                InvalRect(hTe^^.Inport^.PortRect);            { desactivation du code a detokeniser }            PEcr.Ecrans[NumEcran]^^.LgCode:=LgCode;            PEcr.Ecrans[NumEcran]^^.NbVar:=NbVar;            PEcr.Ecrans[NumEcran]^^.NbCst:=NbCst;            PEcr.Ecrans[NumEcran]^^.CodeHdle:=CodeHdle;            PEcr.Ecrans[NumEcran]^^.VarTab:=VarTab;            PEcr.Ecrans[NumEcran]^^.CstTab:=CstTab;            PEcr.Ecrans[NumEcran]^^.ErrFlag:=False;            PEcr.Ecrans[NumEcran]^^.hTE:=hTe;            { restauration de l'ecran en cours }            LgCode:=XLgCode;            NbVar:=XNbVar;            NbCst:=XNbCst;            CodeHdle:=XCodeHdle;            VarTab:=XVarHdle;            CstTab:=XCstHdle;            ErrFlag:=XErrFlag;            hTE:=XhTe;        END;    Modification:=False;    InvalRect(EditRect);    InvalRect(JeuRect);    SetPort(PEcr.Ecrans[NumEcran]^^.Wedit);    InvalRect(PEcr.Ecrans[NumEcran]^^.Wedit^.PortRect);    SetRect(PEcr.Ecrans[NumEcran]^^.hte^^.destrect,4,0,1080,32767);    TESetSelect (0,0,PEcr.Ecrans[NumEcran]^^.hTE);    TECalText (PEcr.Ecrans[NumEcran]^^.hTE);    PEcr.Ecrans[NumEcran]^^.Numero[1]:=0;    PEcr.Ecrans[NumEcran]^^.Numero[2]:=0;    SetPRect(PEcr.Ecrans[NumEcran]^^.Wedit);    i:=PEcr.Ecrans[NumEcran]^^.hTE^^.nlines       - ((TeRect.bottom - TeRect.top) DIV PEcr.Ecrans[NumEcran]^^.hTE^^.lineHeight)       + 2;    IF i<0 THEN i:=0;    SetCtlMax(PEcr.Ecrans[NumEcran]^^.MonControl[1],i);    SetCtlMax(PEcr.Ecrans[NumEcran]^^.MonControl[2],180);    SetCtlValue (PEcr.Ecrans[NumEcran]^^.MonControl[1],0);    SetCtlValue (PEcr.Ecrans[NumEcran]^^.MonControl[2], 0);    SetPort(SavePort);END;{========================================================================                            N E W S C R E E N ========================================================================}PROCEDURE NewScreen(WindPos:BOOLEAN);VAR	i       		: integer;		WPoint  		: Point;		TR      		: Rect;		Hs      		: HandleEcran;		SavePort		: GrafPtr;		theRes			: Handle;		TEDestRect	: Rect;		BEGIN		GetPort(SavePort); 		{ nouvelle fenetre }		PEcr.NbEcran:=PEcr.NbEcran+1;		PEcr.Ecrans[PEcr.NbEcran]:=HandleEcran(NewHandle(sizeof(Ecran)));		HNoPurge(Handle(PEcr.Ecrans[PEcr.NbEcran]));		Hs:=PEcr.Ecrans[PEcr.NbEcran];		HLock(Handle(Hs));     WITH Hs^^ DO    BEGIN			{ fenetre VideoTex }			WEcran:=GetNewWindow(256,Nil,pointer(-1));			SetWRefCon(WEcran,VRef);			WPoint.h:=PEcr.NbEcran*25;			WPoint.v:=20+PEcr.NbEcran*25;			SSel:=0;			ESel:=0;      theRes := NIL;						IF WindPos THEN			BEGIN				SetResLoad(TRUE);				theRes := Get1Resource(WPosResType,128);				IF (ResError = NoErr) & (theRes<>NIL) THEN				BEGIN					HLock(theRes);					WITH WindPosHdl(theRes)^^.Window1,WindPosHdl(theRes)^^ DO					BEGIN						IF GoodWindow(Window1) THEN						BEGIN							WPoint.h:=left;							WPoint.v:=top;						END;												SelStart := 0;						SelEnd := 0;						ESel := 0;						SSel := 0;					END;				END;			END;						MoveWindow(WEcran,WPoint.h,WPoint.v,False);			{ valeurs par defaut }			FileName:='';			VolNumber:=0;			DirID := 0;			SelRgn:=NewRgn;			Couleur:=7;			BCouleur:=0;			Jeu:=0;			Taille:=0;			Clignotement:=False;			Disjoint:=False;			Masquage:=False;			Inverse:=False;			Incrust:=False;			IdleFlag:=False;			FOR i:=0 TO nbcar DO				Cars[i]:=CarNeutre;			Modification:=False;			ErrFlag:=True;			NbVar:=0;			NbCst:=0;			LgCode:=0;						mode:=EditModeCst; { edit mode }			WPict:=Nil;						CodeHdle:=TParamHandle(NewHandle(0));			HNoPurge(Handle(CodeHdle));			VarTab:=HVarRes(NewHandle(0));			HNoPurge(Handle(VarTab));			CstTab:=HCstRes(NewHandle(0));			HNoPurge(Handle(CstTab));						HasMoved := FALSE;			{ fenetre d'edition Basic }			WEdit:=GetNewWindow(257,Nil,pointer(-1));			SetWRefCon(WEdit,ERef);			WPoint.h := WPoint.h+9;			WPoint.v := WPoint.v+20;						IF WindPos & (theRes <> NIL) THEN			BEGIN				WITH WindPosHdl(theRes)^^.Window2,WindPosHdl(theRes)^^ DO				BEGIN					IF GoodWindow(Window2) THEN					BEGIN						WPoint.h:=left;						WPoint.v:=top;						SizeWindow(WEdit,Right-Left,bottom-top,FALSE);					END;				END;				HUnlock(theRes);				ReleaseResource(theRes);			END;			MoveWindow(WEdit,WPoint.h,WPoint.v,False);			SetPort(Wedit);			FOR I := 1 TO 2 DO			BEGIN					monControl[I] := GetNewControl (255 + I, WEdit);					Numero[I] := 0;			END;			tR := WEdit^.portRect;			WITH monControl[1]^^.contrlRect DO			BEGIN				top     := tR.top - 1;				left    := tR.right - 15;				bottom  := tR.bottom - 14;				right   := tR.right + 1;			END;			WITH monControl[2]^^.contrlRect DO			BEGIN				top     := tR.bottom - 15;				left    := tR.left - 1;				bottom  := tR.bottom + 1;				right   := tR.right - 14;			END;			SetCtlMax(MonControl[1],0);			FOR I := 1 TO 2 DO			BEGIN					ShowControl (monControl[I]);					HiliteControl (monControl[I], 255);			END;			SetpRect(Wedit);			TextFont(22104);			TextSize(9);						SetRect(TEDestRect,4,0,1080,32767);						hte:=TeNew(TEDestRect,TeRect);			hte^^.cronly:=-1;{$IFC DRAGANDDROP}			IF gHasDrag THEN	{ •• 4/2/94 •• }			BEGIN				Err := InstallTrackingHandler(@DoDragTrack, WEdit, Hs);				IF Err=NoErr THEN Err := InstallReceiveHandler (@DoDragReceive, WEdit, Hs);			END;{$ENDC}		END;    HUnlock(Handle(Hs));    SetPort(SavePort);    IF WVidFlag THEN			IF WBasFlag THEN			BEGIN				ShowWindow(Hs^^.WEdit);				SelectWindow(Hs^^.WEdit);				ShowWindow(Hs^^.WEcran);			END			ELSE			BEGIN				ShowWindow(Hs^^.WEcran);				SelectWindow(Hs^^.WEcran);			END    ELSE      IF WBasFlag THEN			BEGIN				ShowWindow(Hs^^.WEdit);				SelectWindow(Hs^^.WEdit);			END;END;PROCEDURE SaveDocWindPos;VAR	PB: HParamBlockRec;	theOldDate: LONGINT;	OldVol: INTEGER;	theRes: Handle;	theFile: INTEGER;	BEGIN	{ on lit la date de modif du fichier }	WITH PB DO	BEGIN		ioCompletion := NIL;		ioNamePtr := @Screen^.filename;		ioVRefnum := Screen^.VolNumber;		ioDirID := Screen^.DirID;		IoFDirIndex := 0;	END;	Err := PBHGetFInfo(@PB,FALSE);	IF Err = NoErr THEN	BEGIN		theOldDate := PB.ioFlMdDat;		IF PB.ioFlRLgLen = 0 THEN         BEGIN			WITH Screen^ DO HCreateResFile(VolNumber,DirID,filename);			err := ResError;		END;		WITH Screen^ DO theFile := HOpenResFile(VolNumber,DirID,filename,fsRdWrPerm);		theRes := Get1Resource('WPOS',128);		IF theRes <> NIL THEN RmveResource(theRes);		theRes := NewHandle(SizeOf(WindPosRec));		HLock(theRes);		WITH WindPosHdl(theRes)^^ DO		BEGIN		  Ecran := qd.ScreenBits.Bounds;		  Window1 := WindowPeek(Screen^.WEcran)^.contRgn^^.rgnBBox;	{ Basic }		  Window2 := WindowPeek(Screen^.WEdit)^.contRgn^^.rgnBBox;	{ Vidéotex }		  SelStart := Screen^.sSel;		  SelEnd := Screen^.eSel;		END;		AddResource(theRes,WPosResType,128,'');		CloseResFile(theFile);				{ on remet la date/heure de modif à la valeur d'origine }		WITH PB DO		BEGIN			ioCompletion := NIL;			ioNamePtr := @Screen^.filename;			ioVRefnum := Screen^.VolNumber;			ioDirID := Screen^.DirID;			IoFDirIndex := 0;		END;		Err := PBHGetFInfo(@PB,FALSE);		WITH PB DO		BEGIN			ioCompletion := NIL;			ioNamePtr := @Screen^.filename;			ioVRefnum := Screen^.VolNumber;			ioDirID := Screen^.DirID;			IoFDirIndex := 0;			ioFlMdDat := theOldDate;		END;		Err := PBHSetFInfo(@PB,FALSE);	END;END;	{ SaveDocWindPos }{========================================================================                            O P E N S C R E E N ========================================================================}PROCEDURE OpenScreen;VAR	i					: integer;	prompt		: str255;	NumTypes	: Integer;	TypeList	: SFTypeList;	FileDest	: SFReply;	theFile		: INTEGER;	theSFR		: StandardFileReply;	{ <7.0> }	BEGIN	NumTypes:=1;	TypeList[0]:=MonType;	GetIndString(Prompt,256,2);	ParamText(Prompt,'','','');	IF gNewSF THEN		StandardGetFile(NIL,NumTypes,@TypeList,theSFR)	ELSE	BEGIN		SFGetFile(CenterSF(getDlgID),'',Nil,NumTypes,@TypeList,Nil,FileDest);    WITH theSFR DO		BEGIN			sfgood := fileDest.Good;			IF sfGood THEN			BEGIN				sfFile.Name := fileDest.Fname;				sfFile.VRefNum := fileDest.vRefNum;				sfFile.ParID := 0;			END;		END;	END;		IF theSFR.sfgood THEN	BEGIN		WITH theSFR.sfFile DO		BEGIN			IF VerifScreen(vRefNum,parID ,Name, FALSE) THEN EXIT(OpenScreen);			theFile :=HOpenResFile(vRefNum,parID ,Name,fsRdPerm);		END;		NewScreen(theFile<>-1);		IF theFile <> -1 THEN CloseResFile(theFile);		PEcr.Ecrans[PEcr.NbEcran]^^.FileName:=theSFR.sfFile.Name;		PEcr.Ecrans[PEcr.NbEcran]^^.VolNumber:=theSFR.sfFile.vRefNum;		PEcr.Ecrans[PEcr.NbEcran]^^.DirID:=theSFR.sfFile.ParID;		ReadScreen(PEcr.NbEcran);		Prompt:=theSFR.sfFile.Name;		SetWTitle(PEcr.Ecrans[PEcr.NbEcran]^^.WEcran,Concat(Prompt,' (Videotex)'));		SetWTitle(PEcr.Ecrans[PEcr.NbEcran]^^.WEdit,Concat(Prompt,' (Basic)'));	END;END;FUNCTION OpenthisScreen(thisfile:FSSpec):BOOLEAN;VAR	theFile: INTEGER;		infos: FInfo;		BEGIN		OpenThisScreen := FALSE;		WITH thisfile DO 		BEGIN			{ ecran deja ouvert et au bon format ? }			IF VerifScreen(vRefNum,parID ,Name, FALSE) THEN EXIT(OpenthisScreen);			theFile :=HOpenResFile(vRefNum,parID ,Name,fsRdPerm);		END;				OpenThisScreen := TRUE;	{ on a pu ouvrir le fichier }		NewScreen(theFile<>-1);		IF theFile <> -1 THEN CloseResFile(theFile);		PEcr.Ecrans[PEcr.NbEcran]^^.FileName:=thisfile.Name;		PEcr.Ecrans[PEcr.NbEcran]^^.VolNumber:=thisfile.vRefNum;		PEcr.Ecrans[PEcr.NbEcran]^^.DirID:=thisfile.ParID;		ReadScreen(PEcr.NbEcran);		SetWTitle(PEcr.Ecrans[PEcr.NbEcran]^^.WEcran,Concat(thisfile.Name,' (Videotex)'));		SetWTitle(PEcr.Ecrans[PEcr.NbEcran]^^.WEdit,Concat(thisfile.Name,' (Basic)'));END;{========================================================================                            S T S C R E E N ========================================================================}FUNCTION StScreen: boolean;VAR	i			: integer;	TypeList    : SFTypeList;	FileDest    : AppFile;	TpOpen,	NbMax,	NbOp		: integer;	prompt		: str255;	termine		: boolean;	theFile		: INTEGER;BEGIN	CountAppFiles(TpOpen,NbMax);	i:=0; termine:=(i=NbMax); NbOp:=0;	WHILE NOT termine DO	BEGIN		i:=i+1;		GetAppFiles(i, FileDest);		WITH FileDest DO		IF fType=MonType THEN		BEGIN        	theFile := OpenRFPerm(filedest.fname,filedest.vrefnum,fsRdPerm);			Err := ResError;			NewScreen(theFile<>-1);			IF theFile <> -1 THEN CloseResFile(theFile);            PEcr.Ecrans[PEcr.NbEcran]^^.FileName:=FileDest.fName;            PEcr.Ecrans[PEcr.NbEcran]^^.VolNumber:=FileDest.vRefNum;            PEcr.Ecrans[PEcr.NbEcran]^^.DirID:=0;            ReadScreen(PEcr.NbEcran);            Prompt:=FileDest.fName;            SetWTitle(PEcr.Ecrans[PEcr.NbEcran]^^.WEcran,Concat(Prompt,' (Videotex)'));            SetWTitle(PEcr.Ecrans[PEcr.NbEcran]^^.WEdit,Concat(Prompt,' (Basic)'));			NbOP:=NbOP+1;		END;		Termine:=(i=NbMax) OR (NbOp=1);	END;	StScreen:=NbOp>0;END;PROCEDURE SaveS;	{ enregistre un écran analysé ou non }VAR	Count		: longint;	Err			: integer;	refw		: integer;	txtLength,	TheTeLength	: longint;	TheVCode	: Handle;	Vlg			: longint;	BEGIN    IF NOT Modification THEN EXIT(SaveS);    { ouverture du fichier }		WITH Screen^ DO Err:=HOpen(VolNumber,DirID,filename,fsRdWrPerm,RefW);			IF (Err<>0) THEN	BEGIN    	ErrorManager(Err,0);		EXIT(SaveS);	END;	{ •• Enregistrement du code vidéotex •• }	TheVCode:=Compact(Screen^.Cars);	UnloadSeg(@InitVWork);	{ COMPOSEUR }	Vlg:=GetHandleSize(TheVCode);	Count:=SizeOf(Longint);	Err:=FSWrite(RefW,count,@Vlg);	IF (Err<>0) THEN ErrorManager(Err,201);	Count:=Vlg;	Err:=FSWrite(RefW,count,TheVCode^);	IF (Err<>0) THEN ErrorManager(Err,202);	DisposHandle(TheVCode);	{ •• Enregistrement éventuel du source •• }		IF ErrFlag THEN	BEGIN		{ source non analysé }		TheTeLength:=hTe^^.TeLength;		{ tables bidons }		NbCst:=0;		NbVar:=0;		LgCode:=0;		SetHSize(Handle(VarTab),0);		SetHSize(Handle(CstTab),0);		SetHSize(Handle(CodeHdle),0);	END	ELSE		TheTeLength:=0;		{ source analysé, on n'enregistre pas le texte en clair }	WITH hTE^^ DO	BEGIN		count:=sizeof(Longint);		txtLength := TheTeLength;		Err := FSWrite (RefW, count, @TxtLength);	{ longueur du source en clair }		IF (Err<>0) THEN ErrorManager(Err,202); 		txtLength := TheTeLength;		Err := FSWrite (RefW, txtLength, hText^);	{ enr. du source en clair }		IF (Err<>0) THEN ErrorManager(Err,203);	END; 	{ •• Enregistrement des variables •• }	count:=sizeof(Integer);	Err := FSWrite (RefW, count, @Nbvar);	IF (Err<>0) THEN ErrorManager(Err,204); 	count := SizeOf(TVar)*NbVar;	Err := FSWrite (RefW, count, Ptr(VarTab^));	IF (Err<>0) THEN ErrorManager(Err,205); 	{ •• Enregistrement des constantes chaine •• }	count:=sizeof(Integer);	Err := FSWrite (RefW, count, @NbCst);	IF (Err<>0) THEN ErrorManager(Err,206); 	count := SizeOf(Str64)*NbCst;	Err := FSWrite (RefW, count, Ptr(CstTab^));	IF (Err<>0) THEN ErrorManager(Err,207); 	{ •• Enregistrement du code analysé •• }	count:=sizeof(Integer);	Err := FSWrite (RefW, count, @LgCode);	IF (Err<>0) THEN ErrorManager(Err,208); 	count := LgCode;	Err := FSWrite (RefW, count, Ptr(CodeHdle^));	IF (Err<>0) THEN ErrorManager(Err,209); 	{ •• petit SetEOF pour viré ce qui dépasse… •• }	Err := SetEOF (RefW,  sizeof(longint)+Vlg                         +sizeof(longint)+TheTeLength                         +SizeOf(Integer)+SizeOf(TVar)*NbVar                         +SizeOf(Integer)+SizeOf(Str64)*NbCst                         +SizeOf(Integer)+lgcode                  );	IF (Err<>0) THEN ErrorManager(Err,210);	Err:=FSClose(RefW);	IF (Err<>0) THEN	BEGIN		ErrorManager(Err,211);		EXIT(SaveS);	END;	{ •• Sécurité, sécurité !! •• }	Err:=FlushVol(Nil,Screen^.VolNumber);	IF (Err<>0) THEN ErrorManager(Err,212);	Modification:=False;END;FUNCTION CloseScreen(forceClose:BOOLEAN):BOOLEAN;VAR i:integer;	theWind: WindowPtr;	BEGIN	CloseScreen := FALSE;	IF FrontWindow = NIL THEN	BEGIN		PEcr.NbEcran := 0;		EXIT(CloseScreen);	END;		IF NOT(GetWRefCon(FrontWindow) IN [ERef,VRef]) THEN	BEGIN		HideWindow(FrontWindow);		SendBehind(FrontWindow,Nil);		EXIT(CloseScreen);	END;		SelFen(FrontWindow);		IF forceClose=FALSE THEN	BEGIN		IF ErrFlag THEN { source non analysé }		BEGIN			theWind := FrontWindow;			IF Screen^.filename = '' THEN			BEGIN				GetIndString(gResStr,rSTRErrors,18);	{ sans titre }				ParamText(gResStr,'','','');			END			ELSE				ParamText(Screen^.Filename,'','','');	{ nom d'écran courant }			CASE MyAlert(137) OF				1:					BEGIN { oui }						SelFen(theWind);						Closing := TRUE;						DoBasic(OffSyntax);						IF ErrFlag THEN EXIT(CloseScreen);						SelFen(theWind);						IF Screen^.filename = '' THEN SaveUnder;						Modification := FALSE;	{ analyse réussie }					END;				3:	EXIT(CloseScreen); { Annuler }			END;			SelFen(theWind);		END;				SaveSelFen;		Curoff(FrontWindow);	    IF Modification THEN	    CASE Abort OF				1: SaveScreen;				3: EXIT(CloseScreen);	    END;		IF HasMoved THEN SaveDocWindPos;	END;	{ IF forceClose=FALSE }	{$IFC DRAGANDDROP}	IF gHasDrag THEN		{ •• 4/2/94 •• }	BEGIN		Err := RemoveReceiveHandler (@DoDragReceive, Editptr);		Err := RemoveTrackingHandler(@DoDragTrack, EditPtr);	END;{$ENDC}	{ destruction des structures correspondantes }	{ fenetres }	IF Hte <> NIL THEN TeDispose(Hte);	DisposeRgn(SelRgn);	DisposeWindow(Screenptr);	KillControls (EditPtr);	DisposeWindow(Editptr);	Hte:=Nil;	ScreenPtr:=Nil;	EditPtr:=Nil;	IF VarTab <> NIL THEN DisposHandle(Handle(VarTab));	VarTab:=NIL;	IF CstTab <> NIL THEN DisposHandle(Handle(CstTab));	CstTab:=NIL;	IF CodeHdle <> NIL THEN DisposHandle(Handle(CodeHdle));	CodeHdle := NIL;	HUnlock(Handle(PEcr.Ecrans[CurrentS]));	IF PEcr.Ecrans[CurrentS] <> NIL THEN DisposHandle(Handle(PEcr.Ecrans[CurrentS]));	PEcr.Ecrans[CurrentS]:=NIL;	{ decalage dans le pool ecran }	IF CurrentS<>PEcr.NbEcran THEN		FOR i:=CurrentS TO PEcr.NbEcran-1 DO			PEcr.Ecrans[i]:=PEcr.Ecrans[i+1];	PEcr.NbEcran:=PEcr.NbEcran-1;	{ selection de la frontwindow dans le pool }	SelFen(FrontWindow);	{	If PEcr.NBecran>0 then       begin        SendBehind(gdebugwindowptr,Nil);       end else       Modification:=false;	}	CloseScreen := TRUE;END;PROCEDURE SaveUnder;VAR i: integer;		prompt: str255;		FileDest: SFReply;		theSFR: StandardFileReply;	{ <7.0> }		BEGIN	Curoff(FrontWindow);	GetIndString(Prompt,256,1);	IF gNewSF THEN		StandardPutFile(Prompt,Screen^.fileName,theSFR)	ELSE	BEGIN		SFPutFile(CenterSF(putDlgID),Prompt,'',Nil,FileDest);		theSFR.sfGood := fileDest.good;		IF theSFR.sfGood THEN		BEGIN			theSFR.sfFile.name := fileDest.fName;			theSFR.sfFile.vRefNum := fileDest.vRefNum;			theSFR.sfFile.ParID := 0;		END;	END;		SaveSelFen;	{ nom déjà utilisé par un écran ouvert -> on ferme l'écran ouvert }	WITH theSFR.sfFile DO		IF VerifScreen (vRefNum, parID, Name, TRUE) THEN			IF CloseScreen(TRUE) THEN;		IF theSFR.sfgood THEN	BEGIN		{ attendre ...}		SetCursor(WCurs^^);		NameFlag:=True;		{ suppression du fichier }		WITH theSFR.sfFile DO Err:=HDelete(vRefNum,ParID,Name);		IF (Err<>0) AND (Err<>fnfErr) THEN		BEGIN				ErrorManager(Err,0);				EXIT(SaveUnder);		END;		{ creation du fichier si celui-ci n'existe pas }		WITH theSFR.sfFile DO Err:=HCreate(vRefNum,ParID,Name,MonCreator,MonType);		IF (Err<>0) AND (Err<>DupFNErr) THEN		BEGIN				ErrorManager(Err,1000);				EXIT(SaveUnder);		END;		{ sauvegarde du fichier }		Modification:=True;		WITH theSFR.sfFile DO		BEGIN			Screen^.FileName:=Name;			Screen^.VolNumber:=vRefNum;			Screen^.DirID:=ParID;		END;		SaveS;		{ nom du fichier -> nom des fenêtres }		SetWTitle(ScreenPtr, Concat(Screen^.FileName,' (Videotex)'));		SetWTitle(EditPtr, Concat(Screen^.FileName,' (Basic)'));	END;END;PROCEDURE SaveScreen;BEGIN    Curoff(FrontWindow);    IF Screen^.FileName='' THEN       BEGIN        SaveUnder;        EXIT(SaveScreen);       END;    SetCursor(WCurs^^);    SaveS;END;PROCEDURE DupScreen;VAR	i			: integer;	prompt		: str255;	NumTypes	: Integer;	TypeList    : SFTypeList;	FileDest    : SFReply;	theSFR		: StandardFileReply;	{ <7.0> }	theFile		: INTEGER;BEGIN    Curoff(FrontWindow);    NumTypes:=1;    TypeList[0]:=MonType;	    IF gNewSF THEN		StandardGetFile(NIL,NumTypes,@TypeList,theSFR)	ELSE	BEGIN		SFGetFile(CenterSF(getDlgID),'',Nil,NumTypes,@TypeList,Nil,FileDest);    	WITH theSFR DO		BEGIN			sfgood := fileDest.Good;			IF sfGood THEN			BEGIN				sfFile.Name := fileDest.Fname;				sfFile.VRefNum := fileDest.vRefNum;				sfFile.ParID := 0;			END;		END;	END;		IF theSFR.sfgood THEN	BEGIN		WITH theSFR.sfFile DO theFile :=HOpenResFile(vRefNum,parID ,Name,fsRdPerm);		NewScreen(theFile<>-1);		IF theFile <> -1 THEN CloseResFile(theFile);		PEcr.Ecrans[PEcr.NbEcran]^^.FileName:=theSFR.sfFile.Name;		PEcr.Ecrans[PEcr.NbEcran]^^.VolNumber:=theSFR.sfFile.vRefNum;		PEcr.Ecrans[PEcr.NbEcran]^^.DirID:=theSFR.sfFile.ParID;		ReadScreen(PEcr.NbEcran);		PEcr.Ecrans[PEcr.NbEcran]^^.FileName:='';		PEcr.Ecrans[PEcr.NbEcran]^^.VolNumber:=0;		PEcr.Ecrans[PEcr.NbEcran]^^.DirID:=0;	END;END;PROCEDURE RevertScreen;BEGIN    IF Modification THEN       CASE Abort OF        1:SaveScreen;        2: ;        3: EXIT(RevertScreen);       END;    ReadScreen(CurrentS);END;{========================================================================                        S U P S C R E E N ========================================================================}PROCEDURE SupScreen;    VAR count		: longint;		refw		: integer;        Vlg			: longint;        TheVCode    : Handle;        prompt		: str255;        NumTypes	: Integer;        TypeList    : SFTypeList;        FileDest    : SFReply;		Err			: OSErr;BEGIN    Curoff(FrontWindow);    NumTypes:=1;    TypeList[0]:=MonType;    GetIndString(Prompt,256,3);    ParamText(Prompt,'','','');    SFGetFile(CenterSF(getDlgID),'',Nil,NumTypes,@TypeList,Nil,FileDest);    IF NOT FileDest.good THEN		EXIT(SupScreen);		    SetCursor(WCurs^^);    Err:=FSOpen(FileDest.fName,                FileDest.vRefNum,                RefW);    IF (Err<>0) THEN       BEGIN        ErrorManager(Err,0);        EXIT(SupScreen);       END;	  BEGIN { mode compacte }            Count:=SizeOf(Longint);            Err:=FSRead(RefW,count,@Vlg);            IF (Err<>0) THEN               BEGIN                ErrorManager(Err,102);                Vlg:=0;               END;            TheVCode:=NewHandle(Vlg);            HNopurge(TheVCode);            Err:=FSRead(RefW,Vlg,TheVCode^);            IF (Err<>0) THEN               BEGIN                ErrorManager(Err,103);                SetHSize (TheVCode,0);               END;            HLock(Handle(PEcr.Ecrans[CurrentS]));            Decompact(PEcr.Ecrans[CurrentS]^^.Cars,TheVCode);            UnloadSeg(@InitVWork);	{ COMPOSEUR }            DisposHandle(TheVCode);			InValRect(ScreenPtr^.PortRect);    END;    Err:=FSClose(RefW);    IF (Err<>0) THEN       BEGIN        ErrorManager(Err,1);       END;END;