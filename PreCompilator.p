UNIT PreCompilator;INTERFACEUSES	MemTypes, QuickDraw, OSIntf, ToolIntf, Sane, MacPrint, packages, AppleTalk, ADSP,		StandardFile,		WritelnWindow, DragsterIO, TokDetok, Trace, Compilator;	CONST		PreCompType = 'TOKN';		PreCompType2 = 'TOKn';	{ version "PackBitée" }			TYPE		TOKNrec = RECORD			NbVars: LONGINT;			NbCst: LONGINT;			SizeTokens: LONGINT;			KeyTOKN: LONGINT;		END;				TOKNPtr = ^TOKNrec;		TOKNh = ^TOKNPtr;				DataR = RECORD			Info: PACKED ARRAY[0..65536] OF CHAR;		END;		DataP = ^DataR;		DataH = ^DataP;		(*		INFORec = RECORD			Version: INTEGER;			ModDate: LONGINT;		END;				INFOPtr = ^INFOrec;		INFOh = ^INFOPtr;*)	VAR		Error: INTEGER;				FUNCTION PreCodeGen(PROCEDURE HandleEvent(theEvent:EventRecord);VAR CodeName: Str64; VolNum: Integer; DirID:LONGINT): Integer;	IMPLEMENTATION		USES TextUtils,			{$U $$Shell(PUtilities) }Utilities;				CONST			{ on recupere les constantes des tokens }			{$I TkTokenCst.p}			US = chr(31);			CAN = chr(24);			FF = chr(12);			REP = chr(18);			ESC = chr(27);			SP = chr(32);			SO = chr(14);			SI = chr(15);			SS2 = chr(22);			RS = chr(30);			DC1 = chr(17);			DC4 = chr(20);			kCreatorbis = 'DRG1';			kCreator = 'DRG0';			kType = 'PCOD';			IntSize = 4;			StrSize = 256;						{$I DragsterTCB.p }		TYPE			RecEt = RECORD								FlagDefined: Boolean;								LastOffset: Integer;							END;			TRecEt = ARRAY [1..MaxEtiq] OF RecEt;			PRecEt = ^TRecEt;			HRecEt = ^PRecEt;			RICstRes = ARRAY [1..MaxCst] OF Longint;			PICstRes = ^RICstRes;			HICstRes = ^PICstRes;						{ tableau de chaines… }	        TSRecord	= ARRAY [0..1000] OF Str255;		{ dynamique }	        TSP	     	= ^TSRecord;	        TSHandle	= ^TSP;			TVRecord = ARRAY [0..8000] OF Longint;			TVP = ^TVRecord;			TVHandle = ^TVP;			TGScreen = RECORD									 NomScreen: StringHandle;									 OffsetCode, OffsetVcode: Longint;									 FlagProcessed: Boolean;	{ indique si l'écran a été compilé }									 FlagMissing: Boolean;		{ indique si l'écran est manquant }									 FlagAnalyse: Boolean;								 END;			TgBScreen = RECORD										NbScreens: Integer;										TheScreens: ARRAY [1..1200] OF TGScreen;									END;			PTgScreen = ^TgBScreen;			HTgScreen = ^PTgScreen;			BPtr = ^Char;			IPtr = ^Integer;			LPtr = ^Longint;			ExtTable = ARRAY [1..100] OF INTEGER;								VAR			TheGScreen: HTgScreen; { Pool de noms d'ecran }			TheCCode: TparamHandle; { handle du code BASIC tokenisé }			TheCCsts: HCstRes; { constantes locales }			CurVol: Integer; { Volume du premier nom }			NumCode: INTEGER;						theEvent: EventRecord;			StartTime: Longint;			EndTime: Longint;			Chaine: Str255;			BGFlag: BOOLEAN;	{ indique si on est en arrière plan ou non }			SleepValue: INTEGER;	{ valeur de sleep pour WaitNextEvent }					PROCEDURE InstXCute(e: TParamPtr);			FORWARD;		PROCEDURE ListeXCute(e: TParamPtr);			FORWARD;{==============================================================================}{ 											 U T I L I T A I R E S																 }{==============================================================================}{$S PRECOMPILATEUR}{ Rend le token suivant }PROCEDURE NextCompToken(VAR e:TParamPtr;offset:LONGINT);BEGIN	e:= TParamPtr(Ord4(e)+offset);END;		PROCEDURE CheckMem;BEGIN	IF MemError <> NoErr THEN	BEGIN		WWLnStr('');		WWLnStr('');		WWLnStr('Erreur en cours de compilation');		WWLnStr('Mémoire saturée - utiliser la compilation disque');		WWLnStr('');		ErrFlag := TRUE;		Error := MemError;	END;END;FUNCTION PreCodeGen;VAR	i,j,n,Numvar: Integer;	NoMoreGen: Boolean;	TheXConf: XFileRecord;	TheOffs: THOffScreen;	TheSNames: Handle;	Err: OsErr;	prompt: Str255;	fname: Str255;	FileDest: SFReply;	RefW: Integer;	CurTime: Longint;	StrList: Handle;	PBAnalyse: INTEGER;	{ nombre d'écrans non analysés }	ResFile: INTEGER;	secs: LONGINT;	{ pour l'ajout de la ressource 'DATE' }		gNbNoComp: INTEGER;	NoComp: ARRAY [1..10] OF StringHandle;		PROCEDURE ErrorManager(Error: OsErr; from: Integer);		CONST			Debug = false;		VAR			temp: Integer;			monDialog: DialogPtr;			ErrorStr, TempS: Str255;		BEGIN			CASE Error OF				DirFulErr: GetIndString(ErrorStr, 257, 1);				DskFulErr: GetIndString(ErrorStr, 257, 2);				WPrErr: GetIndString(ErrorStr, 257, 3);				OTHERWISE					BEGIN					NumToString(Error, TempS);					GetIndString(ErrorStr, 257, 4);					ErrorStr := Concat(ErrorStr, ' ', TempS);					END;			END;			ParamText(ErrorStr, '', '', '');			monDialog := GetNewDialog(257, NIL, POINTER( - 1));			CenterDlog(monDialog);			REPEAT				ModalDialog(NIL, temp);			UNTIL temp = 1;			DisposDialog(monDialog);		END;	PROCEDURE LoadCode(NumCC: Integer);		VAR		count: Longint;		Err: OsErr;		RefW: Integer;		OffMax, OffCode, lgtext: Longint;		NbVar, NbCst, LgCode: Integer;		Vlg: Longint;		Trouve: Boolean;		TheStr: Pstr255;		Numvar,i,j: Integer;		e: TParamPtr;		L: Longint;		theRes: HANDLE;		theRes2: Handle;		ModName: Str255;		Cle: CHAR;		Pb: ParamBlockRec;		Changed: BOOLEAN;	{ indique si le source a été modifié depuis la dernière précompil }		TempKey: LONGINT;		infos: FInfo;(*		PackRes: Handle;		PackStart: Ptr;		PackEnd: Ptr;*)				FUNCTION GetLongint: LONGINT;		{ lit un LONGINT depuis le fichier vidéotex RefW }				VAR	L:LONGINT;				L2:LONGINT;		BEGIN			L2 := Sizeof(Longint);			Err := FSRead(RefW, L2, @L);			IF (Err <> 0) THEN			BEGIN				WWriteStr('Pb lecture, erreur=');				WWLnNum(Err,0);				ErrFlag := TRUE;				Error := Err;				L := 0;			END;			GetLongint := L;		END;				FUNCTION GetInteger: INTEGER;		{ lit un INTEGER depuis le fichier vidéotex RefW }				VAR	L:INTEGER;				L2:LONGINT;		BEGIN			L2 := Sizeof(INTEGER);			Err := FSRead(RefW, L2, @L);			IF (Err <> 0) THEN			BEGIN				WWriteStr('Pb lecture, erreur=');				WWLnNum(Err,0);				ErrFlag := TRUE;				Error := Err;				L := 0;			END;			GetInteger := L;		END;						PROCEDURE MsgBadType;				BEGIN			WWLnStr('');			WWriteStr('Le fichier "');			WWriteStr(ModName);			WWLnStr('" n''est pas au format Dragster !');			ErrFlag := TRUE;			EXIT(LoadCode);		END;		BEGIN 		Changed := TRUE;				NumCode := NumCC; 		ModName := TheGScreen^^.TheScreens[NumCC].NomScreen^^;				IF NamesFlag THEN			WWLnStr(ModName)		ELSE		BEGIN			WWriteStr('.');			IF NumCC MOD 50 = 0 THEN WWLnStr('');		END;		{ on regarde si c'est un fichier à ne pas inclure en précompil }		FOR i := 1 TO gNbNoComp DO		BEGIN			IF EqualString(ModName, NoComp[i]^^, FALSE, TRUE) THEN			BEGIN				TheGScreen^^.TheScreens[NumCC].FlagMissing := TRUE;				EXIT(LoadCode);			END;		END;		IF ModName[1]='•' THEN		BEGIN			TheGScreen^^.TheScreens[NumCC].FlagMissing := TRUE;			EXIT(LoadCode);		END;				{ vérification du type de fichier… }		Err := HGetFInfo(CurVol,DirId,ModName,infos);		IF (Err=NoErr) & (infos.fdType<>'VCOD') THEN MsgBadType;				Err := HOpen(CurVol,DirId,ModName, fsRdPerm, RefW);		IF (Err <> 0) THEN		BEGIN			{ vérif. du type de fichier }			Err := GetFInfo(ModName,0,infos);			IF (Err=NoErr) & (infos.fdType<>'VCOD') THEN MsgBadType;			Err := HOpen(0,0,ModName, fsRdPerm, RefW);			IF (Err <> 0) THEN			BEGIN				TheGScreen^^.TheScreens[NumCC].FlagMissing := TRUE;				EXIT(LoadCode);			END		END;(* 		WITH PB DO		BEGIN			ioCompletion := NIL;			ioNamePtr := @ModName;			ioVRefNum := CurVol;			ioFVersNum := 0;			ioFDirIndex := 0;		END;		Err := PBGetFinfo(@Pb,FALSE);		IF Err=NoErr THEN		BEGIN			theRes := GetNamedResource('INFO',ModName);			IF ResError = NoErr THEN			WITH INFOh(theRes)^^DO			BEGIN				IF Version = 1 THEN					IF ModDate = pb.ioFlMdDat THEN Changed := FALSE;				ReleaseResource(theRes);			END;		END		ELSE PB.ioFlMdDat := 0;*)				{ code VideoTex compacté }				Vlg := GetLongint;		IF Vlg > 0 THEN		BEGIN			theRes := NewHandle(Vlg);			Err := FSRead(RefW,Vlg,theRes^);			IF (Vlg > 1) & Changed THEN			BEGIN				AddResource(theRes,'VCOD',NumCC,ModName);				WriteResource(theRes);				HUnlock(theRes);				ReleaseResource(theRes);			END			ELSE DisposHandle(theRes);		END; 		{ on skippe le source si il est là }		LgText := GetLongint;		IF (lgtext > 0) THEN	{ pas analysé ! }		BEGIN			{ErrorManager(Err,103);}			TheGScreen^^.TheScreens[NumCC].FlagAnalyse := TRUE;			PbAnalyse := PbAnalyse + 1;			IF PbAnalyse = 1 THEN WWLnStr('Ecran(s) non analysé(s):');			WWLnStr(TheGScreen^^.TheScreens[NumCC].NomScreen^^);			Err := FSClose(RefW);			EXIT(LoadCode);		END; 		theRes := NewHandle(65536);	{ 64Ko maxi }		IF theRes = NIL THEN		BEGIN			Error := MemError;			ErrFlag := TRUE;			WWLnStr('');			WWLnStr('Saturation mémoire !');			EXIT(LoadCode);		END;				MoveHhi(theRes);		HLock(theRes);		L := SizeOf(TOKNRec);				{ lecture de la table de variables }		TOKNh(theres)^^.NbVars := GetInteger;		IF TOKNh(theres)^^.NbVars > 0 THEN		BEGIN			count := TOKNh(theres)^^.NbVars * Sizeof(TVar);			Err := FSRead(RefW,Count,Ptr(ORD4(theRes^)+L));			{ mise à 0 de la fin de chaine pour compression plus efficace }			FOR i := 1 TO TOKNh(theres)^^.NbVars DO				WITH PVarRes(ORD4(ORD4(theRes^)+L))^[i] DO{$R-}					FOR j := length(NomVar)+1 TO SizeOf(Str20)-1 DO						NomVar[j]:=CHR(0);{$R+}			L := L + Count;		END;				{ lecture de la table de constantes }		TOKNh(theres)^^.NbCst := GetInteger;			{ Nb de constantes à charger }		count := TOKNh(theres)^^.NbCst;		count := count * Sizeof(Str64);	{ Taille à charger }		SetHSize(Handle(TheCCsts), Count);		Err := FSRead(RefW, count, Ptr(TheCCsts^));		IF (Err <> 0) THEN		BEGIN			{ErrorManager(Err,107);}			ErrFlag := TRUE;			Error := Err;			NbCst := 0;			WWLnStr('Lecture constantes');		END;				FOR i := 1 TO TOKNh(theres)^^.NbCst DO		BEGIN			count := length(theCCsts^^[i])+1;			BlockMoveData(@theCCsts^^[i][0],Ptr(ORD4(theRes^)+L),count);			L := L+Count;		END;						{ lecture du code tokenise }		LgCode := GetInteger;		IF LgCode<0 THEN		BEGIN			WWLnStr(concat('Pb avec:',ModName));			WWriteStr('longueur code = ');			WWLnNum(LgCode,0);			ErrFlag := TRUE;			EXIT(LoadCode);		END;		TOKNh(theres)^^.SizeTokens := LgCode;		count := TOKNh(theres)^^.SizeTokens; { pour le LParam a 0 }		SetHSize(Handle(TheCCode), LgCode + 2);		Err := FSRead(RefW, count, Ptr(TheCCode^));		IF (Err <> 0) THEN		BEGIN			{ErrorManager(Err,109);}			ErrFlag := TRUE;			Error := Err;			LgCode := 2;			SetHSize(Handle(TheCCode), LgCode);			WWLnStr('Lecture code tokenisé');		END;		BlockMoveData(Ptr(TheCCode^),Ptr(ORD4(theRes^)+L),count);		L := L+Count;		SetHSize(theRes,L);(*				{ compression par PackBits… }		PackRes := NewHandle(L+1024);		HLock(PackRes);		PackStart := PackRes^;		PackEnd := Ptr(ORD4(PackStart)+4);		Unpack := theRes^;		PackBits(Unpack,PackEnd,L);		L := PackEnd-PackStart;		LongintPtr(PackStart)^:=L;		HUnlock(theRes);		DisposHandle(theres);		SetHSize(PackRes,L);		theRes := PackRes;*)						IF Changed THEN		BEGIN			Count := 0;			WITH dataH(theRes)^^ DO			BEGIN				{ la clé de cryptage dépend du nom, c'est donc tjrs la même pour le même source }				TempKey := BAND(ORD(ModName[1])*17+ORD(ModName[length(ModName)]),$FF);				Cle := CHR(BXOR(BAND($000000FF,L),BXOR($d3,TempKey)));				REPEAT					Info[count] := CHR(BXOR(255-ORD(Info[count]),ORD(Cle)));					Count := Count+1;				UNTIL Count >= L;			END;			TOKNh(theRes)^^.KeyTOKN := TempKey;			AddResource(theRes,PreCompType,NumCC,ModName);			IF resError<>NoErr THEN			BEGIN				Error := resError;				ErrFlag := TRUE;				WWLnStr('');				WWLnStr('Erreur lors de l''écriture du code précompilé.');				EXIT(LoadCode);			END;			WriteResource(theRes);			ReleaseResource(theRes);			(*			{ ajout resource d'info }			IF PB.IoFlMdDat <> 0 THEN			BEGIN				theRes := NewHandle(SizeOf(INFORec));				WITH InfoH(theRes)^^DO				BEGIN					Version := 1;					ModDate := PB.ioFlMdDat;				END;				AddResource(theRes,'INFO',NumCC,ModName);				WriteResource(theRes);				ReleaseResource(theRes);			END;*)		END;(*		ELSE		BEGIN			DisposHandle(theRes);			theRes2 := GetNamedResource(PreCompType,modName);			IF ResError=NoErr THEN RmveResource(theRes2);		END;*)				e := TParamPtr(Ord4(TheCCode^) + LgCode);		e^.LParam := 0; 		Err := FSClose(RefW);		IF (Err <> 0) THEN		BEGIN			ErrFlag := TRUE;			Error := Err;			{ErrorManager(Err,1);}		END; 		IF ErrFlag THEN EXIT(LoadCode); 	END;	{ LoadCode }BEGIN	{ of PreCodeGen }	BGFlag := FALSE;	SleepValue := 6;	{ chargement des nom des fichiers à ne pas compiler… }	FOR i := 1 TO 10 DO	BEGIN		GetIndString(fName,1000,i);		IF fName<>'' THEN			NoComp[i] :=  NewString(fName)		ELSE			Leave;	END;	gNbNoComp := i-1;		GetIndString(prompt, 256, 4);	fname := Concat('•-',CodeName);	SFPutFile(CenterSF(putDlgID),prompt , fname, NIL, FileDest);	IF NOT FileDest.good THEN EXIT(PreCodeGen);	SetCursor(GetCursor(watchCursor)^^);	{ la montre… }		WWLnStr('');	GetDateTime(StartTime);	IUTimeString(StartTime, TRUE, Chaine);	WWriteStr('Pré-Compilation démarrée à ');	WWLnStr(Chaine);		CurVol := VolNum;	{ pool de noms de fichier }	TheGScreen := HTgScreen(NewHandle(Sizeof(Integer) + Sizeof(TGScreen)));	CheckMem;	HLock(Handle(TheGScreen));	WITH TheGScreen^^ DO	BEGIN		NbScreens := 1;		WITH TheScreens[1] DO		BEGIN			NomScreen := NewString(CodeName);			OffsetCode := 0;			OffsetVcode := 0;			FlagProcessed := TRUE;			FlagMissing := False;		{ c'est l'écran de départ de la compil. }			FlagAnalyse := TRUE;		END;	END;	NumCode := 1; { no ecran en cours }	PbAnalyse := 0;	{ handle du code VBasic} {local}	TheCCode := TparamHandle(NewHandle(0));	CheckMem;	HLock(Handle(TheCCode));	{ handle Table de constantes en tableau} {local}	TheCCsts := HCstRes(NewHandle(0));	CheckMem;	HLock(Handle(TheCCsts));	fName := FileDest.Fname;	Err := FSDelete(FName,FileDest.vRefNum);	Err := Create(fName,FileDest.vRefNum,'DRG9','PCOM');	CreateResFile(concat(PathNameFromWD(FileDest.vRefNum),fname));	IF ResError <> NoErr THEN WWLnStr(concat('Impossible de créer le fichier "',fname,'"'))	ELSE	BEGIN		ResFile := OpenRFPerm(fName,FileDest.vRefNum,fsRdWrPerm);		IF ResError <> NoErr THEN		WWLnStr(concat('Impossible d''ouvrir le fichier "',fName,'"'))		ELSE		BEGIN			REPEAT				{ charger le code }				ErrFlag := false;				Error := 0;				runFlag := TRUE;				LoadCode(NumCode);						IF WaitNextEvent(EveryEvent, theEvent,0,NIL) THEN				CASE theEvent.What OF					keyDown:						BEGIN							IF (BitAnd(TheEvent.Modifiers,CmdKey) <> 0)							 & (BitAnd(TheEvent.Message,charCodeMask) = ORD(':'))							THEN							BEGIN								ErrFlag := TRUE;								Error := 0;							END;						END;											OTHERWISE						HandleEvent(TheEvent);				END;	{CASE}				IF (NOT ErrFlag) & RunFlag THEN				BEGIN					runFlag := TRUE;					NoMoreGen := TRUE;							TheGScreen^^.TheScreens[NumCode].FlagProcessed := TRUE;							IF TheGScreen^^.TheScreens[NumCode].FlagMissing=FALSE THEN						ListeXCute(TheCCode^);							{recherche d'un autre code à compiler}					IF NOT ErrFlag THEN					WITH TheGScreen^^ DO						BEGIN						NumCode := 0;						WHILE (NumCode < NbScreens) AND NoMoreGen DO							BEGIN							NumCode := NumCode + 1;							NoMoreGen := TheScreens[NumCode].FlagProcessed;							END;						END;					END;			UNTIL NoMoreGen OR ErrFlag;					runFlag := false;					IF NOT ErrFlag THEN			IF PbAnalyse <> 0 THEN WWLnStr('Pré-compilation annulée')	{ certains écrans n'étaient pas analysés }			ELSE			BEGIN { compil OK }				WWLnStr('');				WWLnStr('Ecran(s) manquant(s):');				j := 0;				FOR i := 1 TO TheGScreen^^.NbScreens DO					IF TheGScreen^^.TheScreens[i].FlagMissing THEN					BEGIN						WWLnStr(TheGScreen^^.TheScreens[i].NomScreen^^);						j := j + 1;					END;										j := 2;					StrList := NewHandle(j);					n := 0;					FOR i := 1 TO TheGScreen^^.NbScreens DO						IF NOT TheGScreen^^.TheScreens[i].FlagMissing THEN						BEGIN							SetHSize(StrList,j+Length(TheGScreen^^.TheScreens[i].NomScreen^^)+1);							BlockMoveData(@TheGScreen^^.TheScreens[i].NomScreen^^[0],Ptr(ORD4(StrList^)+j),Length(TheGScreen^^.TheScreens[i].NomScreen^^)+1);							j := GetHandleSize(StrList);							n := n + 1;						END;					BlockMoveData(@n,StrList^,2);					AddResource(StrList, 'STR#', 10001,'Ecrans présents');					WriteResource(StrList);					HUnlock(StrList);					ReleaseResource(StrList);										{ Ajouter la liste de écrans manquants dans une STR# }										j := 2;					StrList := NewHandle(j);					n := 0;					FOR i := 1 TO TheGScreen^^.NbScreens DO						IF TheGScreen^^.TheScreens[i].FlagMissing THEN						BEGIN							SetHSize(StrList,j+Length(TheGScreen^^.TheScreens[i].NomScreen^^)+1);							BlockMoveData(@TheGScreen^^.TheScreens[i].NomScreen^^[0],Ptr(ORD4(StrList^)+j),Length(TheGScreen^^.TheScreens[i].NomScreen^^)+1);							j := GetHandleSize(StrList);							n := n + 1;						END;					BlockMoveData(@n,StrList^,2);					AddResource(StrList, 'STR#', 10000,'Ecrans manquants');					WriteResource(StrList);					HUnlock(StrList);					ReleaseResource(StrList);							{ Ajouter les ressources de contrôles (AVIR modifié) }										{ Ajouter les ressources 'vers' et autres trucs du genre… }									END				ELSE { IF Not ErrFlag }					IF Err <> NoErr THEN					BEGIN						{ Erreur de compilation }						WWLnStr('');						WWriteStr('Erreur au module "');						WWriteStr(TheGScreen^^.TheScreens[NumCode].NomScreen^^);						WWLnStr('"');						WWLnStr('');					END;					{ ajout de la resource 'DATE' }			GetDateTime(secs);			CreateDateResource(ResFile, secs);						PreCodeGen := Error;		END;	END;		CloseResFile(ResFile);		WITH TheGScreen^^ DO		FOR i := 1 TO NbScreens DO			DisposHandle(Handle(TheScreens[i].NomScreen));	HUnlock(Handle(TheGScreen));	HPurge(Handle(TheGScreen));	DisposHandle(Handle(TheGScreen));	DisposHandle(Handle(TheCCsts));	FOR i := 1 TO gNbNoComp DO		DisposHandle(Handle(NoComp[i]));		WWLnStr('');	GetDateTime(EndTime);	IUTimeString(EndTime, TRUE, Chaine);	IF NOT ErrFlag THEN		WWriteStr('Compilation terminée à ')	ELSE		WWriteStr('Compilation stoppée à ');			WWLnStr(Chaine);END;	{ CodeGen }PROCEDURE GosubScreen(e: TParamPtr);	VAR		NumCode: Integer;		Trouve: Boolean;		TheStr, TheNStr: Pstr255;	BEGIN		NextCompToken(e, Sizeof(TDummy) + 2);		{ si constante on regarde si elle existe dans la liste des ecrans }		IF e^.tk = tkStrCst THEN		BEGIN			TheStr := @TheCCsts^^[e^.indir];			WITH TheGScreen^^ DO			BEGIN				NumCode := 0;				Trouve := false;				WHILE (NumCode < NbScreens) AND (NOT Trouve) DO				BEGIN					NumCode := NumCode + 1;					TheNStr := Pstr255(Ord4(@TheScreens[NumCode].NomScreen^^));					Trouve := EqualString(TheNStr^, TheStr^, false, TRUE);				END;			END;			IF NOT Trouve THEN	{ pas trouvé, on ajoute dans la liste }			BEGIN				NumCode := NumCode + 1;				SetHSize(Handle(TheGScreen), Sizeof(Integer) + Sizeof(TGScreen) * NumCode);				TheStr := @TheCCsts^^[e^.indir];				WITH TheGScreen^^ DO				BEGIN					NbScreens := NbScreens + 1;					WITH TheScreens[NbScreens] DO					BEGIN						NomScreen := NewString(TheStr^);						OffsetCode := 0;						OffsetVcode := 0;						FlagProcessed := false;						FlagMissing := false;						FlagAnalyse := false;					END;				END;			END;		END;	{ e^.tk = tkStrCst }	END;	{ GosubScreen }{==============================================================================}{ 						R O U T A G E 						 }{==============================================================================}PROCEDURE ListeXCute(e: TParamPtr);	VAR		nl, NStartEt, NInst: Integer;		xpc: Longint;		prompt: Str255;	BEGIN { executer la liste }		WHILE e^.LParam <> 0 DO		BEGIN			NextCompToken(e, Sizeof(TDummy) + 2);			NextCompToken(e, e^.LParam); { token listint, formatage }			WHILE (e^.tk <> tkliste) & (e^.LParam <> 0) DO			BEGIN				InstXCute(e);				IF ErrFlag THEN EXIT(ListeXCute);				NextCompToken(e, e^.LParam);			END;		END;	END;{==============================================================================}PROCEDURE InstXCute(e: TParamPtr);	VAR		tpf: Integer;	BEGIN		IF e^.tk IN [tkGOTOSCREEN,tkGOSUBSCREEN,tkDECSCREEN,tkLOADSCREEN,tkDRAWSCREEN]		THEN GosubScreen(e) ELSE NextCompToken(e, e^.LParam);	END;END. { Implementation }