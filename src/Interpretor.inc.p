{$SETC SYSEXP=FALSE}USES TextUtils, InterpretorLib, Compilator;{===============================================================================}{ 							I M P L E M E N T A T I O N 						}{===============================================================================}CONST	{ on recupere les constantes des tokens }	{$I TkTokenCst.p}	SOH = chr(1);	EOT = chr(4);	ENQ = chr(5);	BS = chr(8);	FF = chr(12);	SO = chr(14);	SI = chr(15);	DC1 = chr(17);	REP = chr(18);	SEPC = chr(19);	DC4 = chr(20);	SS2 = chr(22);	CAN = chr(24);	ACC = chr(25);	ESC = chr(27);	RS = chr(30);	US = chr(31);	SP = chr(32);	START = chr($69);	STOP = chr($6A);	IDEN1 = chr($78);	IDEN2 = chr($79);	ENQRAM = chr($7A);	ENQROM = chr($7B);VAR	Pc: LongInt;			{ Program Counter }	Stack: HPCPile;			{ pile des retours }	CStack: HTCodePile;		{ pile des codes }	TheVars: HTbVar;		{ variables totales }	TheCode: TParamHandle;	{ code basic }	TheVCode: Handle; 		{ code VideoTex }	TheCVars: HVarRes;		{ table des variables du code }	TheCsts: HCstRes;		{ table des constantes du code }	PcFlag: Boolean;		{ Indicateur de Jump }	BreakFlag: Boolean;		{ Indicateur de Break }	ContFlag: Boolean;		{ Indicateur de Continue }	StartFlag: Boolean;		{ Indicateur de Restart }	VolCode: Integer;		{ Volume code de boot }	CurDirID: LONGINT;	CurCodeName: Str255;	{ nom de l'écran courant }		{ variables spécifiques à la gestion du séq indéxé }	MyFicheHdl: GFicheHdl;	FichSize: Integer;	FichPtr: Integer;	FichEnd: Integer;	{ variables utilisées pour le S.E. }	SEGHdl, SELHdl: Handle;	RefFSe: Integer;	{ tableau des constantes d'exécution conditionnelle }	ExecCondTable: ARRAY [1..MaxCondEx] OF StringHandle;	NbExecCond: INTEGER;	ExecFlag: BOOLEAN;	{===========================================================================}{ 								 F O R W A R D S							}{===========================================================================}PROCEDURE InstXCute(e: TParamPtr);	FORWARD;PROCEDURE ContXCute(e: TParamPtr);	FORWARD;PROCEDURE ProcXCute(e: TParamPtr);	FORWARD;PROCEDURE AffXCute(e: TParamPtr);	FORWARD;PROCEDURE ListeXCute(e: TParamPtr);	FORWARD;PROCEDURE LoadCode(CodeName: str64; VolNum: Integer; DirId:LONGINT);	FORWARD;PROCEDURE SRead(e: TParamPtr);	FORWARD;PROCEDURE Opt(VAR Str1: str255);	FORWARD;PROCEDURE Break;	INLINE $FACE;	PROCEDURE MyExtCall(Adresse: Ptr);		EXTERNAL; { saut à une adresse en mémoire }				  {•••• à revoir !!! ••••}		PROCEDURE Jsr(addr: ProcPtr); INLINE $205F,$4E90;	{ MOVE (A7)+,A0 ; JSR (A0) }		FUNCTION Pop:LONGINT;		EXTERNAL; { dépilage d'une info = NOP !! }{==============================================================================}{ 							 U T I L I T A I R E S								 }{==============================================================================}{$IFC SYSEXP}{$S EXPERT}FUNCTION SE_DataSize(VAR GSize, LSize: LongInt): LongInt;	C; EXTERNAL;FUNCTION SE_GInit(G: Ptr): LongInt;	C; EXTERNAL;FUNCTION SE_Init(G: Ptr;								 L: Ptr): LongInt;	C; EXTERNAL;FUNCTION SE_Moteur(G: Ptr;									 L: Ptr;									 VAR imp, act, quest, fait, vars: LongInt): LongInt;	C; EXTERNAL;FUNCTION SE_Resultat(G: Ptr;										 L: Ptr;										 PtrTypeDon: Ptr;										 VAR Coef: LongInt;										 VAR Res: CString;										 VAR Panel: LongInt): LongInt;	C; EXTERNAL;FUNCTION SE_Donnee(G: Ptr;									 L: Ptr;									 VAR Tampon: CString;									 VAR Res: CString;									 VAR Panel: LongInt): LongInt;	C; EXTERNAL;FUNCTION SE_Question(G: Ptr;										 L: Ptr;										 VAR Tampon: CString;										 TypeDon: byte;										 VAR Res: CString;										 VAR Panel: LongInt): LongInt;	C; EXTERNAL;{$ENDC}{$S INTERPRETEUR}FUNCTION Xcute(VAR CodeName: str64;				VolNum: Integer; DirID:LONGINT;				TheMain: Ptr): Integer;	LABEL 0;	VAR		i, Numvar: Integer;		Err: OSerr;		GSize, LSize: LongInt;	BEGIN	{$IFC SYSEXP}		 Err:=SE_DataSize(GSize,LSize);		 IF GSize+LSize>0 THEN		 BEGIN				SEGHdl:=NewHandle(GSize);				HLock(SEGHdl);				SELHdl:=NewHandle(LSize);				HLock(SELHdl);				Err:=SE_GInit(SEGHdl^);		 END;{$ENDC}		ExecFlag := TRUE;		NbExecCond:=0;				Err := GInit;		FichSize := 4096; { 4 k arbitrairement pour l'instant }		FichPtr := 0;		FichEnd := 0;		MyFicheHdl := GFicheHdl(NewHandle(SizeOf(GFiche)));		MyFicheHdl^^.ContenuHdl := NewHandle(0);	0:		MonMain := TheMain;		VolCode := VolNum;		{ pile des retour }		Stack := HPCPile(NewHandle(SizeOf(Integer)));		HNoPurge(Handle(Stack));		Stack^^.NbCalls := 0;		{ pile des codes	 }		CStack := HTCodePile(NewHandle(SizeOf(Integer) + SizeOf(CodePile)));		HNoPurge(Handle(CStack));		CStack^^.NbCode := 1;		CStack^^.TheCodes[1].VolNum := VolNum;		CStack^^.TheCodes[1].CodeName := CodeName;		{ variables }		TheVars := HTbVar(NewHandle(SizeOf(Integer)));		HNoPurge(Handle(TheVars));		TheVars^^.NbVars := 0;		{ handle du code }		TheCode := TParamHandle(NewHandle(0));		HNoPurge(Handle(TheCode));		{ handle Table de variables }		TheCVars := HVarRes(NewHandle(0));		HNoPurge(Handle(TheCVars));				{ handle Table de constantes }		TheCsts := HCstRes(NewHandle(0));		HNoPurge(Handle(TheCsts));				{ handle Videotex }		TheVCode := NewHandle(0);		HNoPurge(Handle(TheVCode));		{ buffer de sortie }		ResetBuffer;		{ initialisation de la librairie pour les externes… }		InitInterpretorLib;		StartFlag := False;		ErrFlag := False;		CurTCB^.Error := 0;		CurDirID := DirID;				{ charger le code }		LoadCode(CodeName, VolNum, DirID);		IF NOT ErrFlag THEN			BEGIN				BreakCount := 0;				{ reset du pc }				Pc := 0;				ContFlag := False;				PcFlag := False;				{TraceFlag:=False; RESTE DANS L'ETAT}				EchoFlag := True;				ProtCount := 0;				CurTCB^.MaxTime := 5 * 60 * 60; { 5 minutes }				CurTCB^. ZoneNumber := 0;				CurTCB^. StartTime := 0;				{ et on se lance...}				Hlock(Handle(TheCode));				ListeXCute(TheCode^);				HUnlock(Handle(TheCode));			END;		Xcute := CurTCB^.Error;				{ il faut fermer les fichiers ouverts }		FOR i := 1 TO MaxFile DO			IF CurTCB^.TheFiles[i].FileRef <> 0 THEN				IF CurTCB^.TheFiles[i].BaseFlag THEN					BEGIN						WWriteStr(GetMessage(43));	{ La base }						WWriteNum(i, 0);						WWlnStr(GetMessage(44));	{ était ouverte }						Err := GFermerBase(CurTCB^.TheFiles[i].FileRef);					END				ELSE					BEGIN						WWriteStr(GetMessage(45));	{ Le fichier }						WWriteNum(i, 0);						WWlnStr(GetMessage(46));		{ était ouvert. }						IF CurTCB^.TheFiles[i].FileRef < 0 THEN						BEGIN							Err := CloseDriver(AuxRefIn);							Err := CloseDriver(AuxRefIn-1);						END						ELSE							Err := FsClose(CurTCB^.TheFiles[i].FileRef);					END;		{ il faut disposer des string handles de thevars }		DisposHandle(Handle(Stack));		DisposHandle(Handle(CStack));		BreakCount := 0;		Hlock(Handle(TheVars));		WITH TheVars^^ DO			FOR Numvar := 1 TO NbVars DO				WITH vars[Numvar] DO				BEGIN					CASE TpVar OF						fvarstr:  DisposHandle(Handle(SPtr));						finumvar: DisposHandle(Handle(TVptr));						fistrvar:	DisposHandle(Handle(TSPtr));					END;				END;		HUnlock(Handle(TheVars));		HUnlock(Handle(TheCode));		HUnlock(Handle(TheCVars));		HUnlock(Handle(TheCsts));		HUnlock(Handle(TheVCode));		DisposHandle(Handle(TheVars));		DisposHandle(Handle(TheCode));		DisposHandle(Handle(TheCVars));		DisposHandle(Handle(TheCsts));		DisposHandle(Handle(TheVCode));				RunFlag := False;		ProtCount := 0;		IF StartFlag THEN GOTO 0;		DisposHandle(MyFicheHdl^^.ContenuHdl);		DisposHandle(Handle(MyFicheHdl));		IF GSize + LSize > 0 THEN			BEGIN				DisposHandle(SEGHdl);				DisposHandle(SELHdl);			END;		Err := GFin;				CleanUpLib;				{ on dispose les constantes d'exécution conditionnelle }		FOR i := 1 TO NbExecCond DO			DisposHandle(Handle(ExecCondTable[i]));				{ on rend toutes les routines externes purgeables }		FOR i := NbTokens TO nbTok DO			IF Mots^^[i].TheResC<>NIL THEN			BEGIN				HUnlock(Mots^^[i].TheResC);				HPurge(Mots^^[i].TheResC);			END;			END;{$S INTERPRETEUR1 }PROCEDURE SetInd(ThePtr: LongintPtr;								 TheValue: LongInt);	BEGIN		ThePtr^ := TheValue;	END;FUNCTION GetInd(ThePtr: LongintPtr): LongInt;	BEGIN		GetInd := ThePtr^;	END;		FUNCTION VerifType(volNum:INTEGER; DirID: LONGINT; CodeName:Str255):BOOLEAN;VAR err:OsErr;	infos: FInfo;BEGIN	Err := HGetFInfo(VolNum,DirId,CodeName,infos);	IF Err=NoErr THEN		VerifType := (Infos.FdType='VCOD')	ELSE	BEGIN		Err := HGetFInfo(0,0,CodeName,infos);		IF Err = NoErr THEN			VerifType := (Infos.FdType='VCOD')		ELSE			VerifType := TRUE;	{ écran introuvable ! }	END;END;PROCEDURE LoadCode(CodeName: str64; VolNum: Integer; DirID:LONGINT);	VAR		count: LongInt;		Err: OSerr;		refw: Integer;		lgtext: LongInt;		NbVar, NbCst, LgCode: Integer;		Vlg: LongInt;		Trouve: Boolean;		Numvar, i: Integer;		e: TParamPtr;				PROCEDURE MsgBadType;				BEGIN			WWLnStr('');			WWLnStr(ParamMessage(42,CodeName,'','',''));			ErrFlag:=TRUE;			EXIT(LoadCode);		END;		PROCEDURE ExitLoadCode;				BEGIN			Err := FsClose(refw);			IF (Err <> 0) THEN			BEGIN				ErrFlag := True;				CurTCB^.Error := ErrNonXFile;				{ErrorManager(Err,1);}			END;				IF ErrFlag THEN EXIT(LoadCode);		END;			BEGIN		HUnlock(Handle(TheCode));		{ vérification du type de fichier… }		IF VerifType(VolNum,DirId,CodeName)=FALSE THEN MsgBadType;		Err := HOpen(VolNum,DirId,CodeName, fsRdPerm, refw);		IF (Err <> 0) THEN			BEGIN				Err := HOpen(0,0,CodeName, fsRdPerm, refw);				IF Err <> 0 THEN					BEGIN						ErrFlag := True;						CurTCB^.Error := ErrNonXFile;						EXIT(LoadCode);					END;			END;		{ code VideoTex compacte }		count := SizeOf(LongInt);		Err := FSRead(refw, count, @Vlg);		IF (Err <> 0) THEN		BEGIN			{ErrorManager(Err,102);}			ErrFlag := True;			CurTCB^.Error := ErrNonXFile;			Vlg := 0;			ExitLoadCode;		END;		SetHSize(TheVCode, Vlg);		Err := FSRead(refw, Vlg, TheVCode^);		IF (Err <> 0) THEN			BEGIN				{ErrorManager(Err,103);}				ErrFlag := True;				CurTCB^.Error := ErrNonXFile;				SetHSize(TheVCode, 0);				ExitLoadCode;			END;		{ on skippe le source si il est la }		count := SizeOf(LongInt);		Err := FSRead(refw, count, @lgtext);		IF (Err <> 0) THEN			BEGIN				{ErrorManager(Err,102);}				ErrFlag := True;				CurTCB^.Error := ErrNonXFile;				lgtext := 0;				ExitLoadCode;			END;		Err := SetFPos(refw, fsFromMark, lgtext);		IF (Err <> 0) OR (lgtext > 0) THEN			BEGIN				{ErrorManager(Err,103);}				ErrFlag := True;				CurTCB^.Error := ErrNonXFile;				ExitLoadCode;			END;		{ lecture de la table de variables }		count := SizeOf(Integer);		Err := FSRead(refw, count, @NbVar);		IF (Err <> 0) THEN			BEGIN				{ErrorManager(Err,104);}				ErrFlag := True;				CurTCB^.Error := ErrNonXFile;				NbVar := 0;				ExitLoadCode;			END;		count := SizeOf(TVar) * NbVar;		SetHSize(Handle(TheCVars), SizeOf(TVar) * NbVar);		Err := FSRead(refw, count, Ptr(TheCVars^));		IF (Err <> 0) THEN			BEGIN				{ErrorManager(Err,105);}				NbVar := 0;				ErrFlag := True;				CurTCB^.Error := ErrNonXFile;				SetHSize(Handle(TheCVars), 0);				ExitLoadCode;			END;		{Writeln('Nombre de vars:',NbVar);}		{ lecture de la table de constantes }		count := SizeOf(Integer);		Err := FSRead(refw, count, @NbCst);		IF (Err <> 0) THEN			BEGIN				{ErrorManager(Err,106);}				ErrFlag := True;				CurTCB^.Error := ErrNonXFile;				NbCst := 0;				ExitLoadCode;			END;		count := SizeOf(str64) * NbCst;		SetHSize(Handle(TheCsts), SizeOf(str64) * NbCst);		Err := FSRead(refw, count, Ptr(TheCsts^));		IF (Err <> 0) THEN			BEGIN				{ErrorManager(Err,107);}				ErrFlag := True;				CurTCB^.Error := ErrNonXFile;				NbCst := 0;				SetHSize(Handle(TheCsts), 0);				ExitLoadCode;			END;		{ lecture du code tokenise }		count := SizeOf(Integer);		Err := FSRead(refw, count, @LgCode);		IF (Err <> 0) THEN			BEGIN				{ErrorManager(Err,108);}				ErrFlag := True;				CurTCB^.Error := ErrNonXFile;				LgCode := 0;				ExitLoadCode;			END;		count := LgCode; { pour le LParam a 0 }		SetHSize(Handle(TheCode), LgCode + 2);		Err := FSRead(refw, count, Ptr(TheCode^));		IF (Err <> 0) THEN			BEGIN				{ErrorManager(Err,109);}				ErrFlag := True;				CurTCB^.Error := ErrNonXFile;				LgCode := 2;				SetHSize(Handle(TheCode), LgCode);				ExitLoadCode;			END;		{Writeln('Taille tokens:',LgCode);}		e := TParamPtr(Ord4(TheCode^) + LgCode);		e^.LParam := 0;		Err := FsClose(refw);		IF (Err <> 0) THEN		BEGIN			ErrFlag := True;			CurTCB^.Error := ErrNonXFile;			{ErrorManager(Err,1);}		END;		IF ErrFlag THEN EXIT(LoadCode);		{ integration et initialisation des variables numeriques et chaines }		FOR Numvar := 1 TO NbVar DO			IF (TheCVars^^[Numvar].TpVar IN [fvarnum, fvarstr, finumvar, fistrvar]) THEN				BEGIN					Trouve := False;					i := 0;					WITH TheCVars^^[Numvar] DO						WHILE (NOT Trouve) AND (i < TheVars^^.NbVars) DO							BEGIN								i := i + 1;								Trouve := (TheVars^^.vars[i].NomVar = NomVar);							END;					IF Trouve THEN						BEGIN { on met a jour l'indirection }							TheCVars^^[Numvar].Indir := i;						END					ELSE { on ajoute la variable et on met a jour l'indirection }						BEGIN							TheVars^^.NbVars := TheVars^^.NbVars + 1;							SetHSize(Handle(TheVars), SizeOf(Integer) +														SizeOf(TGVar) * TheVars^^.NbVars);							TheCVars^^[Numvar].Indir := TheVars^^.NbVars;							Hlock(Handle(TheVars));							WITH TheVars^^.vars[TheVars^^.NbVars] DO								BEGIN									NomVar := TheCVars^^[Numvar].NomVar;									TpVar := TheCVars^^[Numvar].TpVar;									DimVal := TheCVars^^[Numvar].DimVal;									{Writeln(NomVar,' = ',tpvar,' = ',DimVal);}									CASE TpVar OF										fvarnum: Value := 0;										fvarstr:											BEGIN												SPtr := NewString('');												HNoPurge(Handle(SPtr));											END;										finumvar:											BEGIN												TVptr := TVHandle(NewHandleClear(Ord4(TheCVars^^[Numvar].DimVal) * sizeOf(LONGINT)));												HNoPurge(Handle(TVptr));											END;										fistrvar:	{ allocation tableau de chaines }											TSPtr := TSHandle(NewHandleClear(Ord4(TheCVars^^[Numvar].DimVal) * SizeOf(Str255)));									END;								END;							HUnlock(Handle(TheVars));						END;				END;		Hlock(Handle(TheCode));		CurCodeName := codeName;	{ màj du nom de l'écran courant }	END;	PROCEDURE Empile(ThePc: LongInt);	BEGIN		SetHSize(Handle(Stack), SizeOf(Integer) + SizeOf(PCPile) *									(Stack^^.NbCalls + 1));		WITH Stack^^ DO			BEGIN				NbCalls := NbCalls + 1;				TheCalls[NbCalls].CodeNum := CStack^^.NbCode;				TheCalls[NbCalls].RetPc := ThePc;			END;	END;PROCEDURE Depile(VAR ThePc: LongInt);	BEGIN		Hlock(Handle(Stack));		WITH Stack^^ DO			BEGIN				IF NbCalls = 0 THEN					BEGIN						ErrFlag := True;						CurTCB^.Error := ErrReturn;						EXIT(Depile);					END;				ThePc := TheCalls[NbCalls].RetPc;				IF TheCalls[NbCalls].CodeNum < CStack^^.NbCode THEN					BEGIN { depiler l'ancien code }						CStack^^.NbCode := TheCalls[NbCalls].CodeNum;						SetHSize(Handle(CStack), SizeOf(Integer) + SizeOf(CodePile) *													(CStack^^.NbCode));						{ charger le nouveau }						LoadCode(CStack^^.TheCodes[TheCalls[NbCalls].CodeNum].CodeName,								CStack^^.TheCodes[TheCalls[NbCalls].CodeNum].VolNum,CurDirID);						IF TraceFlag THEN							WWLnStr(ParamMessage(47,CStack^^.TheCodes[TheCalls[NbCalls].CodeNum].CodeName,'','',''));					END;				NbCalls := NbCalls - 1;			END;		HUnlock(Handle(Stack));		SetHSize(Handle(Stack), SizeOf(Integer) + SizeOf(PCPile) * (Stack^^.NbCalls));	END;{ retrouve un token dans la table des 'mots' }PROCEDURE FindExtToken(e: TParamPtr);	VAR		i: Integer;	BEGIN		FOR i := nbTokens+1 TO nbTok DO			IF mots^^[i].MotRes = e^.extInfos.ExtName THEN				BEGIN					e^.tk := i;					LEAVE;				END;	END;{ Rend le token suivant (interpretteur) }PROCEDURE NextIntToken(VAR e: TParamPtr; offset: LongInt);	BEGIN		e := TParamPtr(Ord4(e) + offset);		IF e^.tk = ExtToken THEN FindExtToken(e);	END;{ appel d'une routine externe en interpretté }PROCEDURE Extern(e: TParamPtr; pl: LongintPtr; ps: pstr255);	PROCEDURE Push(data: LongInt);		INLINE $4E71; { empilage d'une info = NOP }	VAR		temps: ARRAY [1..MaxParams] OF stringHandle;		tempi: ARRAY [1..MaxParams] OF LongInt;		eptr: ARRAY [1..MaxParams] OF TParamPtr;		i, Numvar: Integer;		NumIndice: LongInt;		ex: TParamPtr;		Err: OsErr;		L: LONGINT;		tempPl: LongintPtr;		hstate: SignedByte;	BEGIN		{ lockExternal indique si l'on doit conserver le code de l'externe en mémoire après son appel }		lockExternal := FALSE;				ex := e;		NextIntToken(ex, SizeOf(Tdummy) + SizeOf(ExtRec) - SizeOf(TNextI));		FOR i := 1 TO mots^^[e^.tk].nbparms DO			BEGIN				eptr[i] := ex;				NextIntToken(ex, ex^.LParam);			END;		{ evaluation des parametres et execution }		FOR i := 1 TO mots^^[e^.tk].nbparms DO			CASE mots^^[e^.tk].tparms[i] OF				fexpstr,fvarstr:				BEGIN					{ valeur de la chaine }					temps[i] := stringHandle(NewHandle(256));					Hlock(Handle(temps[i]));					StrExprXcute(eptr[i], @temps[i]^^);				END;									fexpnum,fvarnum:				BEGIN					{ valeur numérique }					NumExprXCute(eptr[i], @tempi[i]);				END;							END;		CASE mots^^[e^.tk].tfunc OF			fnum: Push(0); { place pour le résultat de la fonction }			fStr: Push(LongInt(ps)); { pointeur vers le résultat chaine }		END;				{ rout. ext. avec CallBack -> on doit passer l'adresse de la JT (27/5/92)		  comme 1er paramètre }		IF mots^^[e^.tk].TypeExt = 'DEXC' THEN Push(ORD4(JumpTable));				FOR i := 1 TO mots^^[e^.tk].nbparms DO			CASE mots^^[e^.tk].tparms[i] OF				fexpstr, fVarStr: 					IF mots^^[eptr[i]^.tk].tfunc = fistrvar THEN					BEGIN						{ on met directement l'adresse de l'élément de tableau sur la pile }						ex:=eptr[i];						NextIntToken(ex,SizeOf(TDummy)+2);						numVar:=TheCVars^^[ex^.indir].indir;						NextIntToken(ex,ex^.lparam);						NumExprXCute(ex,@NumIndice);						Push(Longint(@TheVars^^.Vars[NumVar].TSPtr^^[NumIndice]));					END					ELSE						Push(LongInt(temps[i]^)); { passage d'une valeur ou variable alpha }				fexpnum: Push(tempi[i]); 										{ passage d'une valeur numérique (valeur) }				fVarNum: Push(Longint(@tempi[i]));					{ passage d'une valeur numérique (adresse) }			END;					{ Appel de la routine externe }		SetResLoad(TRUE);		LoadResource(mots^^[e^.tk].TheResC);		MoveHHi(mots^^[e^.tk].TheResC);		hState := HGetState(mots^^[e^.tk].TheResC);		Hlock(mots^^[e^.tk].TheResC);		IF HGetState(mots^^[e^.tk].TheResC)=hState THEN LockExternal := TRUE;				L := ORD4(mots^^[e^.tk].TheResC^);	{ adresse de la routine à appeler }		Jsr(Ptr(L));		IF lockExternal=FALSE THEN		BEGIN			{ on rend la routine externe purgeable }			HUnlock(mots^^[e^.tk].TheResC);			HPurge(mots^^[e^.tk].TheResC);		END;		{ recuperation des parametres variables }		FOR i:=1 TO mots^^[e^.tk].nbparms DO		CASE mots^^[e^.tk].tparms[i] OF		fvarStr:	{ chaines }			CASE mots^^[eptr[i]^.tk].tfunc OF				fvarstr:				BEGIN		{ variable chaine }					ex:=eptr[i];					NumVar:=TheCVars^^[ex^.indir].indir;					SetHSize(handle(TheVars^^.Vars[NumVar].Sptr),Length(Temps[i]^^)+1);					BlockMoveData(Ptr(Temps[i]^),Ptr(TheVars^^.Vars[NumVar].Sptr^),Length(Temps[i]^^)+1);					{TheVars^^.Vars[NumVar].Sptr^^:=AdStr;}				END;								fistrvar:	{ élément de tableau de chaines }				BEGIN					{ on a directement mis l'adresse le notre élément de tableau }				END;			END;	{ chaines }					fvarNum:	{ numérique }			CASE mots^^[eptr[i]^.tk].tfunc OF				fvarnum:				BEGIN		{ variable numérique }					ex:=eptr[i];					NumVar:=TheCVars^^[ex^.indir].indir;					TheVars^^.Vars[NumVar].value:=Tempi[i];				END;							finumvar:				BEGIN		{ élément de tableau numérique }					ex:=eptr[i];					NextIntToken(ex,SizeOf(TDummy)+2);					numVar:=TheCVars^^[ex^.indir].indir;					NextIntToken(ex,ex^.lparam);					NumExprXCute(ex,@NumIndice);					IF (NumIndice<0) OR (NumIndice>=TheVars^^.Vars[NumVar].DimVal) THEN					BEGIN						ErrFlag:=True;						CurTCB^.Error:=ErrIndice;						EXIT(Extern);					END;					SetInd(LongintPtr(Ord4(TheVars^^.Vars[NumVar].TVPtr^)+NumIndice*4),Tempi[i]);				END;			END;	{ numériques }		END;		{ CASE }				HLock(Handle(Mots));		WITH Mots^^[e^.tk] DO		BEGIN			{ récupération de l'espace utilisé par les chaines temporaires }			FOR i := 1 TO nbparms DO				CASE tparms[i] OF					fexpstr, fvarstr:					BEGIN						HUnlock(Handle(Temps[i]));						DisposHandle(Handle(Temps[i]));					END;				END;	{ CASE }						{ mise à jour du résultat pour les fonctions }			tempPl := @L;			CASE tfunc OF				fnum: pl^ := Pop; { retourne le résultat numérique }				fStr: tempPl^ := Pop; { retourne l'adresse de la chaine résultat }			END;	{ CASE }					END;	{ WITH }		HUnlock(Handle(Mots));	END; { Extern }{==============================================================================}{ 						 I N S T R U C T I O N S								 }{==============================================================================}PROCEDURE NumPlus(e: TParamPtr; AdNum: LongintPtr);	VAR		Num1, Num2: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num2);		AdNum^ := Num1 + Num2;	END;PROCEDURE Moins(e: TParamPtr;								AdNum: LongintPtr);	VAR		Num1, Num2: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num2);		AdNum^ := Num1 - Num2;	END;PROCEDURE Neg(e: TParamPtr;							AdNum: LongintPtr);	VAR		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		AdNum^ := - Num1;	END;PROCEDURE SDiv(e: TParamPtr;							 AdNum: LongintPtr);	VAR		Num1, Num2: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num2);		IF Num2 <> 0 THEN			AdNum^ := Num1 DIV Num2		ELSE			BEGIN { Division par Zero }				ErrFlag := True;				CurTCB^.Error := ErrZero;				AdNum^ := Num1;			END;	END;PROCEDURE Mul(e: TParamPtr;							AdNum: LongintPtr);	VAR		Num1, Num2: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num2);		AdNum^ := Num1 * Num2;	END;PROCEDURE SMod(e: TParamPtr;							 AdNum: LongintPtr);	VAR		Num1, Num2: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num2);		AdNum^ := Num1 MOD Num2;	END;PROCEDURE NumOr(e: TParamPtr;								AdNum: LongintPtr);	VAR		Num1, Num2: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num2);		IF (Num1 <> 0) OR (Num2 <> 0) THEN			AdNum^ := 1		ELSE			AdNum^ := 0;	END;PROCEDURE NumAnd(e: TParamPtr;								 AdNum: LongintPtr);	VAR		Num1, Num2: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num2);		IF (Num1 <> 0) AND (Num2 <> 0) THEN			AdNum^ := 1		ELSE			AdNum^ := 0;	END;PROCEDURE SNot(e: TParamPtr;							 AdNum: LongintPtr);	VAR		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		IF (Num1 <> 0) THEN			AdNum^ := 0		ELSE			AdNum^ := 1;	END;PROCEDURE SEq(e: TParamPtr;							AdNum: LongintPtr);	VAR		Num1, Num2: LongInt;		Str1, Str2: str255;	BEGIN		{ variable num ou str }		NextIntToken(e, SizeOf(Tdummy) + 2);		CASE mots^^[e^.tk].tfunc OF			fvarnum, fnum, fcnum, fpar, fcstnum, finumvar:				BEGIN					NumExprXCute(e, @Num1);					NextIntToken(e, e^.LParam);					NumExprXCute(e, @Num2);					IF Num1 = Num2 THEN						AdNum^ := 1					ELSE						AdNum^ := 0;				END;			fvarstr, fStr, fcstr, fcststr, fistrvar:				BEGIN					StrExprXcute(e, @Str1);					NextIntToken(e, e^.LParam);					StrExprXcute(e, @Str2);					IF Str1 = Str2 THEN						AdNum^ := 1					ELSE						AdNum^ := 0;				END;		END;	END;PROCEDURE Diff(e: TParamPtr;							 AdNum: LongintPtr);	VAR		Num1, Num2: LongInt;		Str1, Str2: str255;	BEGIN		{ variable num ou str }		NextIntToken(e, SizeOf(Tdummy) + 2);		CASE mots^^[e^.tk].tfunc OF			fvarnum, fnum, fcnum, fpar, fcstnum, finumvar:				BEGIN					NumExprXCute(e, @Num1);					NextIntToken(e, e^.LParam);					NumExprXCute(e, @Num2);					IF Num1 <> Num2 THEN						AdNum^ := 1					ELSE						AdNum^ := 0;				END;			fvarstr, fStr, fcstr, fcststr, fistrvar:				BEGIN					StrExprXcute(e, @Str1);					NextIntToken(e, e^.LParam);					StrExprXcute(e, @Str2);					IF Str1 <> Str2 THEN						AdNum^ := 1					ELSE						AdNum^ := 0;				END;		END;	END;PROCEDURE Inf(e: TParamPtr;							AdNum: LongintPtr);	VAR		Num1, Num2: LongInt;		Str1, Str2: str255;	BEGIN		{ variable num ou str }		NextIntToken(e, SizeOf(Tdummy) + 2);		CASE mots^^[e^.tk].tfunc OF			fvarnum, fnum, fcnum, fpar, fcstnum, finumvar:				BEGIN					NumExprXCute(e, @Num1);					NextIntToken(e, e^.LParam);					NumExprXCute(e, @Num2);					IF Num1 < Num2 THEN						AdNum^ := 1					ELSE						AdNum^ := 0;				END;			fvarstr, fStr, fcstr, fcststr, fistrvar:				BEGIN					StrExprXcute(e, @Str1);					NextIntToken(e, e^.LParam);					StrExprXcute(e, @Str2);					IF Str1 < Str2 THEN						AdNum^ := 1					ELSE						AdNum^ := 0;				END;		END;	END;PROCEDURE Sup(e: TParamPtr;							AdNum: LongintPtr);	VAR		Num1, Num2: LongInt;		Str1, Str2: str255;	BEGIN		{ variable num ou str }		NextIntToken(e, SizeOf(Tdummy) + 2);		CASE mots^^[e^.tk].tfunc OF			fvarnum, fnum, fcnum, fpar, fcstnum, finumvar:				BEGIN					NumExprXCute(e, @Num1);					NextIntToken(e, e^.LParam);					NumExprXCute(e, @Num2);					IF Num1 > Num2 THEN						AdNum^ := 1					ELSE						AdNum^ := 0;				END;			fvarstr, fStr, fcstr, fcststr, fistrvar:				BEGIN					StrExprXcute(e, @Str1);					NextIntToken(e, e^.LParam);					StrExprXcute(e, @Str2);					IF Str1 > Str2 THEN						AdNum^ := 1					ELSE						AdNum^ := 0;				END;		END;	END;PROCEDURE EqInf(e: TParamPtr;								AdNum: LongintPtr);	VAR		Num1, Num2: LongInt;		Str1, Str2: str255;	BEGIN		{ variable num ou str }		NextIntToken(e, SizeOf(Tdummy) + 2);		CASE mots^^[e^.tk].tfunc OF			fvarnum, fnum, fcnum, fpar, fcstnum, finumvar:				BEGIN					NumExprXCute(e, @Num1);					NextIntToken(e, e^.LParam);					NumExprXCute(e, @Num2);					IF Num1 <= Num2 THEN						AdNum^ := 1					ELSE						AdNum^ := 0;				END;			fvarstr, fStr, fcstr, fcststr, fistrvar:				BEGIN					StrExprXcute(e, @Str1);					NextIntToken(e, e^.LParam);					StrExprXcute(e, @Str2);					IF Str1 <= Str2 THEN						AdNum^ := 1					ELSE						AdNum^ := 0;				END;		END;	END;PROCEDURE EqSup(e: TParamPtr;								AdNum: LongintPtr);	VAR		Num1, Num2: LongInt;		Str1, Str2: str255;	BEGIN		{ variable num ou str }		NextIntToken(e, SizeOf(Tdummy) + 2);		CASE mots^^[e^.tk].tfunc OF			fvarnum, fnum, fcnum, fpar, fcstnum, finumvar:				BEGIN					NumExprXCute(e, @Num1);					NextIntToken(e, e^.LParam);					NumExprXCute(e, @Num2);					IF Num1 >= Num2 THEN						AdNum^ := 1					ELSE						AdNum^ := 0;				END;			fvarstr, fStr, fcstr, fcststr, fistrvar:				BEGIN					StrExprXcute(e, @Str1);					NextIntToken(e, e^.LParam);					StrExprXcute(e, @Str2);					IF Str1 >= Str2 THEN						AdNum^ := 1					ELSE						AdNum^ := 0;				END;		END;	END;PROCEDURE SAbs(e: TParamPtr;							 AdNum: LongintPtr);	VAR		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		IF Num1 < 0 THEN			AdNum^ := - Num1		ELSE			AdNum^ := Num1;	END;PROCEDURE SAsc(e: TParamPtr;							 AdNum: LongintPtr);	VAR		Str1: str255;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		StrExprXcute(e, @Str1);		IF length(Str1) = 0 THEN			AdNum^ := 0		ELSE			AdNum^ := ord(Str1[1]);	END;PROCEDURE SEof(e: TParamPtr;							 AdNum: LongintPtr);	VAR		NumFile: LongInt;		pb: Paramblockrec;		Err: OSerr;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				AdNum^ := 1;				EXIT(SEof);			END;		IF (CurTCB^.TheFiles[NumFile].FileRef = 0) THEN			BEGIN				CurTCB^.Error := ErrNotOpen;				AdNum^ := 1;				EXIT(SEof);			END;		{ GETEOF = FilePos ? }		IF CurTCB^.TheFiles[NumFile].BaseFlag THEN			BEGIN				IF FichPtr >= FichEnd THEN					AdNum^ := 1				ELSE					AdNum^ := 0;			END		ELSE			BEGIN				WITH pb DO					BEGIN						ioCompletion := NIL;						ioRefNum := CurTCB^.TheFiles[NumFile].FileRef;					END;				Err := PbGetEof(@pb, False);				CurTCB^.Error := pb.ioResult;				IF CurTCB^.TheFiles[NumFile].FilePos >= Ord4(pb.ioMisc) THEN					AdNum^ := 1				ELSE					AdNum^ := 0;			END;	END;PROCEDURE SError(e: TParamPtr;								 AdNum: LongintPtr);	BEGIN		AdNum^ := CurTCB^.Error;	END;PROCEDURE SKey(e: TParamPtr;							 AdNum: LongintPtr);	BEGIN		AdNum^ := CurTCB^.Error - 127;	END;PROCEDURE BaseOpen(e: TParamPtr);{(NumBase: longint; Var NomBase: Str255);}	VAR		NomBase: str255;		NumFile: LongInt;		NumBase: Integer;		InfoOuverture: GOuvertureInfo;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(BaseOpen);			END;		WITH CurTCB^.TheFiles[NumFile] DO			IF FileRef <> 0 THEN				BEGIN					CurTCB^.Error := ErrFileOpen;					EXIT(BaseOpen);				END;		NextIntToken(e, e^.LParam);		StrExprXcute(e, @NomBase);		WITH InfoOuverture DO			BEGIN				oiNomPtr := @NomBase;				oiVolume := 0;				oiClePositionement := 1;				oiFicheCouranteHdl := MyFicheHdl;				oiFicDonneeExtern := False;			END;		CurTCB^.Error := GOuvrirBase(InfoOuverture, NumBase);		FichEnd := GetHandleSize(MyFicheHdl^^.ContenuHdl);		IF CurTCB^.Error >= GNoErr THEN			WITH CurTCB^.TheFiles[NumFile], MyFicheHdl^^ DO				BEGIN					FileRef := NumBase;					FilePos := CurFiche;					BaseFlag := True;				END;	END;PROCEDURE BaseInfo(e: TParamPtr);{(NumBase: longint);}	VAR		NumFile, Num1, NumIndice, Numvar: LongInt;		ex: TParamPtr;		LesInfos: GInfo;		i: Integer;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(BaseInfo);			END;		WITH CurTCB^.TheFiles[NumFile] DO			IF (FileRef = 0) OR (NOT BaseFlag) THEN				BEGIN					CurTCB^.Error := ErrBadNum;					EXIT(BaseInfo);				END;		WITH CurTCB^.TheFiles[NumFile] DO			CurTCB^.Error := GInfoBase(FileRef, @LesInfos);		NextIntToken(e, e^.LParam);		FOR i := 1 TO 4 DO			BEGIN				CASE i OF					1: Num1 := LesInfos.NombreElem;					2: Num1 := LesInfos.NombreSupprim;					3: Num1 := LesInfos.TailleVide;					4: Num1 := LesInfos.NombreCle;				END;				IF CurTCB^.Error <> 0 THEN Num1 := 0;				IF e^.tk = tkNumVar THEN					BEGIN						{Writeln('Var num:',TheCVars^^[e^.indir].indir);}						TheVars^^.vars[TheCVars^^[e^.Indir].Indir].Value := Num1;					END				ELSE IF e^.tk = tkINUMVAR THEN					BEGIN						ex := TParamPtr(Ord4(e) + SizeOf(Tdummy) + 2);						Numvar := TheCVars^^[ex^.Indir].Indir;						ex := TParamPtr(Ord4(ex) + ex^.LParam);						NumExprXCute(ex, @NumIndice);						IF (NumIndice < 0) OR							 (NumIndice >= TheVars^^.vars[Numvar].DimVal) THEN							BEGIN								ErrFlag := True;								CurTCB^.Error := ErrIndice;								EXIT(BaseInfo);							END;						SetInd(LongintPtr(Ord4(TheVars^^.vars[Numvar].TVptr^) +									 NumIndice * 4), Num1);					END;				NextIntToken(e, e^.LParam);			END;	END;PROCEDURE BaseClose(e: TParamPtr);{(NumBase: longint);}	VAR		NumFile: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(BaseClose);			END;		WITH CurTCB^.TheFiles[NumFile] DO			IF (FileRef = 0) OR (NOT BaseFlag) THEN				BEGIN					CurTCB^.Error := ErrBadNum;					EXIT(BaseClose);				END;		WITH CurTCB^.TheFiles[NumFile] DO			BEGIN				CurTCB^.Error := GFermerBase(FileRef);				FileRef := 0;			END;	END;PROCEDURE BASEINCR(e: TParamPtr);	VAR		NumBase, Flag: LongInt;		BFlag: Boolean;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumBase);		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Flag);		IF (NumBase < 1) OR (NumBase > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(BASEINCR);			END;		WITH CurTCB^.TheFiles[NumBase] DO			IF (FileRef = 0) OR (NOT BaseFlag) THEN				BEGIN					CurTCB^.Error := ErrBadNum;					EXIT(BASEINCR);				END;		BFlag := Flag <> 0;		CurTCB^.Error := GModRecherch(NumBase, True, BFlag);	END;PROCEDURE BASEREAD(e: TParamPtr);	VAR		NumBase: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumBase);		IF (NumBase < 1) OR (NumBase > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(BASEREAD);			END;		WITH CurTCB^.TheFiles[NumBase] DO			IF (FileRef = 0) OR (NOT BaseFlag) THEN				BEGIN					CurTCB^.Error := ErrBadNum;					EXIT(BASEREAD);				END;		WITH CurTCB^.TheFiles[NumBase] DO			BEGIN				MyFicheHdl^^.CurFiche := FilePos;				CurTCB^.Error := GRelire(NumBase);				FichEnd := GetHandleSize(MyFicheHdl^^.ContenuHdl);				FilePos := MyFicheHdl^^.CurFiche;			END;	END;PROCEDURE BASESETREF(e: TParamPtr);	VAR		NumBase, RecRef: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumBase);		NextIntToken(e, e^.LParam);		NumExprXCute(e, @RecRef);		IF (NumBase < 1) OR (NumBase > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(BASESETREF);			END;		WITH CurTCB^.TheFiles[NumBase] DO			BEGIN				IF (FileRef = 0) OR (NOT BaseFlag) THEN					BEGIN						CurTCB^.Error := ErrBadNum;						EXIT(BASESETREF);					END;				FilePos := RecRef;				CurTCB^.Error := NoErr;			END;	END;PROCEDURE BASEGETREF(e: TParamPtr;										 AdNum: LongintPtr);	VAR		NumBase: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumBase);		IF (NumBase < 1) OR (NumBase > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(BASEGETREF);			END;		WITH CurTCB^.TheFiles[NumBase] DO			BEGIN				IF (FileRef = 0) OR (NOT BaseFlag) THEN					BEGIN						CurTCB^.Error := ErrBadNum;						EXIT(BASEGETREF);					END;				AdNum^ := FilePos;				CurTCB^.Error := NoErr;			END;	END;PROCEDURE BaseSeek(e: TParamPtr);{(NumBase,NumIndex: longint; PtIndex: Ptr; TpIndex: Integer);}	VAR		NumFile, NumIndex: LongInt;		Titre: str255;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(BaseSeek);			END;		WITH CurTCB^.TheFiles[NumFile] DO			IF (FileRef = 0) OR (NOT BaseFlag) THEN				BEGIN					CurTCB^.Error := ErrBadNum;					EXIT(BaseSeek);				END;		NextIntToken(e, e^.LParam);		NumExprXCute(e, @NumIndex);		IF NumIndex < 1 THEN			NumIndex := 1		ELSE IF NumIndex > MaxCle THEN NumIndex := MaxCle;		NextIntToken(e, e^.LParam);		StrExprXcute(e, @Titre);		WITH CurTCB^.TheFiles[NumFile] DO			BEGIN				MyFicheHdl^^.CurFiche := FilePos;				CurTCB^.Error := GRechercher(FileRef, NumIndex, @Titre);				FichEnd := GetHandleSize(MyFicheHdl^^.ContenuHdl);				FilePos := MyFicheHdl^^.CurFiche;			END;	END;PROCEDURE SetBaseEnd(TheEnd: LongInt);	BEGIN		SetHSize(MyFicheHdl^^.ContenuHdl, TheEnd);		FichEnd := TheEnd;	END;PROCEDURE BaseUpdate(e: TParamPtr);{(NumBase: longint);}	VAR		NumFile: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(BaseUpdate);			END;		WITH CurTCB^.TheFiles[NumFile] DO			IF (FileRef = 0) OR (NOT BaseFlag) THEN				BEGIN					CurTCB^.Error := ErrBadNum;					EXIT(BaseUpdate);				END;		WITH CurTCB^.TheFiles[NumFile] DO			BEGIN				MyFicheHdl^^.CurFiche := FilePos;				CurTCB^.Error := GModifier(FileRef, MyFicheHdl);				FilePos := MyFicheHdl^^.CurFiche;			END;	END;PROCEDURE BaseAdd(e: TParamPtr);{(NumBase: longint);}	VAR		NumFile: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(BaseAdd);			END;		WITH CurTCB^.TheFiles[NumFile] DO			IF (FileRef = 0) OR (NOT BaseFlag) THEN				BEGIN					CurTCB^.Error := ErrBadNum;					EXIT(BaseAdd);				END;		WITH CurTCB^.TheFiles[NumFile] DO			BEGIN				MyFicheHdl^^.CurFiche := FilePos;				CurTCB^.Error := GAjouter(FileRef, MyFicheHdl);				FilePos := MyFicheHdl^^.CurFiche;			END;	END;PROCEDURE BaseRemove(e: TParamPtr);{(NumBase: longint);}	VAR		NumFile: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(BaseRemove);			END;		WITH CurTCB^.TheFiles[NumFile] DO			IF (FileRef = 0) OR (NOT BaseFlag) THEN				BEGIN					CurTCB^.Error := ErrBadNum;					EXIT(BaseRemove);				END;		WITH CurTCB^.TheFiles[NumFile] DO			BEGIN				MyFicheHdl^^.CurFiche := FilePos;				CurTCB^.Error := GSupprimer(FileRef);				FilePos := MyFicheHdl^^.CurFiche;			END;	END;PROCEDURE BaseNext(e: TParamPtr);{(NumBase,NumIndex: longint);}	VAR		NumFile, NumIndex: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(BaseNext);			END;		WITH CurTCB^.TheFiles[NumFile] DO			IF (FileRef = 0) OR (NOT BaseFlag) THEN				BEGIN					CurTCB^.Error := ErrBadNum;					EXIT(BaseNext);				END;		NextIntToken(e, e^.LParam);		NumExprXCute(e, @NumIndex);		IF NumIndex < 1 THEN			NumIndex := 1		ELSE IF NumIndex > MaxCle THEN NumIndex := MaxCle;		WITH CurTCB^.TheFiles[NumFile] DO			BEGIN				MyFicheHdl^^.CurFiche := FilePos;				CurTCB^.Error := GSuivant(FileRef, NumIndex);				FichEnd := GetHandleSize(MyFicheHdl^^.ContenuHdl);				FilePos := MyFicheHdl^^.CurFiche;			END;	END;PROCEDURE BasePred(e: TParamPtr);{(NumBase,NumIndex: longint);}	VAR		NumFile, NumIndex: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(BasePred);			END;		WITH CurTCB^.TheFiles[NumFile] DO			IF (FileRef = 0) OR (NOT BaseFlag) THEN				BEGIN					CurTCB^.Error := ErrBadNum;					EXIT(BasePred);				END;		NextIntToken(e, e^.LParam);		NumExprXCute(e, @NumIndex);		IF NumIndex < 1 THEN			NumIndex := 1		ELSE IF NumIndex > MaxCle THEN NumIndex := MaxCle;		WITH CurTCB^.TheFiles[NumFile] DO			BEGIN				MyFicheHdl^^.CurFiche := FilePos;				CurTCB^.Error := GPrecedent(FileRef, NumIndex);				FichEnd := GetHandleSize(MyFicheHdl^^.ContenuHdl);				FilePos := MyFicheHdl^^.CurFiche;			END;	END;PROCEDURE BaseCreate(e: TParamPtr);{(NbIndex: Longint; Var NomBase: Str255);}	VAR		NbIndex: LongInt;		NomBase: str255;		i: Integer;		NumBase: Integer;		InfoCreation: GCreationInfo;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NbIndex);		IF NbIndex < 1 THEN			NbIndex := 1		ELSE IF NbIndex > MaxCle THEN NbIndex := MaxCle;		NextIntToken(e, e^.LParam);		StrExprXcute(e, @NomBase);		WITH InfoCreation DO			BEGIN				ciNomPtr := @NomBase;				ciVolume := 0;				ciLeCreateur := 'DRG9';				ciLeTypeFic := 'BASE';				ciLeTypeInd := 'INDX';				ciFicheCouranteHdl := NIL;				ciFicheFinHdl := NIL;				ciFicDonneeExtern := False;				WITH ciSpecifCle DO					BEGIN						NombreCle := NbIndex;						FOR i := 1 TO NbIndex DO							BEGIN								TypeCle[i] := TypeStr;								PositionCle[i] := - 1; { séquentiel }								LongueurCle[i] := 0;							END;					END;			END;		CurTCB^.Error := GCreerBase(InfoCreation, NumBase);		IF CurTCB^.Error >= GNoErr THEN CurTCB^.Error := GFermerBase(NumBase);	END;PROCEDURE SInstr(e: TParamPtr;								 AdNum: LongintPtr);	VAR		Str1, Str2: str255;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		StrExprXcute(e, @Str1);		NextIntToken(e, e^.LParam);		StrExprXcute(e, @Str2);		AdNum^ := Pos(Str2, Str1);	END;PROCEDURE SLen(e: TParamPtr; AdNum: LongintPtr);	VAR		Str1: str255;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		StrExprXcute(e, @Str1);		AdNum^ := length(Str1);	END;PROCEDURE Logtime(e: TParamPtr; AdNum: LongintPtr);	VAR		Str1: str255;		TheTime: LongInt;	BEGIN		GetDateTime(TheTime);		AdNum^ := abs(TheTime - CurTCB^.StartTime);	END;FUNCTION SSVal(VAR Str1: str255): LongInt;{ ATTENTION: la chaine Str1 est detruite }	VAR		Num1: LongInt;		k: Integer;		termine: Boolean;	BEGIN		{ on checke le type de Str1 }		{ on skippe tous les blancs devant }		k := 0;		termine := False;		WHILE (k < length(Str1)) AND (NOT termine) DO			BEGIN				k := k + 1;				termine := Str1[k] <> ' ';			END;		{ on skippe le signe s'il est là }		IF termine THEN			BEGIN				IF (Str1[k] IN ['+'..'-']) THEN					BEGIN						{ on remplace le signe par un blanc et on met le signe au 1er car }						IF k > 1 THEN							BEGIN								Str1[1] := Str1[k];								Str1[k] := ' ';							END;						{ on doit encore skipper les blancs }						termine := False;						WHILE (k < length(Str1)) AND (NOT termine) DO							BEGIN								k := k + 1;								termine := Str1[k] <> ' ';							END;					END			END;		{ on skippe les digits }		IF termine THEN termine := NOT (Str1[k] IN ['0'..'9']);		WHILE (k < length(Str1)) AND (NOT termine) DO			BEGIN				k := k + 1;				termine := NOT (Str1[k] IN ['0'..'9']);			END;		IF termine THEN Str1[0] := chr(k - 1);		StringToNum(Str1, Num1);		SSVal := Num1;	END;PROCEDURE SVal(e: TParamPtr;							 AdNum: LongintPtr);	VAR		Str1: str255;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		StrExprXcute(e, @Str1);		AdNum^ := SSVal(Str1);	END;PROCEDURE STickCount(e: TParamPtr;										 AdNum: LongintPtr);	BEGIN		AdNum^ := TickCount;	END;PROCEDURE STaskNumber(e: TParamPtr; AdNum: LongintPtr);	BEGIN		AdNum^ := CurTCB^.Tasknumber;	END;PROCEDURE SModNumber(e: TParamPtr; AdNum: LongintPtr);	BEGIN		AdNum^ := TheModNumber;	END;PROCEDURE SStarFlag(e: TParamPtr; AdNum: LongintPtr);	BEGIN		AdNum^:=LONGINT(CurTCB^.StarFlag);	END;PROCEDURE SGetPriority(e: TParamPtr; AdNum: LongintPtr);	BEGIN		AdNum^ := CurTCB^.TaskPriority;	END;PROCEDURE Par(e: TParamPtr; AdNum: LongintPtr);	VAR		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		AdNum^ := Num1;	END;PROCEDURE StrPlus(e: TParamPtr;									AdStr: pstr255);	VAR		Str1: str255;		MaxLen: Integer;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		StrExprXcute(e, AdStr);		MaxLen := MaxStrLen - length(AdStr^);		NextIntToken(e, e^.LParam);		StrExprXcute(e, @Str1);		IF length(Str1) < MaxLen THEN MaxLen := length(Str1);		BlockMoveData(Ptr(Ord4(@Str1) + 1), Ptr(Ord4(AdStr) + length(AdStr^) + 1),							MaxLen);		MaxLen := MaxLen + length(AdStr^);		BlockMoveData(Ptr(Ord4(@MaxLen) + 1), Ptr(Ord4(AdStr)), 1);	END;PROCEDURE GetMinID(e: TParamPtr; AdStr: pstr255);	VAR		Num1: LongInt;		Str1: str255;		i: Integer;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1); {Ram1, Ram2, ou Rom}		AdStr^ := '';		IF (Num1 < 0) OR (Num1 > 2) THEN EXIT(GetMinID);		CASE Num1 OF			0:				BEGIN					Str1 := ' ';					Str1[1] := ENQ;				END;			1:				BEGIN					Str1 := '   ';					Str1[1] := ESC;					Str1[2] := chr($39);					Str1[3] := ENQRAM;				END;			2:				BEGIN					Str1 := '   ';					Str1[1] := ESC;					Str1[2] := chr($39);					Str1[3] := ENQROM;				END;		END;		AddDataPaq(@Str1);		FlushBuffer;		WaitDelay(180);		Str1 := '';		PaqPrep(Str1, '?');		AsRead(Str1, AdStr^, 120, False);		IF length(AdStr^) > 0 THEN			BEGIN				{ on vire l'EOT }				IF AdStr^[length(AdStr^)] = EOT THEN					AdStr^[0] := chr(length(AdStr^) - 1);				{ on vire le c et le SOH }				FOR i := 3 TO length(AdStr^) DO AdStr^[i - 2] := AdStr^[i];				AdStr^[0] := chr(length(AdStr^) - 2);			END;	END;	{ GetMinID }PROCEDURE SGet(e: TParamPtr; AdStr: pstr255);	VAR		Num1, TheCount: LongInt;		Str1: str255;		Err: Integer;	BEGIN		CurTCB^.Error := NoErr;		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1); {0=voie videotex, <>0=autre port}		AdStr^ := '';		IF (Num1 = 0) THEN { voie Videotex }			BEGIN				Str1 := '';				PaqPrep(Str1, '?');				AsRead(Str1, AdStr^, 120, False);				IF length(AdStr^) > 0 THEN AdStr^[0] := chr(ord(AdStr^[0]) - 1);				BlockMoveData(Ptr(Ord4(AdStr) + 2), Ptr(Ord4(AdStr) + 1), length(AdStr^));			END		ELSE			BEGIN				TheCount := 0;				Err := SerGetBuf(AuxRefIn, TheCount);				CurTCB^.Error := Err;				IF TheCount > 255 THEN TheCount := 255;				IF TheCount > 0 THEN					BEGIN						Err := FSRead(AuxRefIn, TheCount, Ptr(Ord4(AdStr) + 1));						CurTCB^.Error := Err;						AdStr^[0] := chr(TheCount);					END;			END;	END;	{ sGet }PROCEDURE SGetPaq(e: TParamPtr; AdStr: pstr255);	VAR		Num1, Num2, TheCount: LongInt;		Ch1, Ch2: LongInt;		Err: Integer;		termine: Boolean;		TheMax: LongInt;		Index: Integer;		Automate: Integer;		TheChar: Integer;	BEGIN		CurTCB^.Error := NoErr;		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1); {TimeOut}		IF Num1 <= 0 THEN Num1 := CurTCB^.MaxTime;		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num2); {Maxlen}		IF (Num2 > 255) OR (Num2 <= 0) THEN Num2 := 255;		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Ch1); {SyncChar1}		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Ch2); {SyncChar2}		AdStr^ := '';		termine := False;		TheChar := 0;		TheMax := TickCount + Num1;		Automate := 0;		Index := 0;		REPEAT			TheCount := 0;			Err := SerGetBuf(AuxRefIn, TheCount);			CurTCB^.Error := Err;			IF TheCount > 0 THEN				BEGIN					TheCount := 1;					Err := FSRead(AuxRefIn, TheCount, Ptr(Ord4(@TheChar) + 1));					CurTCB^.Error := Err;					CASE Automate OF						0:							BEGIN { on attend syncstart }								IF (Ch1 = TheChar) OR (Ch1 < 0) THEN { synchro trouve }									BEGIN										Index := Index + 1;										AdStr^[Index] := chr(TheChar);										Automate := 1;									END;							END;						1:							BEGIN { on est synchro }								Index := Index + 1;								AdStr^[Index] := chr(TheChar);								IF Index = Num2 THEN termine := True;								IF TheChar = Ch2 THEN termine := True;							END;					END;					TheMax := TickCount + Num1;				END			ELSE				CheckButton;		UNTIL termine OR (TheMax < TickCount) OR (NOT RunFlag);		AdStr^[0] := chr(Index);		IF TheMax < TickCount THEN CurTCB^.Error := ErrTime;	END;	{ sGetPaq }PROCEDURE SEnd(e: TParamPtr);	BEGIN		RunFlag := False;	END;	{ sEnd }PROCEDURE SSerConfig(e: TParamPtr; FlagOpen: Boolean);	VAR		NumFile, Num1, Num2, Num3, Num4, Num5: LongInt;		TheConfig: Integer;		Err: Integer;		Flags: SerShk;	BEGIN		CurTCB^.Error := NoErr;		TheConfig := 0;		NextIntToken(e, SizeOf(Tdummy) + 2);		IF FlagOpen THEN			BEGIN				NumExprXCute(e, @NumFile); {fichier}				NextIntToken(e, e^.LParam);				IF (NumFile < 1) OR (NumFile > MaxFile) THEN					BEGIN						CurTCB^.Error := ErrBadNum;						EXIT(SSerConfig);					END;				IF (CurTCB^.TheFiles[NumFile].FileRef <> 0) THEN					BEGIN						CurTCB^.Error := ErrFileOpen;						EXIT(SSerConfig);					END;				CurTCB^.TheFiles[NumFile].FileRef := AuxRefIn;				CurTCB^.TheFiles[NumFile].BaseFlag := False;			END;		NumExprXCute(e, @Num1); {bauds}		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num2); {data}		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num3); {parity}		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num4); {stop}		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num5); {handshake}		CASE Num1 OF			300: TheConfig := baud300;			600: TheConfig := baud600;			1200: TheConfig := baud1200;			1800: TheConfig := baud1800;			2400: TheConfig := baud2400;			3600: TheConfig := baud3600;			4800: TheConfig := baud4800;			7200: TheConfig := baud7200;			9600: TheConfig := baud9600;			19200: TheConfig := baud19200;			OTHERWISE				IF Num1 = 57600 THEN					TheConfig := baud57600				ELSE					TheConfig := baud9600;		END;		CASE Num2 OF			5: TheConfig := TheConfig + data5;			6: TheConfig := TheConfig + data6;			7: TheConfig := TheConfig + data7;			8: TheConfig := TheConfig + data8;			OTHERWISE TheConfig := TheConfig + data8;		END;		CASE Num3 OF			0: TheConfig := TheConfig + noParity;			1: TheConfig := TheConfig + oddParity;			2: TheConfig := TheConfig + evenParity;			OTHERWISE TheConfig := TheConfig + noParity;		END;		CASE Num4 OF			10: TheConfig := TheConfig + stop10;			15: TheConfig := TheConfig + stop15;			20: TheConfig := TheConfig + stop20;			OTHERWISE TheConfig := TheConfig + stop10;		END;		CASE AuxRefIn OF			- 6:			BEGIN				Err := OpenDriver('.AIn',Err);				IF Err=NoErr THEN Err := OpenDriver('.AOut',Err);			END;			- 8:			BEGIN				Err := OpenDriver('.BIn',Err);				IF Err=NoErr THEN Err := OpenDriver('.BOut',Err);			END;		END;		IF Err=NoErr THEN Err := SerReset(AuxRefIn, TheConfig);		IF Err=NoErr THEN Err := SerReset(AuxRefIn - 1, TheConfig);		IF Err=NoErr THEN Err := SerSetBuf(AuxRefIn, TheAuxSerBuf, xSerBufSz);		CASE Num5 OF						1: { Xon/Xoff}				WITH Flags DO				BEGIN					fXon := 1;					finX := 1;					xOn := chr(19);					xOff := chr(17);					fcts := 0;					errs := 0;					evts := 0;					fDTR := 0;				END;			2: { CTS }				WITH Flags DO				BEGIN					fXon := 0;					finX := 0;					xOn  := chr(19);					xOff := chr(17);					fcts := 1;					errs := 0;					evts := 0;					fDTR := 1;				END;							OTHERWISE	{ pas de HandShaking }				WITH Flags DO			  BEGIN					fXon := 0;					finX := 0;					xOn  := chr(19);					xOff := chr(17);					fcts := 0;					errs := 0;					evts := 0;					fDTR := 0;			  END;		END;	{ CASE }		Err := SerHShake(AuxRefIn, Flags);		Err := SerHShake(AuxRefIn - 1, Flags);		CurTCB^.Error := Err;	{ on rend le code erreur de l'ouverture du port série }	END;	{ sSerConfig }FUNCTION SStatus2: str255;	VAR		TheStatus: str255;		Str1: str255;		REP: Boolean;	PROCEDURE MessDLoad(VAR Str1:Str255; Num1: Longint);	{ Pour Télétel }		VAR		Str2: Str255;		BEGIN		Str1 := '';		IF Num1 > 99 THEN Num1 := 99;		IF Num1 < 0 THEN Num1 := 0;		NumToString(Num1, Str2);		IF Length(Str2) = 1 THEN Insert('0', Str2, 1);		PaqPrep(Str2, 'L');		AsRead(Str2, Str1, 120, False);		IF Length(Str1) > 0 THEN Delete(Str1, 1, 1);	END;		BEGIN		IF EmulFlag THEN		BEGIN			TestConnect(REP);			TheStatus := 'MC.LEMUL';	{ émulateur }			IF NOT REP THEN TheStatus[2] := 'F';		END		ELSE		BEGIN			Str1 := '';			PaqPrep(Str1, 'S');			AsRead(Str1, TheStatus, 30, False);			IF TheStatus[4] = 'T' THEN MessDLoad(TheStatus,0);		END;		SStatus2 := TheStatus;	END; { sStatus2 }PROCEDURE SStatus(e: TParamPtr; AdStr: pstr255);	BEGIN		AdStr^ := SStatus2;	END;PROCEDURE SRnd(e: TParamPtr;							 AdNum: LongintPtr);	VAR		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		IF Num1<>0 THEN			AdNum^ := abs(Random) MOD Num1		ELSE		BEGIN		{ Division par Zero }			AdNum^:= 0;			ErrFlag := True;			CurTCB^.Error := ErrZero;		END;	END;PROCEDURE SFilter(e: TParamPtr);	VAR		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		CurTCB^.FilterFlag := Num1 <> 0;	END;PROCEDURE Connected(e: TParamPtr; AdNum: LongintPtr);	VAR		Str1, Str2: str255;		REP: Boolean;		lastErr: INTEGER;			BEGIN		IF EmulFlag THEN		BEGIN			TestConnect(REP);			IF REP THEN				AdNum^ := 1			ELSE				AdNum^ := 0;		END		ELSE		BEGIN			lastErr := CurTCB^.Error;			Str2 := '';			PaqPrep(Str2, '?');			AsRead(Str2, Str1, 120, False);			IF (length(Str1) > 0) AND (Str1[1] = 'F') THEN				AdNum^ := 0			ELSE				AdNum^ := 1;			CurTCB^.Error := lastErr;		END;	END;	{ Connected }PROCEDURE SCurPos(e: TParamPtr; AdStr: pstr255);	VAR		Str1: str255;		i: Integer;	BEGIN		AdStr^ := '';		Str1 := '  ';		Str1[1] := ESC;		Str1[2] := chr($61);		AddDataPaq(@Str1);		FlushBuffer;		WaitDelay(120);		Str1 := '';		PaqPrep(Str1, '?');		AsRead(Str1, AdStr^, 120, False);		IF length(AdStr^) > 0 THEN			BEGIN				{ on vire le c et le US }				FOR i := 3 TO length(AdStr^) DO AdStr^[i - 2] := AdStr^[i];				AdStr^[0] := chr(length(AdStr^) - 2);			END;	END;	{ sCurPos }	PROCEDURE SChr(e: TParamPtr; AdStr: pstr255);	VAR		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		IF (Num1<0) | (Num1>255) THEN		BEGIN			ErrFlag := True;			CurTCB^.Error := ErrVParam;			EXIT(SChr);		END;		AdStr^[0] := chr(1);		AdStr^[1] := chr(Num1);	END;	{ sChr }	PROCEDURE SSecs(e: TParamPtr; AdNum: LongintPtr);	BEGIN		GetDateTime(AdNum^);	END;FUNCTION An2000(year: LONGINT):LONGINT;	{ CQ-10/2/99 }BEGIN	IF (CurTCB^.RndMemo = 0) OR (CurTCB^.RndMemo < year) THEN		An2000 := year + 1900	ELSE		An2000 := year + 2000;END;PROCEDURE SDate2Secs(e: TParamPtr; AdNum: LongintPtr);	VAR		Str1: str255;		Num1: LongInt;		DTRec: DateTimeRec;	FUNCTION Conv(Idx: Integer): Integer;		BEGIN			Conv := (ord(Str1[Idx]) - ord('0')) * 10 + (ord(Str1[Idx + 1]) - ord('0'));		END;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		StrExprXcute(e, @Str1);		CASE Length(Str1) OF			6:	{ AAMMJJ }			WITH DTRec DO			BEGIN				day := Conv(5);				month := Conv(3);				year := An2000(Conv(1));	{ CQ-10/2/99 }				hour := 0;				minute := 0;				second := 0;			END;			8:	{ JJ/MM/AA ou AAAAMMJJ }			IF (Str1[1] = '/') THEN			WITH DTRec DO			BEGIN				day := Conv(1);				month := Conv(4);				year := An2000(Conv(7));	{ CQ-10/2/99 }				hour := 0;				minute := 0;				second := 0;			END			ELSE			WITH DTRec DO			BEGIN				day := Conv(7);				month := Conv(5);				IF (Str1[1]='1') THEN					year := Conv(3) + 1900				ELSE					year := Conv(3) + 2000;				hour := 0;				minute := 0;				second := 0;			END;						10:	{ JJ/MM/AAAA }			WITH DTRec DO			BEGIN				day := Conv(1);				month := Conv(4);				IF (Str1[7]='1') THEN					year := Conv(9) + 1900				ELSE					year := Conv(9) + 2000;				hour := 0;				minute := 0;				second := 0;			END;						16:	{ JJ/MM/AAhh:mm:ss }			WITH DTRec DO			BEGIN				day := Conv(1);				month := Conv(4);				year := An2000(Conv(7));	{ CQ-10/2/99 }				hour := Conv(9);				minute := Conv(12);				second := Conv(15);			END;			18:	{ JJ/MM/AAAAhh:mm:ss }			WITH DTRec DO			BEGIN				day := Conv(1);				month := Conv(4);				IF (Str1[7]='1') THEN					year := Conv(9) + 1900				ELSE					year := Conv(9) + 2000;				hour := Conv(11);				minute := Conv(14);				second := Conv(17);			END;		END;	{ CASE }		Date2Secs(DTRec, AdNum^);	END;	{ SDate2Secs }			PROCEDURE SSecs2Date(e: TParamPtr; AdStr: pstr255);	VAR		Num1: LongInt;		DTRec: DateTimeRec;	PROCEDURE Conv(Num: Integer; Idx: Integer);		BEGIN			AdStr^[Idx] := chr((Num DIV 10) + ord('0'));			AdStr^[Idx + 1] := chr((Num MOD 10) + ord('0'));		END;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		AdStr^ := 'XX/XX/XX99:99:99';		Secs2Date(Num1, DTRec);		WITH DTRec DO			BEGIN				Conv(day, 1);				Conv(month, 4);				IF year >= 2000 THEN					Conv(year - 2000, 7)				ELSE					Conv(year - 1900, 7);				Conv(hour, 9);				Conv(minute, 12);				Conv(second, 15);			END;	END;	{ SSecs2Date }	PROCEDURE Date(e: TParamPtr; AdStr: pstr255);	VAR		Num1: LongInt;		DTRec: DateTimeRec;	PROCEDURE Conv(Num: Integer; Idx: Integer);		BEGIN			AdStr^[Idx] := chr((Num DIV 10) + ord('0'));			AdStr^[Idx + 1] := chr((Num MOD 10) + ord('0'));		END;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		GetTime(DTRec);		CASE Num1 OF			0:			WITH DTRec DO			BEGIN				AdStr^ := 'JJ/MM/AA';				Conv(day, 1);				Conv(month, 4);				IF (year >= 2000) THEN					Conv(year - 2000, 7)				ELSE					Conv(year - 1900, 7);			END;						-1:			WITH DTRec DO			BEGIN				AdStr^:='AAMMJJ';				Conv(day,5);				Conv(month,3);				IF (year >= 2000) THEN					Conv(year - 2000, 1)				ELSE					Conv(year - 1900, 1);			END;			-2:	{ 18/3/98 - date an 2000 }			WITH DTRec DO			BEGIN				IF (year >= 2000) THEN				BEGIN					AdStr^:='JJ/MM/20AA';					Conv(year-2000, 9);				END				ELSE				BEGIN					AdStr^:='JJ/MM/19AA';					Conv(year-1900, 9);				END;				Conv(day,1);				Conv(month,4);			END;			-3:	{ 18/3/98 - date an 2000 }			WITH DTRec DO			BEGIN				IF (year >= 2000) THEN				BEGIN					AdStr^:='20AAMMJJ';					Conv(year-2000, 3);				END				ELSE				BEGIN					AdStr^:='19AAMMJJ';					Conv(year-1900, 3);				END;				Conv(day,7);				Conv(month,5);			END;		END;	{ CASE }			END;	{ Date }PROCEDURE drgTime(e: TParamPtr; AdStr: pstr255);	VAR		Num1: LongInt;		DTRec: DateTimeRec;	PROCEDURE Conv(Num: Integer; Idx: Integer);		BEGIN			AdStr^[Idx] := chr((Num DIV 10) + ord('0'));			AdStr^[Idx + 1] := chr((Num MOD 10) + ord('0'));		END;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		AdStr^ := 'XX:XX:XX';		GetTime(DTRec);		WITH DTRec DO			BEGIN				Conv(hour, 1);				Conv(minute, 4);				Conv(second, 7);			END;	END;	{ DrgTime }PROCEDURE DSpcR(e: TParamPtr; AdStr: pstr255);VAR	Str1: str255;BEGIN	NextIntToken(e, SizeOf(Tdummy) + 2);	StrExprXcute(e, @Str1);	WHILE (length(Str1) > 0) AND (Str1[length(Str1)] = ' ') DO		Delete(Str1, length(Str1), 1);	AdStr^ := Str1;END;PROCEDURE DSpcL(e: TParamPtr; AdStr: pstr255);VAR	Str1: str255;BEGIN	NextIntToken(e, SizeOf(Tdummy) + 2);	StrExprXcute(e, @Str1);	WHILE (length(Str1) > 0) AND (Str1[1] = ' ') DO Delete(Str1, 1, 1);	AdStr^ := Str1;END;PROCEDURE Format(e: TParamPtr; AdStr: pstr255);VAR	Num1, Num2, Num3: LongInt;	Str4: str255;BEGIN	NextIntToken(e, SizeOf(Tdummy) + 2);	NumExprXCute(e, @Num1);	NextIntToken(e, e^.LParam);	NumExprXCute(e, @Num2);	NextIntToken(e, e^.LParam);	NumExprXCute(e, @Num3);	NextIntToken(e, e^.LParam);	StrExprXcute(e, @Str4);	IF Num2 > 0 THEN		BEGIN			WHILE (length(Str4) < (Num2 + 1)) AND (length(Str4) < MaxStrLen) DO				Str4 := Concat('0', Str4);			Insert(',', Str4, length(Str4) - Num2 + 1);		END;	IF length(Str4) < Num1 THEN	BEGIN		IF Num3 < 0 THEN { cadrage a gauche }			BEGIN				WHILE (length(Str4) < Num1) AND (length(Str4) < MaxStrLen) DO					Str4 := Concat(Str4, ' ');			END		ELSE IF Num3 = 0 THEN { centrage }			BEGIN				WHILE (length(Str4) < Num1) AND (length(Str4) < MaxStrLen) DO					BEGIN						Str4 := Concat(' ', Str4);						IF (length(Str4) < Num1) AND (length(Str4) < MaxStrLen) THEN							Str4 := Concat(Str4, ' ');					END;			END		ELSE { cadrage a droite }			BEGIN				WHILE (length(Str4) < Num1) AND (length(Str4) < MaxStrLen) DO					Str4 := Concat(' ', Str4);			END;	END	ELSE		Str4[0] := chr(Num1);	{ on coupe la chaine trop longue }			AdStr^ := Str4;END;	{ Format }PROCEDURE Left(e: TParamPtr; AdStr: pstr255);VAR	Str1: str255;	Num2: LongInt;BEGIN	NextIntToken(e, SizeOf(Tdummy) + 2);	StrExprXcute(e, @Str1);	NextIntToken(e, e^.LParam);	NumExprXCute(e, @Num2);	IF Num2>length(Str1) THEN Num2 := Length(Str1);	IF Num2<=0 THEN		AdStr^:=''	ELSE	BEGIN		Str1 := Copy(Str1, 1, Num2);		AdStr^ := Str1;	END;END;	{ Left }PROCEDURE Right(e: TParamPtr; AdStr: pstr255);VAR	Str1: str255;	Num2: LongInt;BEGIN	NextIntToken(e, SizeOf(Tdummy) + 2);	StrExprXcute(e, @Str1);	NextIntToken(e, e^.LParam);	NumExprXCute(e, @Num2);	IF Num2 > length(Str1) THEN Num2 := length(Str1);	IF Num2 <= 0 THEN		AdStr^:=''	ELSE	BEGIN		Str1 := Copy(Str1, length(Str1) - Num2 + 1, Num2);		AdStr^ := Str1;	END;END;	{ Right }PROCEDURE Spc(e: TParamPtr; AdStr: pstr255);VAR	Num1: LongInt;	Str1: str255;BEGIN	NextIntToken(e, SizeOf(Tdummy) + 2);	NumExprXCute(e, @Num1);	IF Num1 < 0 THEN Num1 := 0;	Str1 := '';	WHILE (length(Str1) < Num1) AND (length(Str1) < MaxStrLen) DO		Str1 := Concat(Str1, ' ');	AdStr^ := Str1;END;	{ Spc }PROCEDURE Lwc(e: TParamPtr; AdStr: pstr255);VAR	Str1: str255;	i: Integer;BEGIN	NextIntToken(e, SizeOf(Tdummy) + 2);	StrExprXcute(e, @Str1);	FOR i := 1 TO length(Str1) DO		IF (Str1[i] IN ['A'..'Z']) THEN Str1[i] := chr(ord(Str1[i]) + 32);	AdStr^ := Str1;END;	{ Lwc }PROCEDURE Upc(e: TParamPtr; AdStr: pstr255);VAR	Str1: str255;	i: Integer;BEGIN	NextIntToken(e, SizeOf(Tdummy) + 2);	StrExprXcute(e, @Str1);	UpperString(Str1, False);	AdStr^ := Str1;END;	{ Upc }PROCEDURE Mid(e: TParamPtr; AdStr: pstr255);VAR	Str1: str255;	Num2, Num3: LongInt;BEGIN	NextIntToken(e, SizeOf(Tdummy) + 2);	StrExprXcute(e, @Str1);	NextIntToken(e, e^.LParam);	NumExprXCute(e, @Num2);	NextIntToken(e, e^.LParam);	NumExprXCute(e, @Num3);	IF Num2 + Num3 > length(Str1) THEN Num3 := length(Str1) - Num2 + 1;	IF Num2 <= 0 THEN Num2 := 1;		IF (Num3<=0) | (Num2>length(Str1)) THEN		AdStr^:=''	ELSE	BEGIN		Str1 := Copy(Str1, Num2, Num3);		AdStr^ := Str1;	END;END;	{ Mid }PROCEDURE Str(e: TParamPtr; AdStr: pstr255);VAR	Str2: str255;	Num1: LongInt;BEGIN	NextIntToken(e, SizeOf(Tdummy) + 2);	NumExprXCute(e, @Num1);	NumToString(Num1, Str2);	AdStr^ := Str2;END;	{ Str }PROCEDURE SString(e: TParamPtr; AdStr: pstr255);VAR	Str2, Str3: str255;	Num1: LongInt;BEGIN	NextIntToken(e, SizeOf(Tdummy) + 2);	NumExprXCute(e, @Num1);	NextIntToken(e, e^.LParam);	StrExprXcute(e, @Str2);	IF length(Str2) = 0 THEN		Str2 := ' '	ELSE		Delete(Str2, 2, length(Str2) - 1);	Str3 := Str2;	Str2 := '';	WHILE (length(Str2) < Num1) AND (length(Str2) < MaxStrLen) DO		Str2 := Concat(Str2, Str3);	AdStr^ := Str2;END;	{ sString }PROCEDURE SBackColor(e: TParamPtr);VAR	Num1: LongInt;	Str1: str255;BEGIN	NextIntToken(e, SizeOf(Tdummy) + 2);	NumExprXCute(e, @Num1);	IF (Num1 >= 0) AND (Num1 < 8) THEN		BEGIN			CASE Num1 OF				1: Num1 := 4;				2: Num1 := 1;				3: Num1 := 5;				4: Num1 := 2;				5: Num1 := 6;				6: Num1 := 3;			END;			Str1 := '  ';			Str1[1] := ESC;			Str1[2] := chr($50 + Num1);			AddDataPaq(@Str1);		END;END;	{ sBackColor }PROCEDURE SForeColor(e: TParamPtr);VAR	Num1: LongInt;	Str1: str255;BEGIN	NextIntToken(e, SizeOf(Tdummy) + 2);	NumExprXCute(e, @Num1);	IF (Num1 >= 0) AND (Num1 < 8) THEN		BEGIN			CASE Num1 OF				1: Num1 := 4;				2: Num1 := 1;				3: Num1 := 5;				4: Num1 := 2;				5: Num1 := 6;				6: Num1 := 3;			END;			Str1 := '  ';			Str1[1] := ESC;			Str1[2] := chr($40 + Num1);			AddDataPaq(@Str1);		END;END;	{ sForeColor }PROCEDURE Font(e: TParamPtr);	VAR		Num1: LongInt;		Str1: str255;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		Str1 := ' ';		IF Num1 > 0 THEN			Str1[1] := SO		ELSE			Str1[1] := SI;		AddDataPaq(@Str1);	END;PROCEDURE CanEol(e: TParamPtr);	VAR		Num1, Num2: LongInt;		Str1: str255;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num2);		Str1 := '    ';		Str1[1] := US;		Str1[2] := chr($40 + Num1);		Str1[3] := chr($40 + Num2);		Str1[4] := CAN;		AddDataPaq(@Str1);		FlushBuffer;	END;PROCEDURE CanBlock(e: TParamPtr);	VAR		Num1, Num2, Num3, i: LongInt;		Str1: str255;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num2);		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num3);		Str1 := '    ';		Str1[1] := US;		Str1[3] := chr($40 + Num3);		Str1[4] := CAN;		FOR i := Num1 TO Num2 DO			BEGIN				Str1[2] := chr($40 + i);				AddDataPaq(@Str1);			END;		FlushBuffer;	END;PROCEDURE SGetVol(e: TParamPtr;									AdStr: pstr255);	VAR		Err: OSerr;		pb: Paramblockrec;		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		IF (Num1 < 1) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(SGetVol);			END;		WITH pb DO			BEGIN				ioCompletion := NIL;				ioNamePtr := StringPtr(AdStr);				ioVolIndex := Num1;				ioVRefNum := 0;			END;		Err := PBGetVInfo(@pb, False);		CurTCB^.Error := pb.ioResult;		IF CurTCB^.Error <> NoErr THEN			BEGIN				AdStr^ := '';			END		ELSE			BEGIN				AdStr^[0] := chr(ord(AdStr^[0]) + 1);				AdStr^[length(AdStr^)] := ':';			END;	END;PROCEDURE DirFile(e: TParamPtr; AdStr: pstr255);	VAR		ThePb: CInfoPbRec;		TheWDPb: WDPBRec;		Err: OSerr;		TheIndex: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		StrExprXcute(e, @AdStr^);		IF AdStr^[length(AdStr^)]<>':' THEN AdStr^ := concat(AdStr^,':');				NextIntToken(e, e^.LParam);		NumExprXCute(e, @TheIndex);		WITH TheWDPb DO			BEGIN				ioCompletion := NIL;				ioNamePtr := @AdStr^;				ioVRefNum := 0;				ioWdProcId := $12345678;				ioWDDirId := 0;			END;		Err := PBopenWD(@TheWDPb, False);				IF Err=NoErr THEN		BEGIN			WITH ThePb DO				BEGIN					ioVRefNum := TheWDPb.ioVRefNum;					ioDrDirId := 0;					ioCompletion := NIL;					ioNamePtr := @AdStr^;					ioFDirIndex := TheIndex;				END;				Err := PBGetCatInfo(@ThePb, False);		END;				IF Err <> NoErr THEN			AdStr^ := ''		ELSE IF BTst(ThePb.IOFlAttrib, 4) THEN			BEGIN { directory }				AdStr^[0] := chr(length(AdStr^) + 1);				AdStr^[length(AdStr^)] := ':';			END;		CurTCB^.Error := Err;		Err := PBcloseWD(@TheWDPb, False);	END;	PROCEDURE SClose(e: TParamPtr);	VAR		Num1: LongInt;		Err: OSerr;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		IF (Num1 < 1) OR (Num1 > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(SClose);			END;		IF (CurTCB^.TheFiles[Num1].FileRef = 0) OR CurTCB^.TheFiles[Num1].BaseFlag THEN			BEGIN				CurTCB^.Error := ErrNotOpen;				EXIT(SClose);			END;		IF CurTCB^.TheFiles[Num1].FileRef < 0 THEN			BEGIN				Err := CloseDriver(AuxRefIn);				Err := CloseDriver(AuxRefIn-1);				CurTCB^.TheFiles[Num1].FileRef := 0;				CurTCB^.Error := 0;				EXIT(SClose);			END;		Err := FsClose(CurTCB^.TheFiles[Num1].FileRef);		CurTCB^.TheFiles[Num1].FileRef := 0;		CurTCB^.Error := Err;	END;PROCEDURE SCreate(e: TParamPtr);	VAR		Str1, XStr: str255;		Err: OSerr;		pb: HParamBlockRec;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		StrExprXcute(e, @Str1);		{ Err:=Create(Str1,0,'DRG9','TEXT'); }		XStr := Str1;		WITH pb DO			BEGIN				ioCompletion := NIL;				ioNamePtr := @XStr;				ioVRefNum := 0;				IODirId := 0;			END;		Err := PBHCreate(@pb, False);		CurTCB^.Error := Err;		IF CurTCB^.Error <> NoErr THEN EXIT(SCreate);		XStr := Str1;		WITH pb DO			BEGIN				ioNamePtr := @XStr;				ioVRefNum := 0;				ioCompletion := NIL;				IoDirId := 0;				ioFDirIndex := 0;			END;		Err := PbHGetFInfo(@pb, False);		CurTCB^.Error := Err;		IF Err <> NoErr THEN EXIT(SCreate);		pb.ioFlFndrInfo.fdType := 'TEXT';		pb.ioFlFndrInfo.fdCreator := 'DRG9';		XStr := Str1;		WITH pb DO			BEGIN				ioNamePtr := @XStr;				ioVRefNum := 0;				ioCompletion := NIL;				ioDirID := 0;				ioFDirIndex := 0;			END;		Err := PbHSetFInfo(@pb, False);		CurTCB^.Error := Err;	END;PROCEDURE SGetFInfo(e: TParamPtr);	VAR		Num1, Numvar, NumIndice: LongInt;		ex: TParamPtr;		Str1, XStr: str255;		pb: CInfoPBRec;		i: Integer;		Err: OSerr;		Folder: BOOLEAN;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		StrExprXcute(e, @Str1);		NextIntToken(e, e^.LParam);		XStr := Str1;		WITH pb DO			BEGIN				ioNamePtr := @XStr;				ioVRefNum := 0;				ioCompletion := NIL;				ioFDirIndex := 0;				IODirId := 0;			END;		Err := PbGetCatInfo(@pb, False);		CurTCB^.Error := Err;		Folder := BTst(PB.IoFlAttrib,4);		IF Folder THEN Str1 := ''		ELSE		BEGIN			Str1[0] := chr(8);			BlockMoveData(@pb.ioFlFndrInfo, Ptr(Ord4(@Str1) + 1), 8);		END;		IF e^.tk = tkStrVar THEN			BEGIN				Numvar := TheCVars^^[e^.Indir].Indir;				{Writeln('Var chaine:',numvar);}				SetHSize(Handle(TheVars^^.vars[Numvar].SPtr), length(Str1) + 1);				BlockMoveData(@Str1, Ptr(Ord4(TheVars^^.vars[Numvar].SPtr^)), length(Str1) + 1);			END		ELSE			BEGIN				ex := TParamPtr(Ord4(e) + SizeOf(Tdummy) + 2);				Numvar := TheCVars^^[ex^.Indir].Indir;				ex := TParamPtr(Ord4(ex) + ex^.LParam);				NumExprXCute(ex, @NumIndice);				IF (NumIndice < 0) OR (NumIndice >= TheVars^^.vars[Numvar].DimVal) THEN				BEGIN					ErrFlag := True;					CurTCB^.Error := ErrIndice;					EXIT(SGetFInfo);				END;				TheVars^^.vars[Numvar].TSPtr^^[NumIndice] := Str1;			END;		NextIntToken(e, e^.LParam);		FOR i := 1 TO 4 DO			BEGIN							IF Folder THEN				CASE i OF	{ Dossier }					1: Num1 := Ord4(pb.ioDrNmFls);					2: Num1 := Ord4(pb.ioDrBkDat);					3: Num1 := Ord4(pb.ioDrCrDat);					4: Num1 := Ord4(pb.ioDrMdDat);				END				ELSE				CASE i OF	{ FIchier }					1: Num1 := Ord4(pb.ioFlLgLen);					2: Num1 := Ord4(pb.ioFlRLgLen);					3: Num1 := Ord4(pb.ioFlCrDat);					4: Num1 := Ord4(pb.ioFlMdDat);				END;								IF e^.tk = tkNumVar THEN					BEGIN						{Writeln('Var num:',TheCVars^^[e^.indir].indir);}						TheVars^^.vars[TheCVars^^[e^.Indir].Indir].Value := Num1;					END				ELSE IF e^.tk = tkINUMVAR THEN					BEGIN						ex := TParamPtr(Ord4(e) + SizeOf(Tdummy) + 2);						Numvar := TheCVars^^[ex^.Indir].Indir;						ex := TParamPtr(Ord4(ex) + ex^.LParam);						NumExprXCute(ex, @NumIndice);						IF (NumIndice < 0) OR							 (NumIndice >= TheVars^^.vars[Numvar].DimVal) THEN							BEGIN								ErrFlag := True;								CurTCB^.Error := ErrIndice;								EXIT(SGetFInfo);							END;						SetInd(LongintPtr(Ord4(TheVars^^.vars[Numvar].TVptr^) +									 NumIndice * 4), Num1);					END;				NextIntToken(e, e^.LParam);			END;	END;PROCEDURE SSetFInfo(e: TParamPtr);	VAR		Str1, Str2, XStr: str255;		pb: HParamBlockRec;		Err: OSerr;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		StrExprXcute(e, @Str1);		NextIntToken(e, e^.LParam);		StrExprXcute(e, @Str2);		XStr := Str1;		WITH pb DO			BEGIN				ioNamePtr := @XStr;				ioVRefNum := 0;				ioCompletion := NIL;				ioFDirIndex := 0;				IODirId := 0;			END;		Err := PbHGetFInfo(@pb, False);		CurTCB^.Error := Err;		IF Err <> NoErr THEN EXIT(SSetFInfo);		BlockMoveData(Ptr(Ord4(@Str2) + 1), @pb.ioFlFndrInfo, 8);		XStr := Str1;		WITH pb DO			BEGIN				ioNamePtr := @XStr;				ioCompletion := NIL;			END;		Err := PbHSetFInfo(@pb, False);		CurTCB^.Error := Err;	END;PROCEDURE SNewFolder(e: TParamPtr);	VAR		Str1: str255;		pb: HParamBlockRec;		Err: OSerr;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		StrExprXcute(e, @Str1);		WITH pb DO			BEGIN				ioNamePtr := @Str1;				ioVRefNum := 0;				ioCompletion := NIL;				IODirId := 0;			END;		Err := PbDirCreate(@pb, False);		CurTCB^.Error := Err;	END;PROCEDURE Cls(e: TParamPtr);	VAR		Str1: str255;		i: Integer;	BEGIN		Str1 := '  X  X  X  X  X';		FOR i := 1 TO 5 DO Str1[i * 3] := FF;		AddDataPaq(@Str1);		Str1 := '    ';		Str1[1] := US;		Str1[2] := chr($40);		Str1[3] := chr($41);		Str1[4] := CAN;		AddDataPaq(@Str1);	END;PROCEDURE SCursor(e: TParamPtr);	VAR		Num1: LongInt;		Str1: str255;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		Str1 := ' ';		IF Num1 > 0 THEN			Str1[1] := DC1		ELSE			Str1[1] := DC4;		AddDataPaq(@Str1);		FlushBuffer;	END;PROCEDURE SDelay(e: TParamPtr);	VAR		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		IF Num1<30 THEN Num1:=1;	{ on raccourci les délais courts… }		IF Num1>0 THEN WaitDelay(Num1);	END;PROCEDURE Disconnect(e: TParamPtr);	VAR		Str1: str255;		TheTime: LongInt;	BEGIN		WaitDelay(30);		Str1 := '   ';		Str1[1] := ESC;		Str1[2] := chr($39);		Str1[3] := chr($67);		{If SnFlag then Str1[1]:=US;}		AddDataPaq(@Str1);		FlushBuffer;		WWriteStr(GetMessage(48));		GetDateTime(TheTime);		IF CurTCB^. StartTime = 0 THEN CurTCB^. StartTime := TheTime;		WWriteNum(abs(TheTime - CurTCB^. StartTime), 8);		WWlnStr(GetMessage(49));		WWlnStr('');		CurTCB^.ConFlag := FALSE;	END;PROCEDURE Draw(e: TParamPtr);	VAR		LgV, LgC, CurPos: LongInt;		LTime, LLen: LongInt;	BEGIN { on envoie par paquets de 128 }		Hlock(TheVCode);		CurPos := 0;		LgV := GetHandleSize(TheVCode);		LLen := 0;		LTime := TickCount;		WHILE CurPos < LgV DO			BEGIN				LgC := LgV - CurPos;				IF LgC > 128 THEN LgC := 128;				StartDataPaq;				PAddBuffer(Ptr(Ord4(TheVCode^) + CurPos), LgC);				EndDataPaq;				FlushBuffer;				CurPos := CurPos + LgC;				IF EmulFlag=FALSE THEN					IF LLen > 1024 THEN						BEGIN							WaitDelay(512 - abs(TickCount - LTime));							LLen := 0;							LTime := TickCount;						END					ELSE						LLen := LLen + LgC;			END;		HUnlock(TheVCode);	END;PROCEDURE SEcho(e: TParamPtr);	VAR		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		EchoFlag := Num1 <> 0;	END;PROCEDURE Flash(e: TParamPtr);	VAR		Num1: LongInt;		Str1: str255;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		Str1 := '  ';		Str1[1] := ESC;		IF Num1 > 0 THEN			Str1[2] := chr($48)		ELSE			Str1[2] := chr($49);		AddDataPaq(@Str1);	END;PROCEDURE SScroll(e: TParamPtr);	VAR		Num1: LongInt;		Str1: str255;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		Str1 := '    ';		Str1[1] := ESC;		Str1[2] := chr($3A);		Str1[3] := START;		Str1[4] := chr($43);		IF Num1 = 0 THEN Str1[3] := STOP;		AddDataPaq(@Str1);		FlushBuffer;	END;PROCEDURE SLower(e: TParamPtr);	VAR		Str1: str255;		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		Str1[4] := chr(4);		Str1[1] := ESC;		Str1[2] := chr($3A);		IF Num1 = 0 THEN Str1[3] := STOP ELSE Str1[3] := START;		Str1[4] := chr($45);		AddDataPaq(@Str1);		FlushBuffer;	END;PROCEDURE GosubScreen(e: TParamPtr);	VAR		Str1: str255;		ex: TParamPtr;	BEGIN		ex := TParamPtr(Ord4(e) + e^.LParam);		NextIntToken(e, SizeOf(Tdummy) + 2);		{ empiler l'adresse de retour }		Empile(LongInt(Ord4(ex) - Ord4(TheCode^)));		{ empiler et charger le nouveau code }		StrExprXcute(e, @Str1);		CStack^^.NbCode := CStack^^.NbCode + 1;		SetHSize(Handle(CStack), SizeOf(Integer) + SizeOf(CodePile) * (CStack^^.NbCode));		WITH CStack^^ DO			BEGIN				TheCodes[NbCode].CodeName := Str1;				TheCodes[NbCode].VolNum := VolCode;			END;		IF TraceFlag THEN WWLnStr(ParamMessage(50,Str1,'','',''));		LoadCode(Str1, VolCode, CurDirID);		Pc := 0;		PcFlag := True;	END;PROCEDURE GotoScreen(e: TParamPtr);	VAR		Str1: str255;		ex: TParamPtr;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		{ empiler et charger le nouveau code }		StrExprXcute(e, @Str1);		CStack^^.NbCode := CStack^^.NbCode + 1;		SetHSize(Handle(CStack), SizeOf(Integer) + SizeOf(CodePile) * (CStack^^.NbCode));		WITH CStack^^ DO			BEGIN				TheCodes[NbCode].CodeName := Str1;				TheCodes[NbCode].VolNum := VolCode;			END;		LoadCode(Str1, VolCode, CurDirID);		IF TraceFlag THEN WWLnStr(ParamMessage(51,Str1,'','',''));		Pc := 0;		PcFlag := True;	END;PROCEDURE CallScreen(e: TParamPtr);	VAR		Str1: str255;		ex: TParamPtr;	BEGIN		ex := TParamPtr(Ord4(e) + e^.LParam);		NextIntToken(e, SizeOf(Tdummy) + 2);		{ empiler l'adresse de retour }		Empile(LongInt(Ord4(ex) - Ord4(TheCode^)));		{ empiler et charger le nouveau code }		StrExprXcute(e, @Str1);		CStack^^.NbCode := CStack^^.NbCode + 1;		SetHSize(Handle(CStack), SizeOf(Integer) + SizeOf(CodePile) * (CStack^^.NbCode));		WITH CStack^^ DO			BEGIN				TheCodes[NbCode].CodeName := Str1;				TheCodes[NbCode].VolNum := VolCode;			END;		IF TraceFlag THEN			BEGIN				WWLnStr(ParamMessage(52,Str1,'','',''));			END;		{LoadCode(Str1, VolCode, CurDirID);		Pc := 0;		PcFlag := True;}	END;PROCEDURE SInput(e: TParamPtr);	VAR		Num1, Numvar, NumIndice: LongInt;		ex: TParamPtr;		nb: Integer;		Str1: str255;		i: Integer;		termine: Boolean;	BEGIN		{ affichage du prompt et du curseur }		nb := e^.nbparam;		NextIntToken(e, SizeOf(Tdummy) + 2);		Str1 := '';		IF nb > 1 THEN			BEGIN				StrExprXcute(e, @Str1);				AddDataPaq(@Str1);				NextIntToken(e, e^.LParam);			END;		{ entree de la zone }		Str1 := '';		CurTCB^.Error := Zinput(Str1, 0, 0, 240, 0, CurTCB^.MaxTime, ' ', True);		{ controle et affectation de la zone }		IF e^.tk = tkStrVar THEN			BEGIN				Numvar := TheCVars^^[e^.Indir].Indir;				SetHSize(Handle(TheVars^^.vars[Numvar].SPtr), length(Str1) + 1);				BlockMoveData(@Str1, Ptr(Ord4(TheVars^^.vars[Numvar].SPtr^)), length(Str1) +									1);			END		ELSE IF e^.tk = tkNumVar THEN			BEGIN				TheVars^^.vars[TheCVars^^[e^.Indir].Indir].Value := SSVal(Str1);			END		ELSE IF e^.tk = tkINUMVAR THEN			BEGIN				ex := TParamPtr(Ord4(e) + SizeOf(Tdummy) + 2);				Numvar := TheCVars^^[ex^.Indir].Indir;				ex := TParamPtr(Ord4(ex) + ex^.LParam);				NumExprXCute(ex, @NumIndice);				IF (NumIndice < 0) OR (NumIndice >= TheVars^^.vars[Numvar].DimVal) THEN				BEGIN					ErrFlag := True;					CurTCB^.Error := ErrIndice;					EXIT(SInput);				END;				SetInd(LongintPtr(Ord4(TheVars^^.vars[Numvar].TVptr^) + NumIndice * 4), SSVal(Str1));			END		ELSE			BEGIN				ex := TParamPtr(Ord4(e) + SizeOf(Tdummy) + 2);				Numvar := TheCVars^^[ex^.Indir].Indir;				ex := TParamPtr(Ord4(ex) + ex^.LParam);				NumExprXCute(ex, @NumIndice);				IF (NumIndice < 0) OR (NumIndice >= TheVars^^.vars[Numvar].DimVal) THEN				BEGIN					ErrFlag := True;					CurTCB^.Error := ErrIndice;					EXIT(SInput);				END;				TheVars^^.vars[Numvar].TSPtr^^[NumIndice] := Str1;			END;		Str1 := ' ';		Str1[1] := DC4;	{ cursor off }		AddDataPaq(@Str1);		FlushBuffer;	END;PROCEDURE Inverse(e: TParamPtr);	VAR		Num1: LongInt;		Str1: str255;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		Str1 := '  ';		Str1[1] := ESC;		IF Num1 > 0 THEN			Str1[2] := chr($5D)		ELSE			Str1[2] := chr($5C);		AddDataPaq(@Str1);	END;PROCEDURE Kill(e: TParamPtr);	VAR		Num1: LongInt;		Str1: str255;		Err: OSerr;		PB: HParamBlockRec;			BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		StrExprXcute(e, @Str1);		WITH PB DO		BEGIN			ioCompletion := NIL;			ioNamePtr := @Str1;			ioVRefNum := 0;			ioDirID := 0;		END;		Err := PBHDelete(@Pb,FALSE);	{ sync }		CurTCB^.Error := PB.IoResult;	END;PROCEDURE Locate(e: TParamPtr);	VAR		Num1, Num2: LongInt;		Str1: str255;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num2);		IF (Num1 > 24) | (Num1 < 0) THEN;		IF (Num2 > 63) | (Num2 < 1) THEN;		Str1 := '   ';		Str1[1] := US;		Str1[2] := chr($40 + Num1);		Str1[3] := chr($40 + Num2);		AddDataPaq(@Str1);	END;PROCEDURE Message(e: TParamPtr);	VAR		Num1, Num2, Num3: LongInt;		Str1: str255;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num2);		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num3);		Str1 := '   ';		Str1[1] := US;		Str1[2] := chr($40 + Num1);		Str1[3] := chr($40 + Num2);		StartDataPaq;		AddBuffer(@Str1);		NextIntToken(e, e^.LParam);		StrExprXcute(e, @Str1);		Opt(Str1);		AddBuffer(@Str1);		Str1 := ' ';		Str1[1] := CAN;		AddBuffer(@Str1);		EndDataPaq;		FlushBuffer;		WaitDelay(Num3);		Str1 := '    ';		Str1[1] := US;		Str1[2] := chr($40 + Num1);		Str1[3] := chr($40 + Num2);		Str1[4] := CAN;		AddDataPaq(@Str1);		FlushBuffer;	END;PROCEDURE MyOpen(e: TParamPtr);	VAR		Num1: LongInt;		Str1: str255;		Err: OSerr;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		NextIntToken(e, e^.LParam);		StrExprXcute(e, @Str1);		IF (Num1 < 1) OR (Num1 > MaxFile) OR (BreakCount > 10) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(MyOpen);			END;		IF (CurTCB^.TheFiles[Num1].FileRef <> 0) THEN			BEGIN				CurTCB^.Error := ErrFileOpen;				EXIT(MyOpen);			END;		Err := FSOpen(Str1,0,CurTCB^.TheFiles[Num1].FileRef);		WITH CurTCB^.TheFiles[Num1] DO			BEGIN				FilePos := 0;				FileRLen := 1;				BaseFlag := False;			END;		IF Err<>noErr THEN CurTCB^.TheFiles[Num1].FileRef := 0;		CurTCB^.Error := Err;	END;PROCEDURE SAppend(e: TParamPtr);	VAR		Num1: LongInt;		Str1: str255;		Err: OSerr;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		NextIntToken(e, e^.LParam);		StrExprXcute(e, @Str1);		IF (Num1 < 1) OR (Num1 > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(SAppend);			END;		IF (CurTCB^.TheFiles[Num1].FileRef <> 0) OR (BreakCount > 50) THEN			BEGIN				CurTCB^.Error := ErrFileOpen;				EXIT(SAppend);			END;		Err := FSOpen(Str1, 0, CurTCB^.TheFiles[Num1].FileRef);		IF Err = 0 THEN Err := SetFPos(CurTCB^.TheFiles[Num1].FileRef, fsFromLEOF, 0);		WITH CurTCB^.TheFiles[Num1] DO			BEGIN				FilePos := 0;				FileRLen := 1;				BaseFlag := False;			END;		IF Err <> 0 THEN CurTCB^.TheFiles[Num1].FileRef := 0;		CurTCB^.Error := Err;	END;PROCEDURE TrPrint(e: TParamPtr);	VAR		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		Byte(CurTCB^.TrPrintFlag) := Num1;	END;PROCEDURE Opt(VAR Str1: str255);	VAR		Str2: str255;		i, j, xi: Integer;		termine: Boolean;		LastCar: char;	PROCEDURE AddStr2(C:CHAR);		BEGIN		IF j<255 THEN		BEGIN			j := j + 1;			Str2[j]:=C;		END;	END;	BEGIN		IF Byte(CurTCB^.TrPrintFlag)=1 THEN EXIT(Opt);		{ compactage de la chaine Str1 -> Str2 }		i := 0;		j := 0;		WHILE (i < length(Str1)) & (j<255) DO			BEGIN				i := i + 1;				j := j + 1;				{ transformation des accents }				LastCar := Str1[i];				IF ord(LastCar) > 127 THEN					BEGIN						CASE LastCar OF							chr(130):								BEGIN									Str2[j]:=SS2;									AddStr2('K');									AddStr2('C');								END;																chr(131):								BEGIN									Str2[j]:=SS2;									AddStr2('B');									AddStr2('E');								END;							'à':								BEGIN									Str2[j]:=SS2;									AddStr2('A');									AddStr2('a');								END;							'â':								BEGIN									Str2[j]:=SS2;									AddStr2('C');									AddStr2('a');								END;							'ä':								BEGIN									Str2[j]:=SS2;									AddStr2('H');									AddStr2('a');								END;							'ç':								BEGIN									Str2[j]:=SS2;									AddStr2('K');									AddStr2('c');								END;							'é':								BEGIN									Str2[j]:=SS2;									AddStr2('B');									AddStr2('e');								END;							'è':								BEGIN									Str2[j]:=SS2;									AddStr2('A');									AddStr2('e');								END;							'ë':								BEGIN									Str2[j]:=SS2;									AddStr2('H');									AddStr2('e');								END;							'ê':								BEGIN									Str2[j]:=SS2;									AddStr2('C');									AddStr2('e');								END;							'ï':								BEGIN									Str2[j]:=SS2;									AddStr2('H');									AddStr2('i');								END;							'î':								BEGIN									Str2[j]:=SS2;									AddStr2('C');									AddStr2('i');								END;							'ô':								BEGIN									Str2[j]:=SS2;									AddStr2('C');									AddStr2('o');								END;							'ù':								BEGIN									Str2[j]:=SS2;									AddStr2('A');									AddStr2('u');								END;							'ü':								BEGIN									Str2[j]:=SS2;									AddStr2('H');									AddStr2('u');								END;							'û':								BEGIN									Str2[j]:=SS2;									AddStr2('C');									AddStr2('u');								END;							OTHERWISE Str2[j] := ' ';						END;					END				ELSE					Str2[j] := LastCar;				{ on regarde le nombre de cars identiques }				termine := False;				xi := i;				WHILE (i < length(Str1)) AND (NOT termine) DO					BEGIN						IF (Str1[i + 1] = LastCar) & (LastCar>=' ') THEN							i := i + 1						ELSE							termine := True;					END;				{ le nombre de cars repeter est egal a i-xi }				xi := i - xi;				IF (xi > 2) OR ((ord(LastCar) > 127) AND (xi > 0)) THEN					BEGIN						IF xi < 64 THEN							BEGIN								Str2[j + 1] := REP;								Str2[j + 2] := chr($40 + xi);								xi := 0;								j := j + 2;							END						ELSE							BEGIN								Str2[j + 1] := REP;								Str2[j + 2] := chr($40 + 63);								j := j + 2;								i := i - xi + 63;								CYCLE;							END;					END				ELSE				{ on recopie les 2 cars max }				IF xi > 0 THEN					BEGIN						Str2[j + 1] := LastCar;						IF xi > 1 THEN Str2[j + 2] := LastCar;						j := j + xi;					END;			END;		{ on met a jour la longueur de la chaine resultante }		Str2[0] := chr(j);		Str1 := Str2;	END;PROCEDURE Print(e: TParamPtr);	VAR		Num1: LongInt;		nb, i: Integer;		Str1: str255;		LastTk: Integer;	BEGIN		nb := e^.nbparam;		NextIntToken(e, SizeOf(Tdummy) + 2);		LastTk := 0;		FOR i := 1 TO nb DO			BEGIN				LastTk := e^.tk;				{ on va a la peche des parametres }				CASE mots^^[e^.tk].tfunc OF					fvarstr, fcststr, fcstr, fStr, fistrvar: StrExprXcute(e, @Str1);					fcnum, fnum, fcstnum, fvarnum, finumvar:						BEGIN							NumExprXCute(e, @Num1);							NumToString(Num1, Str1);						END;					OTHERWISE						IF LastTk = TkV THEN							Str1 := ' '						ELSE							Str1 := '';				END;				NextIntToken(e, e^.LParam);				{ on optimise }				Opt(Str1);				IF length(Str1) > 240 THEN Str1[0] := chr(240);				IF length(Str1) > 0 THEN AddDataPaq(@Str1);			END;		IF (LastTk <> TkV) AND (LastTk <> TkPV) THEN			BEGIN				Str1 := '  ';				Str1[1] := chr($0D);				Str1[2] := chr($0A);				AddDataPaq(@Str1);			END;		FlushBuffer;	END;PROCEDURE RLen(e: TParamPtr);	VAR		NumFile, Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(RLen);			END;		IF (CurTCB^.TheFiles[NumFile].FileRef = 0) OR CurTCB^.TheFiles[NumFile].BaseFlag THEN			BEGIN				CurTCB^.Error := ErrNotOpen;				EXIT(RLen);			END;		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num1);		IF Num1 < 1 THEN Num1 := 1;		CurTCB^.TheFiles[NumFile].FileRLen := Num1;	END;PROCEDURE RSeek(e: TParamPtr);	VAR		NumFile, Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(RSeek);			END;		IF (CurTCB^.TheFiles[NumFile].FileRef = 0) OR CurTCB^.TheFiles[NumFile].BaseFlag THEN			BEGIN				CurTCB^.Error := ErrNotOpen;				EXIT(RSeek);			END;		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num1);		IF Num1 < 0 THEN Num1 := 0;		CurTCB^.TheFiles[NumFile].FilePos := Num1 * CurTCB^.TheFiles[NumFile].FileRLen;		CurTCB^.Error := NoErr;	END;PROCEDURE SSeek(e: TParamPtr);	VAR		NumFile, Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(SSeek);			END;		IF (CurTCB^.TheFiles[NumFile].FileRef = 0) THEN			BEGIN				CurTCB^.Error := ErrNotOpen;				EXIT(SSeek);			END;		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num1);		IF Num1 < 0 THEN Num1 := 0;		IF CurTCB^.TheFiles[NumFile].BaseFlag THEN			BEGIN				IF Num1 <= FichEnd THEN					FichPtr := Num1				ELSE					BEGIN						IF Num1 < FichSize THEN							BEGIN								SetBaseEnd(Num1);								FichPtr := FichEnd;							END;					END;			END		ELSE			BEGIN				CurTCB^.TheFiles[NumFile].FilePos := Num1;			END;	END;PROCEDURE LoadScreen(e: TParamPtr);	VAR		refw: Integer;		Err: OSerr;		count, Vlg: LongInt;		Str1: str255;	PROCEDURE ShowErr;		BEGIN		ErrFlag := True;		CurTCB^.Error := ErrNonXFile;		EXIT(LoadScreen);	END;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		StrExprXcute(e, @Str1);		IF VerifType(volCode,CurDirID,Str1)=FALSE THEN ShowErr;		HUnlock(Handle(TheCode));				Err := HOpen(VolCode,CurDirID,Str1,fsRdPerm, refw);		IF (Err <> 0) THEN			BEGIN				Err := FSOpen(Str1, 0, refw);				IF Err <> 0 THEN ShowErr;			END;		{ code VideoTex compacte }		count := SizeOf(LongInt);		Err := FSRead(refw, count, @Vlg);		IF (Err <> 0) THEN			BEGIN				Vlg := 0;			END;		SetHSize(TheVCode, Vlg);		Err := FSRead(refw, Vlg, TheVCode^);		IF (Err <> 0) THEN			BEGIN				SetHSize(TheVCode, 0);			END;		Err := FsClose(refw);		Hlock(Handle(TheCode));	END;PROCEDURE DrawScreen(e: TParamPtr);	VAR		refw: Integer;		Err: OSerr;		count, Vlg: LongInt;		Str1: str255;		TheCV: Handle;		LgC, LgV, CurPos: LongInt;		LTime, LLen: LongInt;	PROCEDURE ShowErr;	BEGIN		ErrFlag := True;		CurTCB^.Error := ErrNonXFile;		EXIT(DrawScreen);	END;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		StrExprXcute(e, @Str1);		IF VerifType(volCode,CurDirID,Str1)=FALSE THEN ShowErr;		Err := HOpen(VolCode,CurDirID,Str1, fsRdPerm, refw);		IF (Err <> 0) THEN			BEGIN				Err := FSOpen(Str1, 0, refw);				IF Err <> 0 THEN ShowErr;			END;		{ code VideoTex compacte }		count := SizeOf(LongInt);		Err := FSRead(refw, count, @Vlg);		IF (Err <> 0) THEN Vlg := 0;		TheCV := NewHandle(Vlg);		HNoPurge(TheCV);		Err := FSRead(refw, Vlg, TheCV^);		Err := FsClose(refw);		Hlock(TheCV);		CurPos := 0;		LgV := GetHandleSize(TheCV);		LLen := 0;		LTime := TickCount;		WHILE CurPos < LgV DO			BEGIN				LgC := LgV - CurPos;				IF LgC > 128 THEN LgC := 128;				StartDataPaq;				PAddBuffer(Ptr(Ord4(TheCV^) + CurPos), LgC);				EndDataPaq;				FlushBuffer;				CurPos := CurPos + LgC;				IF EmulFlag=FALSE THEN					IF LLen > 1024 THEN						BEGIN							WaitDelay(512 - abs(TickCount - LTime));							LLen := 0;							LTime := TickCount;						END					ELSE						LLen := LLen + LgC;			END;		HUnlock(TheCV);		DisposHandle(TheCV);	END;PROCEDURE PrintScreenBis(screen:Str255);	VAR		refw: Integer;		Err: OSerr;		count, Vlg: LongInt;		TheCV: Handle;		LgC, LgV, CurPos: LongInt;		LTime, LLen: LongInt;		fndrInfo: FInfo;	BEGIN		CurTCB^.Error := HGetFInfo(VolCode,CurDirId,screen,fndrInfo);		IF CurTCB^.Error <> NoErr THEN EXIT(PrintscreenBis);		Err := HOpen(VolCode,CurDirId,screen, fsRdPerm, refw);		IF (Err <> 0) THEN		BEGIN			Err := FSOpen(screen, 0, refw);			IF Err <> 0 THEN			BEGIN				CurTCB^.Error := ErrNonXFile;				EXIT(PrintScreenBis);			END;		END;		IF fndrInfo.fdType = 'VCOD' THEN { format VCOD }		BEGIN		  count := SizeOf(LongInt);		  Err := FSRead(refw, count, @Vlg);		  IF (Err <> 0) THEN Vlg := 0;		END		ELSE CurTCB^.Error := GetEOF(refw,Vlg);	{ format VTEX et autres… }		TheCV := NewHandle(Vlg);		HNoPurge(TheCV);		Err := FSRead(refw, Vlg, TheCV^);		IF (Err <> 0) THEN			BEGIN				SetHSize(TheCV, 0);			END;		Err := FsClose(refw);		Hlock(TheCV);		CurPos := 0;		LgV := GetHandleSize(TheCV);		LLen := 0;		LTime := TickCount;		WHILE CurPos < LgV DO			BEGIN				LgC := LgV - CurPos;				IF LgC > 128 THEN LgC := 128;				StartDataPaq;				PAddBuffer(Ptr(Ord4(TheCV^) + CurPos), LgC);				EndDataPaq;				FlushBuffer;				CurPos := CurPos + LgC;				IF EmulFlag=FALSE THEN					IF LLen > 1024 THEN						BEGIN							WaitDelay(512 - abs(TickCount - LTime));							LLen := 0;							LTime := TickCount;						END					ELSE						LLen := LLen + LgC;			END;		HUnlock(TheCV);		DisposHandle(TheCV);	END;PROCEDURE PrintScreen(e:TParamPtr);VAR	screen: Str255;BEGIN	NextIntToken(e, SizeOf(Tdummy) + 2);	StrExprXcute(e, @screen);	PrintScreenBis(screen);END;PROCEDURE FrontScreen(e: TParamPtr);VAR	Str1: str255;	Num1: LongInt;BEGIN	IF EmulFlag THEN EXIT(FrontScreen);		NextIntToken(e, SizeOf(Tdummy) + 2);	NumExprXCute(e, @Num1);	{ on met l'entete dans le buffer }	IF Num1 = 0 THEN		BEGIN			Str1 := '';			PaqPrep(Str1, 't');		END	ELSE		BEGIN			Str1 := 'S';			PaqPrep(Str1, 'T');		END;	AddBuffer(@Str1);	FlushBuffer;END;{$S INTERPRETEUR2}PROCEDURE SSysParm(e: TParamPtr);	VAR		Str1, Str2: str255;		Num1: LongInt;	BEGIN		IF EmulFlag THEN EXIT(SSysParm);				NextIntToken(e, SizeOf(Tdummy) + 2);		Str1 := 'YY';		NumExprXCute(e, @Num1);		IF Num1 = 0 THEN			BEGIN				Str1[1] := 'N';			END;		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num1);		IF Num1 = 0 THEN			BEGIN				Str1[2] := 'N';			END;		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num1);		IF Num1 > 999 THEN Num1 := 999;		IF Num1 < 0 THEN Num1 := 0;		NumToString(Num1, Str2);		WHILE length(Str2) < 3 DO Insert('0', Str2, 1);		Str1 := Concat(Str1, Str2);		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num1);		IF Num1 > 999 THEN Num1 := 999;		IF Num1 < 0 THEN Num1 := 0;		NumToString(Num1, Str2);		WHILE length(Str2) < 3 DO Insert('0', Str2, 1);		Str1 := Concat(Str1, Str2);		PaqPrep(Str1, 'P');		AddBuffer(@Str1);		FlushBuffer;	END;PROCEDURE SEnqueue(e: TParamPtr);	BEGIN	END;PROCEDURE SDequeue(e: TParamPtr; AdStr: pstr255);BEGIN	AdStr^ := '';	CurTCB^.Error := ErrQEmpty;END;PROCEDURE QueueSize(e: TParamPtr; AdNum: LongintPtr);BEGIN	AdNum^ := 0;END;PROCEDURE MessULoad(e: TParamPtr);VAR	Num1: LongInt;	Str1, Str2: str255;	ex: TParamPtr;BEGIN	IF EmulFlag THEN EXIT(MessULoad);		NextIntToken(e, SizeOf(Tdummy) + 2);	NumExprXCute(e, @Num1);	IF Num1 > 99 THEN Num1 := 99;	IF Num1 < 0 THEN Num1 := 0;	NumToString(Num1, Str1);	IF length(Str1) = 1 THEN Insert('0', Str1, 1);	NextIntToken(e, e^.LParam);	StrExprXcute(e, @Str2);	Str1 := Concat(Str1, Str2);	PaqPrep(Str1, 'T');	AddBuffer(@Str1);	FlushBuffer;END;PROCEDURE MessDLoad(e: TParamPtr; AdStr: pstr255);VAR	Num1: LongInt;	Str1: str255;BEGIN	AdStr^ := '';	IF EmulFlag THEN EXIT(MessDLoad);		NextIntToken(e, SizeOf(Tdummy) + 2);	NumExprXCute(e, @Num1);	IF Num1 > 99 THEN Num1 := 99;	IF Num1 < 0 THEN Num1 := 0;	NumToString(Num1, Str1);	IF length(Str1) = 1 THEN Insert('0', Str1, 1);	PaqPrep(Str1, 'L');	AsRead(Str1, AdStr^, 120, False);	IF length(AdStr^) > 0 THEN Delete(AdStr^, 1, 1);END;PROCEDURE cptr2p(C: Ptr; VAR p: str255);VAR	i: Integer;	cx: Ptr;BEGIN	cx := C;	i := 0;	WHILE (C^ <> 0) AND (i < 255) DO		BEGIN			i := i + 1;			C := Ptr(Ord4(C) + 1);		END;	BlockMoveData(cx, Ptr(Ord4(@p) + 1), i);	p[0] := chr(i);END;PROCEDURE FAsOpen(TheStr: Ptr; NumFile: LongInt);VAR	Str1: str255;BEGIN	cptr2p(TheStr, Str1);	CurTCB^.Error := FSOpen(Str1, 0, RefFSe);END;PROCEDURE FAsRead(NumFile: LongInt; TheCBuffer: Ptr; count: LongInt);	BEGIN		CurTCB^.Error := FSRead(RefFSe, count, TheCBuffer);	END;PROCEDURE FAsClose(NumFile: LongInt);	BEGIN		CurTCB^.Error := FsClose(RefFSe);	END;PROCEDURE Ise_INIT(e: TParamPtr);	BEGIN	END;PROCEDURE SRead(e: TParamPtr);	VAR		NumFile, Num1, Numvar, NumIndice: LongInt;		termine: Boolean;		ex: TParamPtr;		nb, i: Integer;		Str1: str255;		Err: OSerr;		C: char;		pb: Paramblockrec;		count: LongInt;	BEGIN		nb := e^.nbparam;		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(SRead);			END;		IF CurTCB^.TheFiles[NumFile].FileRef = 0 THEN			BEGIN				CurTCB^.Error := ErrNotOpen;				EXIT(SRead);			END;		NextIntToken(e, e^.LParam);		FOR i := 2 TO nb DO			BEGIN				IF CurTCB^.TheFiles[NumFile].BaseFlag THEN					BEGIN						{ on lit entre FichPtr et FichEnd }						Str1 := '';						C := ' ';						IF FichPtr < FichEnd THEN							WITH MyFicheHdl^^ DO								REPEAT									C := PCHdl(ContenuHdl)^^[FichPtr];									FichPtr := FichPtr + 1;									IF (C <> chr($09)) AND (C <> chr($0D)) THEN										BEGIN											Str1[0] := chr(length(Str1) + 1);											Str1[length(Str1)] := C;										END;								UNTIL (FichPtr >= FichEnd) OR (C = chr($09)) OR (C =											chr($0D)) OR (length(Str1) = 255);						IF FichPtr >= FichEnd THEN Err := EofErr;					END				ELSE					BEGIN						{ on va a la peche des parametres }						Str1 := '';						C := ' ';						REPEAT							Num1 := 1;							WITH pb DO								BEGIN									ioCompletion := NIL;									ioRefNum := CurTCB^.TheFiles[NumFile].FileRef;									ioBuffer := Ptr(Ord4(@C) + 1);									ioReqCount := 1;									ioPosMode := fsFromStart;									ioPosOffset := CurTCB^.TheFiles[NumFile].FilePos;								END;							IF CurTCB^.TheFiles[NumFile].FileRef > 0 THEN								BEGIN									Err := PbRead(@pb, False);									CurTCB^.TheFiles[NumFile].FilePos := pb.ioPosOffset;									Err := pb.ioResult;								END							ELSE								BEGIN									REPEAT										Err := SerGetBuf(CurTCB^.TheFiles[NumFile].FileRef, count);										CheckButton;									UNTIL (count > 0) OR (NOT RunFlag);									IF count > 0 THEN										BEGIN											Err := PbRead(@pb, False);											Err := pb.ioResult;										END;								END;							IF (Err = 0) AND (C <> chr($09)) AND (C <> chr($0D)) THEN								BEGIN									Str1[0] := chr(length(Str1) + 1);									Str1[length(Str1)] := C;								END;						UNTIL (Err <> 0) OR (C = chr($09)) OR (C = chr($0D)) OR									(NOT RunFlag) OR (length(Str1) = 255);					END;				IF e^.tk = tkStrVar THEN					BEGIN						Numvar := TheCVars^^[e^.Indir].Indir;						SetHSize(Handle(TheVars^^.vars[Numvar].SPtr), length(Str1) +													1);						BlockMoveData(@Str1, Ptr(Ord4(TheVars^^.vars[Numvar].SPtr^)),											length(Str1) + 1);					END				ELSE IF e^.tk = tkNumVar THEN					BEGIN						TheVars^^.vars[TheCVars^^[e^.Indir].Indir].Value := SSVal(Str1);					END				ELSE IF e^.tk = tkINUMVAR THEN					BEGIN						ex := TParamPtr(Ord4(e) + SizeOf(Tdummy) + 2);						Numvar := TheCVars^^[ex^.Indir].Indir;						ex := TParamPtr(Ord4(ex) + ex^.LParam);						NumExprXCute(ex, @NumIndice);						IF (NumIndice < 0) OR							 (NumIndice >= TheVars^^.vars[Numvar].DimVal) THEN							BEGIN								ErrFlag := True;								CurTCB^.Error := ErrIndice;								EXIT(SRead);							END;						SetInd(LongintPtr(Ord4(TheVars^^.vars[Numvar].TVptr^) +									 NumIndice * 4), SSVal(Str1));					END				ELSE					BEGIN						ex := TParamPtr(Ord4(e) + SizeOf(Tdummy) + 2);						Numvar := TheCVars^^[ex^.Indir].Indir;						ex := TParamPtr(Ord4(ex) + ex^.LParam);						NumExprXCute(ex, @NumIndice);						IF (NumIndice < 0) OR (NumIndice >= TheVars^^.vars[Numvar].DimVal) THEN						BEGIN							ErrFlag := True;							CurTCB^.Error := ErrIndice;							EXIT(SRead);						END;						TheVars^^.vars[Numvar].TSPtr^^[NumIndice]:=Str1;					END;				NextIntToken(e, e^.LParam);			END;		CurTCB^.Error := Err;	END;PROCEDURE BRead(e: TParamPtr);	VAR		NumFile, Num1, Numvar, NumIndice, NumLen: LongInt;		ex: TParamPtr;		Err: OSerr;		pb: Paramblockrec;		FichCalc: Integer;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(BRead);			END;		IF CurTCB^.TheFiles[NumFile].FileRef = 0 THEN			BEGIN				CurTCB^.Error := ErrNotOpen;				EXIT(BRead);			END;		NextIntToken(e, e^.LParam);		ex := e; { ex pointe sur la variable }		NextIntToken(e, e^.LParam);		NumExprXCute(e, @NumLen);		IF (NumLen > 4) THEN NumLen := 4;		IF NumLen < 0 THEN NumLen := 0;		{ on va a la peche des parametres }		Num1 := 0;		IF CurTCB^.TheFiles[NumFile].BaseFlag THEN			BEGIN				{ on lit entre FichPtr et FichEnd }				FichCalc := FichEnd - FichPtr;				IF FichCalc > NumLen THEN FichCalc := NumLen;				BlockMoveData(Ptr(Ord4(MyFicheHdl^^.ContenuHdl^) + FichPtr),									Ptr(Ord4(@Num1) + 4 - FichCalc), FichCalc);				FichPtr := FichPtr + FichCalc;				IF FichCalc < NumLen THEN Err := EofErr;			END		ELSE			BEGIN				WITH pb DO					BEGIN						ioCompletion := NIL;						ioRefNum := CurTCB^.TheFiles[NumFile].FileRef;						ioBuffer := Ptr(Ord4(@Num1) + 4 - NumLen);						ioReqCount := NumLen;						ioPosMode := fsFromStart;						ioPosOffset := CurTCB^.TheFiles[NumFile].FilePos;					END;				Err := PbRead(@pb, False);				CurTCB^.TheFiles[NumFile].FilePos := pb.ioPosOffset;				Err := pb.ioResult;			END;		IF ex^.tk = tkNumVar THEN			BEGIN				TheVars^^.vars[TheCVars^^[ex^.Indir].Indir].Value := Num1;			END		ELSE IF ex^.tk = tkINUMVAR THEN			BEGIN				ex := TParamPtr(Ord4(ex) + SizeOf(Tdummy) + 2);				Numvar := TheCVars^^[ex^.Indir].Indir;				ex := TParamPtr(Ord4(ex) + ex^.LParam);				NumExprXCute(ex, @NumIndice);				IF (NumIndice < 0) OR (NumIndice >= TheVars^^.vars[Numvar].DimVal) THEN					BEGIN						ErrFlag := True;						CurTCB^.Error := ErrIndice;						EXIT(BRead);					END;				SetInd(LongintPtr(Ord4(TheVars^^.vars[Numvar].TVptr^) + NumIndice * 4),							 Num1);			END;		CurTCB^.Error := Err;	END;PROCEDURE BWrite(e: TParamPtr);	VAR		NumFile, Num1, Numvar, NumIndice, NumLen: LongInt;		ex: TParamPtr;		Err: OSerr;		pb: Paramblockrec;		FichCalc: Integer;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(BWrite);			END;		IF CurTCB^.TheFiles[NumFile].FileRef = 0 THEN			BEGIN				CurTCB^.Error := ErrNotOpen;				EXIT(BWrite);			END;		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num1);		NextIntToken(e, e^.LParam);		NumExprXCute(e, @NumLen);		IF (NumLen > 4) THEN NumLen := 4;		IF NumLen < 0 THEN NumLen := 0;		{ on va a la peche des parametres }		IF CurTCB^.TheFiles[NumFile].BaseFlag THEN			BEGIN				{ on ecrit entre FichPtr et jusqu'à FichSize-1 }				FichCalc := FichSize - FichPtr;				IF FichCalc > NumLen THEN FichCalc := NumLen;				IF FichEnd < FichPtr + FichCalc THEN SetBaseEnd(FichPtr + FichCalc);				BlockMoveData(Ptr(Ord4(@Num1) + 4 - NumLen), Ptr(Ord4(MyFicheHdl^^.																													ContenuHdl^) +																										 FichPtr), NumLen);				FichPtr := FichPtr + FichCalc;			END		ELSE			BEGIN				WITH pb DO					BEGIN						ioCompletion := NIL;						ioRefNum := CurTCB^.TheFiles[NumFile].FileRef;						ioBuffer := Ptr(Ord4(@Num1) + 4 - NumLen);						ioReqCount := NumLen;						ioPosMode := fsFromStart;						ioPosOffset := CurTCB^.TheFiles[NumFile].FilePos;					END;				Err := PbWrite(@pb, False);				CurTCB^.TheFiles[NumFile].FilePos := pb.ioPosOffset;				Err := pb.ioResult;			END;		CurTCB^.Error := Err;	END;PROCEDURE SLock(e: TParamPtr);	VAR		NumFile: LongInt;		nb: Integer;	BEGIN		nb := e^.nbparam;		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(SLock);			END;		IF (CurTCB^.TheFiles[NumFile].FileRef = 0) THEN			BEGIN				CurTCB^.Error := ErrNotOpen;				EXIT(SLock);			END;		CurTCB^.Error := 0;	END;PROCEDURE SUnLock(e: TParamPtr);	VAR		NumFile: LongInt;		nb: Integer;	BEGIN		nb := e^.nbparam;		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(SUnLock);			END;		IF (CurTCB^.TheFiles[NumFile].FileRef = 0) THEN			BEGIN				CurTCB^.Error := ErrNotOpen;				EXIT(SUnLock);			END;		CurTCB^.Error := 0;	END;PROCEDURE SNControl(e: TParamPtr);	BEGIN		CurTCB^.Error := 0;	END;PROCEDURE Dial(e: TParamPtr);VAR	Str1: str255;BEGIN	IF EmulFlag THEN EXIT(Dial);		NextIntToken(e, SizeOf(Tdummy) + 2);	StrExprXcute(e, @Str1);	PaqPrep(Str1, 'A');	AddBuffer(@Str1);	FlushBuffer;END;PROCEDURE SRestart(e: TParamPtr);	BEGIN		ErrFlag := True;		StartFlag := True;	END;PROCEDURE YieldCpu(e: TParamPtr);	BEGIN		SystemTask;	END;PROCEDURE SWModem(e: TParamPtr);VAR	Str1: str255;BEGIN	IF EmulFlag THEN EXIT(SWModem);		Str1 := '';	PaqPrep(Str1, 'R');	AddBuffer(@Str1);	FlushBuffer;END;PROCEDURE SSetPriority(e: TParamPtr);VAR	Str1: str255;	Num1: LongInt;BEGIN	NextIntToken(e, SizeOf(Tdummy) + 2);	NumExprXCute(e, @Num1);	IF (Num1 MOD 256) >= 20 THEN CurTCB^.TaskPriority := (Num1 MOD 256);END;PROCEDURE SRequest(e: TParamPtr);BEGIN	CurTCB^.Error := 0;END;PROCEDURE SPend(e: TParamPtr; AdNum: LongintPtr);BEGIN	CurTCB^.Error := 0;END;PROCEDURE SPost(e: TParamPtr);BEGIN	CurTCB^.Error := 0;END;PROCEDURE SetMinID(e: TParamPtr);	VAR		Str1, Str2: str255;		Num1: LongInt;		nbcar: Integer;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		NextIntToken(e, e^.LParam);		StrExprXcute(e, @Str2);		IF (Num1 < 0) OR (Num1 > 1) THEN EXIT(SetMinID);		CASE Num1 OF			0:				BEGIN					Str1 := '   ';					Str1[1] := ESC;					Str1[2] := chr($39);					Str1[3] := IDEN1;				END;			1:				BEGIN					Str1 := '   ';					Str1[1] := ESC;					Str1[2] := chr($39);					Str1[3] := IDEN2;				END;		END;		Str1[4] := SOH;		nbcar := length(Str2);		IF nbcar > 15 THEN nbcar := 15;		BlockMoveData(Ptr(Ord4(@Str2) + 1), Ptr(Ord4(@Str1) + 5), nbcar);		IF nbcar < 15 THEN			BEGIN				Str1[nbcar + 5] := EOT;				nbcar := nbcar + 1;			END;		nbcar := nbcar + 4;		Str1[0] := chr(nbcar);		AddDataPaq(@Str1);		FlushBuffer;	END;PROCEDURE SRename(e: TParamPtr);	VAR		Str1, Str2: str255;		Err: OSerr;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		StrExprXcute(e, @Str1);		NextIntToken(e, e^.LParam);		StrExprXcute(e, @Str2);		Err := Rename(Str1, 0, Str2);		CurTCB^.Error := Err;	END;PROCEDURE ResetZones(e: TParamPtr);	BEGIN		curTCB^.NbZones := 0;	END;PROCEDURE SSize(e: TParamPtr);	VAR		Num1: LongInt;		Str1: str255;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		IF (Num1 >= 0) AND (Num1 < 4) THEN			BEGIN				Str1 := '  ';				Str1[1] := ESC;				Str1[2] := chr($4C + Num1);				AddDataPaq(@Str1);			END;	END;PROCEDURE TimeOut(e: TParamPtr);	VAR		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		CurTCB^.MaxTime := Num1 * 60;	END;PROCEDURE STrace(e: TParamPtr);	VAR		Num1: LongInt;		nb, i,j: Integer;		Str1: str255;		LastTk: Integer;	BEGIN		nb := e^.nbparam;		NextIntToken(e, SizeOf(Tdummy) + 2);		LastTk := 0;		FOR i := 1 TO nb DO			BEGIN				j :=i;				LastTk := e^.tk;				{ on va a la peche des parametres }				CASE mots^^[e^.tk].tfunc OF					fvarstr, fcststr, fcstr, fStr, fistrvar: StrExprXcute(e, @Str1);					fcnum, fnum, fcstnum, fvarnum, finumvar:						BEGIN							NumExprXCute(e, @Num1);							NumToString(Num1, Str1);						END;					OTHERWISE						IF LastTk = TkV THEN							Str1 := ' '						ELSE							Str1 := '';				END;				i := j;				NextIntToken(e, e^.LParam);				IF length(Str1) > 0 THEN IF Trace2Flag THEN WWriteStr(Str1);			END;		IF (LastTk <> TkV) AND (LastTk <> TkPV) THEN IF Trace2Flag THEN WWlnStr('');	END;PROCEDURE STron(e: TParamPtr);	BEGIN		TraceFlag := True;	END;PROCEDURE STroff(e: TParamPtr);	BEGIN		TraceFlag := False;	END;PROCEDURE SUnderLine(e: TParamPtr);	VAR		Num1: LongInt;		Str1: str255;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		Str1 := '  ';		Str1[1] := ESC;		IF Num1 > 0 THEN			Str1[2] := chr($5A)		ELSE			Str1[2] := chr($59);		AddDataPaq(@Str1);	END;PROCEDURE WaitBis(NumZone:INTEGER);LABEL 0;VAR	Num1, Numvar: LongInt;	Str1, Str2: str255;	i, k, NextZone: Integer;	termine: Boolean;	C: char;	count: Integer;	redraw: BOOLEAN;	{ indique si il faut redessiner les zones }		 { changement du 10/09/86:			no de var du fichier remplace par no de var globale:			TheCVars^^[e^.Indir].indir au lieu de e^.indir				}	PROCEDURE SelectZone(i, j: Integer);		BEGIN			WITH CurTCB^ DO			BEGIN				IF j <> 0 THEN				CASE TheZones[j].tkVar OF					0:	{ variable = pointeur vers Str255 }						StringPtr(TheZones[j].AdVar)^:=Str1;										tkStrVar:					BEGIN						Numvar := TheZones[j].Numvar;						SetHSize(Handle(TheVars^^.vars[Numvar].SPtr), length(Str1) + 1);						BlockMoveData(@Str1, Ptr(Ord4(TheVars^^.vars[Numvar].SPtr^)), length(Str1) + 1);					END;										tkNumVar:						TheVars^^.vars[TheZones[j].Numvar].Value := SSVal(Str1);						tkINUMVAR:						SetInd(LongintPtr(Ord4(TheVars^^.vars[TheZones[j].Numvar].TVptr^) + Ord4(TheZones[j].IndVar) * 4),SSVal(Str1));						tkISTRVar:					BEGIN						Numvar := TheZones[j].Numvar;						TheVars^^.vars[Numvar].TSPtr^^[TheZones[j].IndVar] := Str1;					END;				END;	{ CASE }			END;	{ WITH }						IF i = 0 THEN EXIT(SelectZone);			WITH CurTCB^ DO				BEGIN					CASE TheZones[i].tkVar OF						0:	{ variable = pointeur vers Str255 }							Str1 := StringPtr(TheZones[i].AdVar)^;													tkStrVar:							Str1 := TheVars^^.vars[TheZones[i].Numvar].SPtr^^;													tkNumVar:						BEGIN							Num1 := TheVars^^.vars[TheZones[i].Numvar].Value;							IF Num1 = 0 THEN Str1 := '' ELSE NumToString(Num1, Str1);						END;												tkINUMVAR:						BEGIN							Num1 := LongintPtr(Ord4(TheVars^^.vars[TheZones[i].Numvar].TVptr^) + Ord4(TheZones[i].IndVar) * 4)^;							IF Num1 = 0 THEN Str1 := '' ELSE NumToString(Num1, Str1);						END;												tkISTRVar:							Str1 := TheVars^^.vars[TheZones[i].Numvar].TSPtr^^[TheZones[i].IndVar];					END;	{ CASE }										IF length(Str1) > TheZones[i].len THEN						BlockMoveData(Ptr(Ord4(@TheZones[i].len) + 1), @Str1, 1);				END;		END;	PROCEDURE ResetVars;		VAR			i, Numvar: Integer;		BEGIN { Reset de toutes les vars de saisie }			Str1 := '';			{ affichage des valeurs par defaut et des pointilles }			WITH CurTCB^ DO				FOR i := 1 TO NbZones DO					BEGIN						CASE TheZones[i].tkVar OF							0:	{ adresse d'une Str255 en mémoire }								StringPtr(TheZones[i].AdVar)^:='';															tkStrVar:							BEGIN								Numvar := TheZones[i].Numvar;								SetHSize(Handle(TheVars^^.vars[Numvar].SPtr), length(Str1) + 1);								BlockMoveData(@Str1, Ptr(Ord4(TheVars^^.vars[Numvar].SPtr^)), length(Str1) + 1);							END;													tkNumVar:								TheVars^^.vars[TheZones[i].Numvar].Value := 0;													tkINUMVAR:								SetInd(LongintPtr(Ord4(TheVars^^.vars[TheZones[i].Numvar].TVptr^) + Ord4(TheZones[i].IndVar) * 4), 0);							tkISTRVar:							BEGIN								Numvar := TheZones[i].Numvar;								TheVars^^.vars[Numvar].TSPtr^^[TheZones[i].IndVar]:=Str1;							END;						END;	{ CASE }					END;		END;	BEGIN		IF CurTCB^.NbZones = 0 THEN		BEGIN			CurTCB^. ZoneNumber := 0;			CurTCB^.Error := ErrTime;			EXIT(WaitBis);		END;		IF NumZone = 0 THEN NumZone := CurTCB^. ZoneNumber;	{ on reprend la dernière zone }		IF NumZone <0 THEN		BEGIN			Redraw := FALSE;			NumZone := -NumZone;		END ELSE Redraw := TRUE;		IF NumZone > CurTCB^.NbZones THEN NumZone := CurTCB^.NbZones;	0:		{ ======== affichage des valeurs par defaut et des pointilles ======== }		IF Redraw THEN WITH CurTCB^ DO			FOR i := 1 TO NbZones DO				BEGIN					{ =========== on choppe la valeur par defaut =========== }					CASE TheZones[i].tkVar OF						0:							Str1 := StringPtr(theZones[i].AdVar)^;													tkStrVar:							Str1 := TheVars^^.vars[TheZones[i].Numvar].SPtr^^;												tkNumVar:						BEGIN							Num1 := TheVars^^.vars[TheZones[i].Numvar].Value;							IF Num1 = 0 THEN Str1 := '' ELSE NumToString(Num1, Str1);						END;												tkINUMVAR:						BEGIN							Num1 := LongintPtr(Ord4(TheVars^^.vars[TheZones[i].Numvar].TVptr^) + Ord4(TheZones[i].IndVar) * 4)^;							IF Num1 = 0 THEN Str1 := '' ELSE NumToString(Num1, Str1);						END;												tkISTRVar:							Str1 := TheVars^^.vars[TheZones[i].Numvar].TSPtr^^[TheZones[i].IndVar];					END;	{ CASE }										IF length(Str1) > TheZones[i].len THEN						BlockMoveData(Ptr(Ord4(@TheZones[i].len) + 1), @Str1, 1);											{ ========= positionnement ========== }					Str2 := '   ';					Str2[1] := US;					Str2[2] := chr($40 + TheZones[i].Posx);					Str2[3] := chr($40 + TheZones[i].PosY);					AddDataPaq(@Str2);					{ ========= affichage des attributs ========= }					{ ***** Couleur ***** }					k := BitAnd(theZones[i].Color, 7);					IF k <> 7 THEN { autre que blanc }					BEGIN						CASE k OF							1: k := 4;							2: k := 1;							3: k := 5;							4: k := 2;							5: k := 6;							6: k := 3;						END;						Str2 := '  ';						Str2[1] := ESC;						Str2[2] := chr($40 + k);						AddDataPaq(@Str2);					END;					{ ***** Taille ***** }					k := BAND(BSR(theZones[i].Color, 6),3);					IF k <> 0 THEN { autre que taille normale }					BEGIN						Str2 := '  ';						Str2[1] := ESC;						Str2[2] := chr($4C + k);						AddDataPaq(@Str2);					END;					{ ***** Inversion ***** }					k := BAND(BSR(theZones[i].Color, 5), 1);					IF k <> 0 THEN { inversion }					BEGIN						Str2 := '  ';						Str2[1] := ESC;						Str2[2] := chr($5D);						AddDataPaq(@Str2);					END;					{ ***** Clignotement ***** }					k := BAND(BSR(theZones[i].Color, 4), 1);					IF k <> 0 THEN { Clignotement }					BEGIN						Str2 := '  ';						Str2[1] := ESC;						Str2[2] := chr($48);						AddDataPaq(@Str2);					END;					{ ========== valeur par défaut ========= }					Str2 := Str1;					IF NOT EchoFlag THEN FOR k := 1 TO length(Str2) DO Str2[k] := '*';					StartDataPaq;					Opt(Str2);					AddBuffer(@Str2);					{ ========== pointillés =========== }					count := TheZones[i].len - length(Str1);					WHILE count > 0 DO					BEGIN						IF EchoFlag THEN C := '.' ELSE C := 'X';						PAddBuffer(Ptr(Ord4(@C) + 1), 1);						IF count > 3 THEN						BEGIN							C := REP;							PAddBuffer(Ptr(Ord4(@C) + 1), 1);							IF count < 64 THEN								BEGIN									C := chr($40 + count - 1);									count := 0;								END							ELSE								BEGIN									C := chr($40 + 63);									count := count - 64;								END;							PAddBuffer(Ptr(Ord4(@C) + 1), 1);						END						ELSE						BEGIN							FOR k := 2 TO count DO PAddBuffer(Ptr(Ord4(@C) + 1), 1);							count := 0;						END;					END;					EndDataPaq;					FlushBuffer;				END;		{ selection de la premiere zone }		SelectZone(NumZone, 0);		{ entree de la zone }		termine := False;		REPEAT			WITH CurTCB^.TheZones[NumZone] DO				CurTCB^.Error := Zinput(Str1, Posx, PosY, len, BAND(Color,255), CurTCB^.MaxTime, '.', False);			IF NOT RunFlag THEN EXIT(WaitBis);			CurTCB^.StarFlag := Str1[length(Str1)] = '*';			CASE CurTCB^.Error OF				ErrTime, CEnvoi, CGuide, CSommaire, CConnexion, CRepetition,				CCorrection:					termine := True;				CAnnulation:					IF BitAnd(CurTCB^.TheZones[NumZone].Color, 2048) <> 0 THEN						BEGIN							termine := True;						END					ELSE IF (CurTCB^.NbZones = 1) AND (CurTCB^.TheZones[NumZone].len = 0) THEN						termine := True					ELSE IF CurTCB^.StarFlag THEN						BEGIN							ResetVars;							NumZone := 1;							GOTO 0;						END;				CSuite:					IF BitAnd(CurTCB^.TheZones[NumZone].Color, 4096) <> 0 THEN						BEGIN							termine := True;						END					ELSE IF (CurTCB^.NbZones = 1) OR CurTCB^.StarFlag THEN						termine := True					ELSE						BEGIN							IF NumZone = CurTCB^.NbZones THEN								NextZone := 1							ELSE								NextZone := NumZone + 1;														{ on saute les zones le longueur nulle }							WHILE (CurTCB^.TheZones[NextZone].len = 0) DO							BEGIN								NextZone:= NextZone+1;								IF NextZone>CurTCB^.NbZones THEN NextZone := 1;							END;														SelectZone(NextZone, NumZone);							NumZone := NextZone;						END;										CRetour:					IF BitAnd(CurTCB^.TheZones[NumZone].Color, 8192) <> 0 THEN						BEGIN							termine := True;						END					ELSE IF (CurTCB^.NbZones = 1) OR CurTCB^.StarFlag THEN						termine := True					ELSE						BEGIN							IF NumZone = 1 THEN								NextZone := CurTCB^.NbZones							ELSE								NextZone := NumZone - 1;							{ on saute les zones le longueur nulle }							WHILE CurTCB^.TheZones[NextZone].len = 0 DO							BEGIN								NextZone:= NextZone-1;								IF NextZone<1 THEN NextZone := CurTCB^.NbZones;							END;														SelectZone(NextZone, NumZone);							NumZone := NextZone;						END;			END;		UNTIL termine;		SelectZone(0, NumZone);		CurTCB^. ZoneNumber := NumZone;		Str1 := ' ';		Str1[1] := DC4;		AddDataPaq(@Str1);		IF NOT EmulFlag THEN		BEGIN			Str1 := '';			PaqPrep(Str1, 'z');			AddBuffer(@Str1);		END;		FlushBuffer;	END;PROCEDURE Wait(e:TParamPtr);VAR	NumZone:LONGINT;BEGIN	NextIntToken(e, SizeOf(Tdummy) + 2);	NumExprXCute(e, @NumZone);	WaitBis(NumZone);END;PROCEDURE WaitConnect(e: TParamPtr);VAR	Str1, Str2: str255;	DateN: LongInt;	Err: OSerr;	WTime: LongInt;	REP: Boolean;BEGIN	WTime := 0;	IF e^.nbparam > 0 THEN		BEGIN			NextIntToken(e, SizeOf(Tdummy) + 2);			NumExprXCute(e, @WTime);			IF WTime > 0 THEN				WTime := WTime * 60 + TickCount			ELSE				WTime := 0;		END;		IF NOT EmulFlag THEN	BEGIN		Str2 := '';		PaqPrep(Str2, '?');		REPEAT			AsRead(Str2, Str1, 120, False);			CheckButton;		UNTIL ((length(Str1) > 0) AND ((Str1[1] = 'C') OR (Str1[1] = 'c'))) OR			  (NOT RunFlag) OR (BreakCount > 12) OR ((TickCount > WTime) AND			  (WTime > 0));	END	ELSE	  REPEAT		  TestConnect(REP);		  CheckButton;	  UNTIL (REP) OR (NOT RunFlag) OR ((TickCount > WTime) AND (WTime > 0));	IF RunFlag AND (NOT ((TickCount > WTime) AND (WTime > 0))) THEN	BEGIN		Err := ReadDateTime(DateN);		IUDateString(DateN, ShortDate, Str1);		IUTimeString(DateN, True, Str2);		WWLnStr(ParamMessage(53,Str1,Str2,'',''));		GetDateTime(CurTCB^. StartTime);		ResetBuffer;	END;END;PROCEDURE FPrint(e: TParamPtr);VAR	Num1, NumFile: LongInt;	nb, i: Integer;	Str1: str255;	Err: OSerr;	pb: Paramblockrec;	LastTk: Integer;	OffFile: Integer;	FichCalc: Integer;BEGIN	nb := e^.nbparam;	NextIntToken(e, SizeOf(Tdummy) + 2);	NumExprXCute(e, @NumFile);	IF (NumFile < 1) OR (NumFile > MaxFile) THEN		BEGIN			CurTCB^.Error := ErrBadNum;			EXIT(FPrint);		END;	IF CurTCB^.TheFiles[NumFile].FileRef = 0 THEN		BEGIN			CurTCB^.Error := ErrNotOpen;			EXIT(FPrint);		END;	IF CurTCB^.TheFiles[NumFile].FileRef < 0 THEN		OffFile := - 1	ELSE		OffFile := 0;	NextIntToken(e, e^.LParam);	LastTk := 0;	FOR i := 2 TO nb DO		BEGIN			LastTk := e^.tk;			{ on va a la peche des parametres }			CASE mots^^[e^.tk].tfunc OF				fvarstr, fcststr, fcstr, fStr, fistrvar: StrExprXcute(e, @Str1);				fcnum, fnum, fcstnum, fvarnum, finumvar:					BEGIN						NumExprXCute(e, @Num1);						NumToString(Num1, Str1);					END;				OTHERWISE					IF LastTk = TkV THEN						Str1 := ' '					ELSE						Str1 := '';			END;			IF length(Str1) > 0 THEN				BEGIN					IF CurTCB^.TheFiles[NumFile].BaseFlag THEN						BEGIN							{ on ecrit entre FichPtr et jusqu'à FichSize-1 }							FichCalc := FichSize - FichPtr;							IF FichCalc > length(Str1) THEN FichCalc := length(Str1);							IF FichEnd < FichPtr + FichCalc THEN								SetBaseEnd(FichPtr + FichCalc);							BlockMoveData(Ptr(Ord4(@Str1) + 1), Ptr(Ord4(MyFicheHdl^^.ContenuHdl																											 ^) + FichPtr),												FichCalc);							FichPtr := FichPtr + FichCalc;						END					ELSE						BEGIN							WITH pb DO								BEGIN									ioCompletion := NIL;									ioRefNum := CurTCB^.TheFiles[NumFile].FileRef + OffFile;									ioBuffer := Ptr(Ord4(@Str1) + 1);									ioReqCount := length(Str1);									ioPosMode := fsFromStart;									ioPosOffset := CurTCB^.TheFiles[NumFile].FilePos;								END;							Err := PbWrite(@pb, False);							CurTCB^.TheFiles[NumFile].FilePos := pb.ioPosOffset;							CurTCB^.Error := pb.ioResult;						END;				END;			NextIntToken(e, e^.LParam);		END;	IF (LastTk <> TkV) AND (LastTk <> TkPV) THEN		BEGIN			Str1 := ' ';			Str1[1] := chr($0D);			IF CurTCB^.TheFiles[NumFile].BaseFlag THEN				BEGIN					{ on ecrit entre FichPtr et jusqu'à FichSize-1 }					FichCalc := FichSize - FichPtr;					IF FichCalc > length(Str1) THEN FichCalc := length(Str1);					IF FichEnd < FichPtr + FichCalc THEN SetBaseEnd(FichPtr + FichCalc);					BlockMoveData(Ptr(Ord4(@Str1) + 1), Ptr(Ord4(MyFicheHdl^^.ContenuHdl^) +																							FichPtr), FichCalc);					FichPtr := FichPtr + FichCalc;				END			ELSE				BEGIN					WITH pb DO						BEGIN							ioCompletion := NIL;							ioRefNum := CurTCB^.TheFiles[NumFile].FileRef + OffFile;							ioBuffer := Ptr(Ord4(@Str1) + 1);							ioReqCount := length(Str1);							ioPosMode := fsFromStart;							ioPosOffset := CurTCB^.TheFiles[NumFile].FilePos;						END;					Err := PbWrite(@pb, False);					CurTCB^.TheFiles[NumFile].FilePos := pb.ioPosOffset;					CurTCB^.Error := pb.ioResult;				END;		END;END;PROCEDURE FPos(e: TParamPtr;							 AdNum: LongintPtr);	VAR		NumFile: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				AdNum^ := 0;				EXIT(FPos);			END;		IF CurTCB^.TheFiles[NumFile].FileRef = 0 THEN			BEGIN				CurTCB^.Error := ErrNotOpen;				AdNum^ := 0;				EXIT(FPos);			END;		IF CurTCB^.TheFiles[NumFile].FileRef < 0 THEN			BEGIN				CurTCB^.Error := 0;				AdNum^ := 0;				EXIT(FPos);			END;		IF CurTCB^.TheFiles[NumFile].BaseFlag THEN			BEGIN				AdNum^ := FichPtr;			END		ELSE			BEGIN				AdNum^ := CurTCB^.TheFiles[NumFile].FilePos;			END;	END;PROCEDURE SGetEof(e: TParamPtr;									AdNum: LongintPtr);	VAR		NumFile: LongInt;		pb: Paramblockrec;		Err: OSerr;		count: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				AdNum^ := 0;				EXIT(SGetEof);			END;		IF (CurTCB^.TheFiles[NumFile].FileRef = 0) THEN			BEGIN				CurTCB^.Error := ErrNotOpen;				AdNum^ := 0;				EXIT(SGetEof);			END;		IF CurTCB^.TheFiles[NumFile].FileRef < 0 THEN			BEGIN				Err := SerGetBuf(CurTCB^.TheFiles[NumFile].FileRef, count);				CurTCB^.Error := 0;				AdNum^ := count;				EXIT(SGetEof);			END;		IF CurTCB^.TheFiles[NumFile].BaseFlag THEN			BEGIN				AdNum^ := FichEnd;				CurTCB^.Error := 0;			END		ELSE			BEGIN				WITH pb DO					BEGIN						ioCompletion := NIL;						ioRefNum := CurTCB^.TheFiles[NumFile].FileRef;					END;				Err := PbGetEof(@pb, False);				CurTCB^.Error := pb.ioResult;				AdNum^ := Ord4(pb.ioMisc);			END;	END;PROCEDURE SSetEof(e: TParamPtr);	VAR		NumFile, Num1: LongInt;		pb: Paramblockrec;		Err: OSerr;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(SSetEof);			END;		IF (CurTCB^.TheFiles[NumFile].FileRef = 0) THEN			BEGIN				CurTCB^.Error := ErrNotOpen;				EXIT(SSetEof);			END;		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num1);		IF CurTCB^.TheFiles[NumFile].BaseFlag THEN			BEGIN				IF Num1 < FichSize THEN SetBaseEnd(Num1);			END		ELSE			BEGIN				WITH pb DO					BEGIN						ioCompletion := NIL;						ioRefNum := CurTCB^.TheFiles[NumFile].FileRef;						ioMisc := Ptr(Num1);					END;				Err := PbSetEof(@pb, False);				CurTCB^.Error := pb.ioResult;				IF CurTCB^.TheFiles[NumFile].FilePos > Num1 THEN	{ 2/9/96 }					CurTCB^.TheFiles[NumFile].FilePos := Num1;			END;	END;PROCEDURE SWrite(e: TParamPtr);	VAR		NumFile, Num1: LongInt;		nb, i: Integer;		Str1: str255;		Err: OSerr;		pb: Paramblockrec;		OffFile: Integer;		FichCalc: Integer;	BEGIN		nb := e^.nbparam;		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @NumFile);		IF (NumFile < 1) OR (NumFile > MaxFile) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(SWrite);			END;		IF CurTCB^.TheFiles[NumFile].FileRef = 0 THEN			BEGIN				CurTCB^.Error := ErrNotOpen;				EXIT(SWrite);			END;		IF CurTCB^.TheFiles[NumFile].FileRef < 0 THEN			OffFile := - 1		ELSE			OffFile := 0;		NextIntToken(e, e^.LParam);		FOR i := 2 TO nb DO			BEGIN				{ on va a la peche des parametres }				CASE mots^^[e^.tk].tfunc OF					fvarstr, fcststr, fcstr, fStr, fistrvar: StrExprXcute(e, @Str1);					fcnum, fnum, fcstnum, fvarnum, finumvar:						BEGIN							NumExprXCute(e, @Num1);							NumToString(Num1, Str1);						END;				END;				NextIntToken(e, e^.LParam);				IF CurTCB^.TheFiles[NumFile].BaseFlag THEN					BEGIN						{ on ecrit entre FichPtr et jusqu'à FichSize-1 }						FichCalc := FichSize - FichPtr;						IF FichCalc > length(Str1) THEN FichCalc := length(Str1);						IF FichEnd < FichPtr + FichCalc THEN SetBaseEnd(FichPtr + FichCalc);						BlockMoveData(@Str1[1], Ptr(Ord4(MyFicheHdl^^.ContenuHdl^) + FichPtr), FichCalc);						FichPtr := FichPtr + FichCalc;												{ ajout du TAB ou CR }						IF i<nb THEN							Str1 := chr(9)						ELSE							Str1 := chr(13);						FichCalc := FichSize - FichPtr;						IF FichCalc > 1 THEN FichCalc := 1;						IF FichEnd < FichPtr + FichCalc THEN SetBaseEnd(FichPtr + FichCalc);						BlockMoveData(@Str1[1], Ptr(Ord4(MyFicheHdl^^.ContenuHdl^) + FichPtr), FichCalc);						FichPtr := FichPtr + FichCalc;					END				ELSE					BEGIN						WITH pb DO							BEGIN								ioCompletion := NIL;								ioRefNum := CurTCB^.TheFiles[NumFile].FileRef + OffFile;								ioBuffer := @Str1[1];								ioReqCount := length(Str1);								ioPosMode := fsFromStart;								ioPosOffset := CurTCB^.TheFiles[NumFile].FilePos;							END;						Err := PbWrite(@pb, False);						CurTCB^.TheFiles[NumFile].FilePos := pb.ioPosOffset;												{ écriture du TAB ou du CR }						IF i<nb THEN							Str1 := chr(9)						ELSE							Str1 := chr(13);						WITH pb DO							BEGIN								ioCompletion := NIL;								ioRefNum := CurTCB^.TheFiles[NumFile].FileRef + OffFile;								ioBuffer := @Str1[1];								ioReqCount := length(Str1);								ioPosMode := fsFromStart;								ioPosOffset := CurTCB^.TheFiles[NumFile].FilePos;							END;						Err := PbWrite(@pb, False);						CurTCB^.TheFiles[NumFile].FilePos := pb.ioPosOffset;						CurTCB^.Error := pb.ioResult;					END;			END;	END;PROCEDURE ZoneNumber(e: TParamPtr; AdNum: LongintPtr);	BEGIN		AdNum^ := CurTCB^. ZoneNumber;	END;PROCEDURE SZone(e: TParamPtr);	VAR		Num1: LongInt;	BEGIN { ajout d'une zone }		 { changement du 10/09/86:				no de var du fichier remplace par no de var globale:				TheCVars^^[e^.Indir].indir au lieu de e^.indir				}		NextIntToken(e, SizeOf(Tdummy) + 2);		CurTCB^.NbZones := CurTCB^.NbZones + 1;		{ 1er param : ligne }		NumExprXCute(e, @Num1);		WITH CurTCB^ DO			BEGIN				TheZones[NbZones].Posx := Num1;			END;		{ 2e param: colonne }		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num1);		WITH CurTCB^ DO			BEGIN				TheZones[NbZones].PosY := Num1;			END;		{ 3e param: longueur }		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num1);		IF Num1 > 240 THEN Num1 := 240;		IF Num1 < 0 THEN Num1 := 0;		WITH CurTCB^ DO			BEGIN				TheZones[NbZones].len := Num1;			END;		{ 4e param: variable }		NextIntToken(e, e^.LParam);		WITH CurTCB^ DO			BEGIN				IF (e^.tk = tkISTRVar) OR (e^.tk = tkINUMVAR) THEN					BEGIN						NextIntToken(e, SizeOf(Tdummy) + 2);						TheZones[NbZones].Numvar := TheCVars^^[e^.Indir].Indir;						TheZones[NbZones].tkVar := e^.tk;						NextIntToken(e, e^.LParam);						NumExprXCute(e, @Num1);						WITH TheZones[NbZones] DO							IF (Num1 < 0) OR (Num1 >= TheVars^^.vars[Numvar].DimVal) THEN								BEGIN									ErrFlag := True;									CurTCB^.Error := ErrIndice;									EXIT(SZone);								END;						TheZones[NbZones].IndVar := Num1;					END				ELSE					BEGIN						TheZones[NbZones].IndVar := 0;						TheZones[NbZones].Numvar := TheCVars^^[e^.Indir].Indir;						TheZones[NbZones].tkVar := e^.tk;					END;			END;		{ 5e param: couleur }		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num1);		WITH CurTCB^ DO			BEGIN				TheZones[NbZones].Color := Num1;			END;	END;FUNCTION Upc2(Str1: str255): str255;	BEGIN		UpperString(Str1, FALSE);		Upc2 := Str1;	END;FUNCTION DSpcR2(Str1: str255): str255;	BEGIN		WHILE (length(Str1) > 0) AND (Str1[length(Str1)] = ' ') DO			Str1[0] := chr(ord(Str1[0]) - 1);		DSpcR2 := Str1;	END;FUNCTION DSpcL2(Str1: str255): str255;VAR	i: INTEGER;	BEGIN		i := 0;		WHILE (Str1[1] = ' ') & (i<=length(Str1)) DO i:=i+1;		IF i<>0 THEN Delete(Str1, 1, i);		DSpcL2 := Str1;	END;PROCEDURE Similarity(e: TParamPtr; AdNum: LongintPtr);	VAR		Str1, Str2: str255;	BEGIN		{ variable num ou str }		NextIntToken(e, SizeOf(Tdummy) + 2);		StrExprXcute(e, @Str1);		NextIntToken(e, e^.LParam);		StrExprXcute(e, @Str2);		Str1 := DSpcR2(DSpcL2(Upc2(Str1)));		Str2 := DSpcR2(DSpcL2(Upc2(Str2)));		AdNum^ := LongInt(Str1 = Str2);	END;PROCEDURE Phonem(e: TParamPtr; AdStr: pstr255);	BEGIN		AdStr^ := '';	END;PROCEDURE SOpenRF(e: TParamPtr);	VAR		Num1: LongInt;		Str1: str255;		Err: OSerr;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		NextIntToken(e, e^.LParam);		StrExprXcute(e, @Str1);		IF (Num1 < 1) OR (Num1 > MaxFile) OR (BreakCount > 10) THEN			BEGIN				CurTCB^.Error := ErrBadNum;				EXIT(SOpenRF);			END;		IF (CurTCB^.TheFiles[Num1].FileRef <> 0) THEN			BEGIN				CurTCB^.Error := ErrFileOpen;				EXIT(SOpenRF);			END;		Err := OpenRF(Str1, 0, CurTCB^.TheFiles[Num1].FileRef);		WITH CurTCB^.TheFiles[Num1] DO			BEGIN				FilePos := 0;				FileRLen := 1;				BaseFlag := False;			END;		IF (Err <> 0) AND (Err<>-49) THEN CurTCB^.TheFiles[Num1].FileRef := 0;		CurTCB^.Error := Err;	END;PROCEDURE RunFlags(e: TParamPtr; ps:PStr255);{ Rend le mode de fonctionnement du serveur:	I = interpreté	R/L = Modem  E = Emulateur	T = Télétel}BEGIN	IF EmulFlag THEN		ps^[2] := 'E'	{ Emulateur }	ELSE	BEGIN		ps^:= SStatus2;	{ Modem ou Télétel }		ps^[2]:=ps^[4];	END;	ps^[1] := 'I';		{ mode interpreté }	ps^[0] := chr(2);END;PROCEDURE BaseMaxSize(e: TParamPtr; pn:LongintPtr);{ rend la taille de la zone de comm. de la base de donnée }BEGIN	pn^:=4096;END;{==============================================================================}{ 								 C O N T R O L E										 }{==============================================================================}PROCEDURE SIF(e: TParamPtr);	VAR		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		IF Num1 = 0 THEN			BEGIN							 { on essaye d'aller derriere le else								 sinon on va derriere le endif }				NextIntToken(e, e^.LParam);				IF e^.Num = 0 THEN					BEGIN						NextIntToken(e, e^.LParam);						Pc := e^.Num + SizeOf(Tdummy) + 2;					END				ELSE					Pc := e^.Num + SizeOf(Tdummy) + 2 + SizeOf(Tdummy) + 4;				PcFlag := True;			END;	END;PROCEDURE SWhile(e: TParamPtr);	VAR		Num1: LongInt;	BEGIN		ContFlag := False;		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		IF Num1 = 0 THEN			BEGIN				{ on va au endwhile }				NextIntToken(e, e^.LParam);				Pc := e^.Num + SizeOf(Tdummy) + 2 + SizeOf(Tdummy) + 4;				PcFlag := True;			END;	END;PROCEDURE SGoto(e: TParamPtr);	VAR		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		Pc := TheCVars^^[e^.Indir].Indir;		PcFlag := True;	END;PROCEDURE SOn(e: TParamPtr);	VAR		Num1: LongInt;		ex: TParamPtr;		nb: Integer;	BEGIN		ex := TParamPtr(Ord4(e) + e^.LParam);		nb := e^.nbparam;		NextIntToken(e, SizeOf(Tdummy) + 2);		NumExprXCute(e, @Num1);		IF (Num1 >= 1) AND (Num1 <= nb - 2) THEN			BEGIN { bornes valides }				NextIntToken(e, e^.LParam);				IF e^.tk = tkgosub THEN Empile(LongInt(Ord4(ex) - Ord4(TheCode^)));				WHILE Num1 > 0 DO					BEGIN						NextIntToken(e, e^.LParam);						Num1 := Num1 - 1;					END;				Pc := TheCVars^^[e^.Indir].Indir;				PcFlag := True;			END;	END;PROCEDURE SGosub(e: TParamPtr);	VAR		Num1: LongInt;		ex: TParamPtr;	BEGIN		ex := TParamPtr(Ord4(e) + e^.LParam);		NextIntToken(e, SizeOf(Tdummy) + 2);		Empile(LongInt(Ord4(ex) - Ord4(TheCode^)));		Pc := TheCVars^^[e^.Indir].Indir;		PcFlag := True;	END;PROCEDURE Sfor(e: TParamPtr);	VAR		Num1, Num2, NumIndice: LongInt;		tkVar: Integer;		ex: TParamPtr;		ValVar: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		ex := e;		tkVar := TParamPtr(Ord4(e) + SizeOf(Tdummy) + 2)^.tk;		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num1);		NextIntToken(e, e^.LParam);		NumExprXCute(e, @Num2);		IF NOT ContFlag THEN			BEGIN { initialiser la variable }				AffXCute(ex);				{ distinguer Var num de var num indicee }				CASE mots^^[tkVar].tfunc OF					fvarnum:						BEGIN							ex := TParamPtr(Ord4(ex) + SizeOf(Tdummy) + 2);							tkVar := TheCVars^^[ex^.Indir].Indir;							WITH TheVars^^.vars[tkVar] DO								BEGIN									ValVar := Value;								END;						END;					finumvar:						BEGIN							ex := TParamPtr(Ord4(ex) + SizeOf(Tdummy) + 2);							ex := TParamPtr(Ord4(ex) + SizeOf(Tdummy) + 2);							tkVar := TheCVars^^[ex^.Indir].Indir;							ex := TParamPtr(Ord4(ex) + ex^.LParam);							NumExprXCute(ex, @NumIndice);							WITH TheVars^^.vars[tkVar] DO								BEGIN									ValVar := LongintPtr(Ord4(TVptr^) + NumIndice * 4)^;								END;						END;				END;			END		ELSE			BEGIN { incrementer la variable }				ContFlag := False;				{ distinguer Var num de var num indicee }				CASE mots^^[tkVar].tfunc OF					fvarnum:						BEGIN							ex := TParamPtr(Ord4(ex) + SizeOf(Tdummy) + 2);							tkVar := TheCVars^^[ex^.Indir].Indir;							WITH TheVars^^.vars[tkVar] DO								BEGIN									Value := Value + Num2;									ValVar := Value;								END;						END;					finumvar:						BEGIN							ex := TParamPtr(Ord4(ex) + SizeOf(Tdummy) + 2);							ex := TParamPtr(Ord4(ex) + SizeOf(Tdummy) + 2);							tkVar := TheCVars^^[ex^.Indir].Indir;							ex := TParamPtr(Ord4(ex) + ex^.LParam);							NumExprXCute(ex, @NumIndice);							WITH TheVars^^.vars[tkVar] DO								BEGIN									SetInd(LongintPtr(Ord4(TVptr^) + NumIndice * 4),												 LongintPtr(Ord4(TVptr^) + NumIndice * 4)^ + Num2);									ValVar := LongintPtr(Ord4(TVptr^) + NumIndice * 4)^;								END;						END;				END;			END;		{ tester les bornes }		IF Num2 < 0 THEN			BEGIN				IF ValVar < Num1 THEN					BEGIN { on sort de la boucle }						NextIntToken(e, e^.LParam);						Pc := e^.Num + SizeOf(Tdummy) + 2 + SizeOf(Tdummy) + 4;						PcFlag := True;					END			END		ELSE			BEGIN				IF ValVar > Num1 THEN					BEGIN { on sort de la boucle }						NextIntToken(e, e^.LParam);						Pc := e^.Num + SizeOf(Tdummy) + 2 + SizeOf(Tdummy) + 4;						PcFlag := True;					END			END	END;PROCEDURE Selse(e: TParamPtr);	VAR		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		Pc := e^.Num;		PcFlag := True;	END;PROCEDURE Sendif(e: TParamPtr);	BEGIN	END;PROCEDURE Sbreak(e: TParamPtr);	VAR		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		Pc := e^.Num + SizeOf(Tdummy) + 2 + SizeOf(Tdummy) + 4;		PcFlag := True;	END;PROCEDURE Scontinue(e: TParamPtr);	VAR		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		Pc := e^.Num;		PcFlag := True;		ContFlag := True;	END;PROCEDURE Swend(e: TParamPtr);	VAR		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		Pc := e^.Num;		PcFlag := True;	END;PROCEDURE Snext(e: TParamPtr);	VAR		Num1: LongInt;	BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		Pc := e^.Num;		PcFlag := True;		ContFlag := True;	END;PROCEDURE SRepeat(e:TParamPtr);BEGINEND;PROCEDURE SUntil(e:TParamPtr);VAR	Num1: LongInt;BEGIN	ContFlag := False;	NextIntToken(e, SizeOf(Tdummy) + 2);	NumExprXCute(e, @Num1);	IF Num1 = 0 THEN		BEGIN			{ on va juste après le REPEAT }			NextIntToken(e, e^.LParam);			Pc := e^.Num + SizeOf(Tdummy) + 2;			PcFlag := True;		END;END;PROCEDURE Sreturn(e: TParamPtr);	VAR		Num1: LongInt;	BEGIN		Depile(Pc);		PcFlag := True;	END;{ ••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••• }PROCEDURE DecExec(e:TParamPtr);VAR	str:Str255;		i: INTEGER;		BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		StrExprXcute (e, @str);		FOR i := 1 TO NbExecCond DO			IF ExecCondTable[i]^^=str THEN EXIT(DecExec);		NbExecCond := NbExecCond + 1;		ExecCondTable[NbExecCond]:=NewString(str);END;PROCEDURE IFEXEC(e:TParamPtr);VAR	str:Str255;		i: INTEGER;		BEGIN		NextIntToken(e, SizeOf(Tdummy) + 2);		StrExprXcute (e, @str);		FOR i := 1 TO NbExecCond DO			IF ExecCondTable[i]^^=str THEN EXIT(IFEXEC);		ExecFlag := FALSE;END;PROCEDURE EndifExec(e:TParamPtr);BEGIN	ExecFlag := TRUE;END;{ ••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••• }{$S INTERPRETEUR}PROCEDURE ListeXCute(e: TParamPtr);VAR s:Str255;	XvarTab: HVarRes;	XcstTab: HCstRes;	BEGIN { executer la liste }		{ la trace est ici }		{ ... }		IF e^.LParam = 0 THEN EXIT(ListeXCute); { fin physique du code }		WHILE True DO			BEGIN				CheckButton;						NextIntToken(e, SizeOf(Tdummy) + 2); { indentation }				NextIntToken(e, e^.LParam);				IF e^.LParam = 0 THEN EXIT(ListeXCute);				WHILE (e^.tk <> tkliste) DO					BEGIN						InstXCute(e);						IF ErrFlag | (RunFlag=FALSE) THEN						BEGIN							IF CurTCB^.Error<>NoErr THEN							BEGIN								{ trace de l'instruction en cause… }								{ modif. des handles de Expr (pour le Detokeniseur) }								XVarTab := varTab; VarTab := TheCVars;								XCstTab := CstTab; CstTab := TheCsts;													RoutDetok(e,s);								VarTab := XVarTab;								CstTab := XCstTab;								WWLnStr(concat('==> ',s,' (',curcodename,') <=='));							END;							EXIT(ListeXCute);						END;						IF PcFlag THEN							BEGIN								e := TParamPtr(Ord4(TheCode^) + Pc);								PcFlag := False;							END						ELSE							NextIntToken(e, e^.LParam);						IF e^.LParam = 0 THEN EXIT(ListeXCute);					END;			END;	END;{==============================================================================}PROCEDURE AffXCute(e: TParamPtr);	VAR		AdStr: str255;		AdNum, NumIndice: LongInt;		Numvar: Integer;		ex: TParamPtr;	BEGIN		{ variable num ou str }		NextIntToken(e, SizeOf(Tdummy) + 2);		ex := e;		CASE mots^^[e^.tk].tfunc OF			fvarnum:				BEGIN					Numvar := TheCVars^^[e^.Indir].Indir;					NextIntToken(e, e^.LParam);					NumExprXCute(e, @AdNum);					TheVars^^.vars[Numvar].Value := AdNum;				END;			finumvar:				BEGIN					ex := TParamPtr(Ord4(ex) + SizeOf(Tdummy) + 2);					Numvar := TheCVars^^[ex^.Indir].Indir;					ex := TParamPtr(Ord4(ex) + ex^.LParam);					NumExprXCute(ex, @NumIndice);					IF (NumIndice < 0) OR						 (NumIndice >= TheVars^^.vars[Numvar].DimVal) THEN						BEGIN							ErrFlag := True;							CurTCB^.Error := ErrIndice;							EXIT(AffXCute);						END;					NextIntToken(e, e^.LParam);					NumExprXCute(e, @AdNum);					{break;}					SetInd(LongintPtr(Ord4(TheVars^^.vars[Numvar].TVptr^) + NumIndice * 4),								 AdNum);				END;			fistrvar:				BEGIN					ex := TParamPtr(Ord4(ex) + SizeOf(Tdummy) + 2);					Numvar := TheCVars^^[ex^.Indir].Indir;					ex := TParamPtr(Ord4(ex) + ex^.LParam);					NumExprXCute(ex, @NumIndice);					IF (NumIndice < 0) OR						 (NumIndice >= TheVars^^.vars[Numvar].DimVal) THEN						BEGIN							ErrFlag := True;							CurTCB^.Error := ErrIndice;							EXIT(AffXCute);						END;					NextIntToken(e, e^.LParam);					StrExprXcute(e, @AdStr);					TheVars^^.vars[Numvar].TSPtr^^[NumIndice]:=AdStr;				END;			fvarstr:				BEGIN					Numvar := TheCVars^^[e^.Indir].Indir;					NextIntToken(e, e^.LParam);					StrExprXcute(e, @AdStr);					SetHSize(Handle(TheVars^^.vars[Numvar].SPtr), length(AdStr) + 1);					BlockMoveData(@AdStr, Ptr(Ord4(TheVars^^.vars[Numvar].SPtr^)),										length(AdStr) + 1);					{TheVars^^.Vars[NumVar].Sptr^^:=AdStr;}				END;			OTHERWISE				BEGIN					WWriteStr('ERR type variable: ');					WWlnNum(mots^^[e^.tk].tfunc, 0);				END;		END;	END;PROCEDURE NumExprXCute(e: TParamPtr; pn: LongintPtr);	VAR		Num1, Numvar: LongInt;	BEGIN		IF e^.tk<0 THEN	{ 6/3/95 }		BEGIN			pn^:=0;			ErrFlag := True;			CurTCB^.Error := ErrNoExtToken;			EXIT(NumExprXCute);		END;				CASE mots^^[e^.tk].tfunc OF			fvarnum: { on va chercher la valeur de la variable }				BEGIN					pn^ := TheVars^^.vars[TheCVars^^[e^.Indir].Indir].Value;				END;			finumvar: { on va chercher la valeur de la variable indicee }				BEGIN					NextIntToken(e, SizeOf(Tdummy) + 2);					Numvar := TheCVars^^[e^.Indir].Indir;					NextIntToken(e, e^.LParam);					NumExprXCute(e, @Num1);					IF (Num1 < 0) OR (Num1 >= TheVars^^.vars[Numvar].DimVal) THEN						BEGIN							ErrFlag := True;							CurTCB^.Error := ErrIndice;							EXIT(NumExprXCute);						END;					pn^ := LongintPtr(Ord4(TheVars^^.vars[Numvar].TVptr^) + Num1 * 4)^;				END;			fcstnum: { on donne la valeur de la constante }				BEGIN					pn^ := e^.Num;				END;			fpar: { on donne la valeur dans les parentheses }				BEGIN					Par(e, pn);				END;			fcnum: { on fait le calcul en question }				BEGIN					CASE e^.tk OF						tkplus: NumPlus(e, pn);						tkmoins: Moins(e, pn);						tkNeg: Neg(e, pn);						tkdiv: SDiv(e, pn);						tkmod: SMod(e, pn);						tkmul: Mul(e, pn);						tkor: NumOr(e, pn);						tkand: NumAnd(e, pn);						tkNot: SNot(e, pn);						tkeq: SEq(e, pn);						tkdiff: Diff(e, pn);						tkinf: Inf(e, pn);						tksup: Sup(e, pn);						tkeqinf: EqInf(e, pn);						tkeqsup: EqSup(e, pn);					END;				END;			fnum: { on execute la fonction }				BEGIN					IF e^.tk > nbTokens THEN						Extern(e, pn, NIL)					ELSE						CASE e^.tk OF							TkAbs: SAbs(e, pn);							{ 		 TkArgNum:		Argnum(e,pn); 			}							TkAsc: SAsc(e, pn);							TkEof: SEof(e, pn);							TkError: SError(e, pn);							TkInstr: SInstr(e, pn);							TkFPos: FPos(e, pn);							TkGetEof: SGetEof(e, pn);							TkLen: SLen(e, pn);							TkLogTime: Logtime(e, pn);							TkTickCount: STickCount(e, pn);							TkVal: SVal(e, pn);							TkZoneNumber: ZoneNumber(e, pn);							TkConnected: Connected(e, pn);							TkTaskNumber: STaskNumber(e, pn);							TkGetPriority: SGetPriority(e, pn);							TkModNumber: SModNumber(e, pn);							TkStarFlag: SStarFlag(e, pn);							TkPend: SPend(e, pn);							TkKEY: SKey(e, pn);							TkSimilarity: Similarity(e, pn);							TkQueueSize: QueueSize(e, pn);							TkSecs: SSecs(e, pn);							TkDate2Secs: SDate2Secs(e, pn);							TkRnd: SRnd(e, pn);							TkBaseGetRef: BASEGETREF(e, pn);							TkBaseMaxSize: BaseMaxSize(e, pn);						END;				END;		END;	END;PROCEDURE StrExprXcute(e: TParamPtr; ps: pstr255);	VAR		Numvar, Num1: LongInt;	BEGIN		IF e^.tk<0 THEN	{ 6/3/95 }		BEGIN			ps^:='';			ErrFlag := True;			CurTCB^.Error := ErrNoExtToken;			EXIT(StrExprXcute);		END;				CASE mots^^[e^.tk].tfunc OF			fvarstr: { on va chercher la valeur de la variable }				BEGIN					ps^ := TheVars^^.vars[TheCVars^^[e^.Indir].Indir].SPtr^^;				END;			fistrvar: { on va chercher la valeur de la variable indicee }				BEGIN					NextIntToken(e, SizeOf(Tdummy) + 2);					Numvar := TheCVars^^[e^.Indir].Indir;					NextIntToken(e, e^.LParam);					NumExprXCute(e, @Num1);					IF (Num1 < 0) OR (Num1 >= TheVars^^.vars[Numvar].DimVal) THEN						BEGIN							ErrFlag := True;							CurTCB^.Error := ErrIndice;							EXIT(StrExprXcute);						END;					ps^ := TheVars^^.vars[Numvar].TSPtr^^[Num1];				END;			fcststr: { on donne la valeur de la constante }				BEGIN					ps^ := TheCsts^^[e^.Indir];				END;			fcstr: { on fait le calcul }				BEGIN					CASE e^.tk OF						tkplusStr: StrPlus(e, ps);					END;				END;			fStr: { on execute la fonction }				BEGIN					IF e^.tk > nbTokens THEN						Extern(e, NIL, ps)					ELSE						CASE e^.tk OF						{tkArg: 	Arg(e,ps);}							tkChr: SChr(e, ps);							tkDate: Date(e, ps);							tkDSpcR: DSpcR(e, ps);							TkDSpcL: DSpcL(e, ps);							TkFormat: Format(e, ps);							TkLeft: Left(e, ps);							TkLwc: Lwc(e, ps);							TkMid: Mid(e, ps);							TkRight: Right(e, ps);							tkSpc: Spc(e, ps);							TkStr: Str(e, ps);							TkString: SString(e, ps);							TkTime: drgTime(e, ps);							TkUpc: Upc(e, ps);							TkStatus: SStatus(e, ps);							TkGetId: GetMinID(e, ps);							TkCurPos: SCurPos(e, ps);							{TkUSep:	Usep(e,ps);}							TkMessDownLoad: MessDLoad(e, ps);							TkgetFILE: DirFile(e, ps);							TkDEQUEUE: SDequeue(e, ps);							TkGet: SGet(e, ps);							TkGetPaq: SGetPaq(e, ps);							TkSecs2date: SSecs2Date(e, ps);							TkGetVol: SGetVol(e, ps);							TkRunFlags: RunFlags(e, ps);						END;				END;		END;	END;{==============================================================================}PROCEDURE ProcXCute(e: TParamPtr);	BEGIN { Executer la procedure ... }		IF e^.tk > nbTokens THEN			Extern(e, NIL, NIL) {•••• Routine externe ••••}		ELSE			CASE e^.tk OF				TkBackColor: SBackColor(e);				TkCanEol: CanEol(e);				TkCanBlock: CanBlock(e);				TkClose: SClose(e);				TkCreate: SCreate(e);				TkCls: Cls(e);				TkCursor: SCursor(e);				TkDelay: SDelay(e);				TkDisconnect: Disconnect(e);				TkDraw: Draw(e);				TkEcho: SEcho(e);				TkFlash: Flash(e);				TkLower: SLower(e);				TkScroll: SScroll(e);				TkFont: Font(e);				TkForeColor: SForeColor(e);				TkGosubScreen: GosubScreen(e);				TkGotoScreen: GotoScreen(e);				TkInput: SInput(e);				TkInverse: Inverse(e);				TkKill: Kill(e);				TkLoadScreen: LoadScreen(e);				TkDrawScreen: DrawScreen(e);				TkFrontScreen: FrontScreen(e);				TkLocate: Locate(e);				TkMessage: Message(e);				TkOpen: MyOpen(e);				TkAppend: SAppend(e);				TkFPrint: FPrint(e);				TkPrint: Print(e);				TkRead: SRead(e);				TkRename: SRename(e);				TkResetZones: ResetZones(e);				TkRLen: RLen(e);				TkRSeek: RSeek(e);				TkSeek: SSeek(e);				TkSetEof: SSetEof(e);				TkLock: SLock(e);				TkUnlock: SUnLock(e);				TkDial: Dial(e);				TkRestart: SRestart(e);				TkControlSN: SNControl(e);				TkSetId: SetMinID(e);				TkSetPriority: SSetPriority(e);				TkYieldCpu: YieldCpu(e);				TkSwModem: SWModem(e);				TkTrace: STrace(e);				TkTron: STron(e);				TkTroff: STroff(e);				TkSize: SSize(e);				TkTimeOut: TimeOut(e);				TkUnderLine: SUnderLine(e);				TkWait: Wait(e);				TkWaitConnect: WaitConnect(e);				TkWrite: SWrite(e);				TkZone: SZone(e);				TkRequest: SRequest(e);				TkPost: SPost(e);				TkMessUpLoad: MessULoad(e);				TkBread: BRead(e);				TkBWrite: BWrite(e);				TkSysParm: SSysParm(e);				TkPRINTSCREEN: PrintScreen(e);				TkENQUEUE: SEnqueue(e);				TkEnd: SEnd(e);				TkSerConfig: SSerConfig(e, False);				TkGetFInfo: SGetFInfo(e);				TkSetFInfo: SSetFInfo(e);				TkNewFolder: SNewFolder(e);				TkOpenSer: SSerConfig(e, True);				TkFilter: SFilter(e);				TkBaseOpen: BaseOpen(e);				TkBaseClose: BaseClose(e);				TkBaseSeek: BaseSeek(e);				TkBaseUpdate: BaseUpdate(e);				TkBaseAdd: BaseAdd(e);				TkBaseRemove: BaseRemove(e);				TkBaseNext: BaseNext(e);				TkBasePred: BasePred(e);				TkBaseCreate: BaseCreate(e);				TkBaseInfo: BaseInfo(e);				TkBaseRInc: BASEINCR(e);				TkBaseread: BASEREAD(e);				TkBaseSetRef: BASESETREF(e);				TkTrPrint: TrPrint(e);				Tk_SE_INIT: Ise_INIT(e);				TkOPENRF: SOpenRF(e);				TkCALLSCREEN: CallScreen(e);				TkDecExec: DecExec(e);				TkIfExec: IFEXEC(e);				TkEndifExec: EndifExec(e);			END;	END;{==============================================================================}PROCEDURE ContXCute(e: TParamPtr);	VAR		temp: str255;		nb, i, len: Integer;	BEGIN { Executer la structure de controle }		CASE e^.tk OF			tkif: SIF(e);			tkwhile: SWhile(e);			tkgoto: SGoto(e);			tkgosub: SGosub(e);			tkon: SOn(e);			tkfor: Sfor(e);			tkelse: Selse(e);			tkendif: Sendif(e);			tkbreak: Sbreak(e);			tkcontinue: Scontinue(e);			tkWend: Swend(e);			tkNext: Snext(e);			tkreturn: Sreturn(e);			tkREPEAT: SRepeat(e);			tkUNTIL: SUntil(e);		END;	END;{==============================================================================}PROCEDURE TraceXCute(e: TParamPtr);	BEGIN { Tracer l'etiquette }		IF TraceFlag THEN WWlnStr(TheCVars^^[e^.Indir].NomVar);	END;{==============================================================================}PROCEDURE InstXCute(e: TParamPtr);	BEGIN		IF (e^.tk=TkEndifExec) | ExecFlag THEN		CASE mots^^[e^.tk].tfunc OF			fcnum: AffXCute(e);			fproc: ProcXCute(e);			fcont: ContXCute(e);			fuetiq: TraceXCute(e);		END;	END;