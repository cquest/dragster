;File DragsterRT1asm.a
;----------------------------------------------------------------
;
;       RunTime 1 de Dragster
;
;
;-----------------------------------------------------------------


                BLANKS          ON
                STRING          ASIS

                INCLUDE  'QuickEqu.a'
                INCLUDE  'SysEqu.a'
                INCLUDE  'ToolEqu.a'
                INCLUDE  'Traps.a'
				INCLUDE  'DragsterTCB.a'
				
RT	         	PROC	         EXPORT 


;=================================================================
; Construction JumpTable de la runtime pour cette Unit
;=================================================================


;=================================================================
; Macro de construction de la JumpTable
;=================================================================
                MACRO         
                JConst
				IMPORT	&Syslst[1]
                LEA     &Syslst[1],A1
                MOVE.L  A1,&Syslst[2]*6+2(A0)
                ENDM 

;=================================================================
                EXPORT  UnitInit
				IMPORT	PJumpTable

UnitInit
				LEA		PJumpTable,A0
				MOVE.L	(A0),A0				; A0 pointe sur la table de jump

                JConst Scheduler,0		        ;       0
                JConst RunTask,1		        ;       1
                JConst CarPrint,2		        ;       2
                JConst NumPrint,3		        ;       3
                JConst StrPrint,4		        ;       4
                JConst SeekScreen,8		        ;       8
                JConst SInput,9			        ;       9
                JConst TimeIt,12		        ;      12
                JConst SBackColor,24	        ;      20 + 4
                JConst Cls,27		        	;      20 + 7
                JConst SCursor,29		        ;      20 + 9
                JConst WaitDelay,31		        ;      20 +11
                JConst Disconnect,34	        ;      20 +14
                JConst Draw,35		        	;      20 +15
                JConst Echo,36		        	;      20 +16
                JConst Flash,39			        ;      20 +19
                JConst Font,40		        	;      20 +20
                JConst SForeColor,41	        ;      20 +21
                JConst Inverse,46		        ;      20 +26
                JConst Locate,50		        ;      20 +30
                JConst SSize,64			        ;      20 +44
                JConst SUnderLine,71	        ;      20 +51
                JConst Wait,74		        	;      20 +54
                JConst WaitConnect,75	        ;      20 +55
                JConst SZone,77			        ;      20 +57
                JConst Message,78		        ;      20 +58
                JConst CanEol,79		        ;      20 +59
                Jconst InputMode,99		    	;      20 +79
                JConst DrawScreen,105	        ;      20 +85
                JConst SPend,106		        ;      20 +86
                JConst SPost,107		        ;      20 +87
                JConst ControlSN,110	        ;      20 +90
                JConst Dial,111		        	;      20 +91
                JConst StartTask,112	        ;      20 +92
                JConst FrontScreen,113	        ;      20 +93
                JConst SGetMinId,114	        ;      20 +94
                JConst SSetMinId,115	        ;      20 +95
                JConst SStatus,116		        ;      20 +96
                JConst YieldCpu,120		        ;      20 +100
                JConst Request,121		        ;      20 +101
                JConst SWModem,122		        ;      20 +102
                JConst Connected,123	        ;      20 +103
                JConst SCurPos,124		        ;      20 +104
                JConst SScroll,125		        ;      20 +105
                JConst SLower,126		        ;      20 +106
                JConst CanBlock,127		        ;      20 +107
                JConst MessDLoad,130	        ;      20 +110
                JConst MessULoad,131	        ;      20 +111
                JConst SSysParm,134		        ;      20 +114
                JConst PrintScreen,141			;      20 +121
                JConst SEnqueue,142				;      20 +122
                JConst SDequeue,143				;      20 +123
				JConst Similarity,145			;	   20 +125
				JConst ResetQueue,146			;	   20 +126
				JConst QueueSize,147			;	   20 +127
				JConst SGet,148					;	   20 +128
				JConst SGetPaq,149				;	   20 +129
				JConst SSerConfig,150			;	   20 +130
				JConst Rnd,158					;	   20 +138
				JConst OpenSer,159				;	   20 +139
				JConst RunFlags,176				;	   20 +156

                RTS
				
				
				BLANKS 	OFF
*==============================================================================
* The following macro is used to 
* generate a branch based on an index value in a D-register.  The branch is
* through a table of relative addresses also generated by this macro.  The macro
* is called in one of two forms as follows:

*  {Form #1}	Case#	(Dreg,Default),case0,case1,...caseN
*  {Form #2}	Case#.<size>	(Dreg,IF),(cst0,case0),...,(cstN,caseN)
	
* The "Dreg" is a D-register with a value from 0 to N.  In Form #1, the 
* "Default" specifies a label for any omitted case labels not specified 
* explicitly. The "case0", "case1",..."caseN" are case labels identifying the 
* various cases to be processed.  A case label may be omitted, in which case the
* "Default" is used. The "Default" may also be omitted, but in that case all 
* case labels must be specified. If there are fewer case labels than there are 
* cases, but there are N possible values for the case index, the proper number 
* of trailing commas must be supplied to generate the defaults.

* In Form #2, the default is specified as the the word "IF".  In this form the
* macro generates as set of compares (CMPI's) and branches (BEQ) for each 
* specified case (there is no implicit default).  Each case is a constant/label
* pair.  The constant is compared (CMPI.W) and an branch is done (BEQ) to the 
* case if the Dreg equals the constant.  A size may be specified for all the 
* branches as a <size> attribute to the Case# call itself.  This must either be
* an "S" or "W" to generate BEQ.S's or BEQ.W's.  The default is for "S".

	MACRO
	Case#.&Size	&IdxDef
	PRINT	Push,NoMDir	Only list generated code
	LCLA	&i	Index to macro parameters
	LCLA	&n 	Total number of macro parameters
	LCLC	&Dreg,&Def	The Dreg and Default parameters
	LCLC	&sz	The <size> value
.*
&Dreg	SETC	&IdxDef[1]	Pick off 1st opnd of sublist
&Def	SETC	&IdxDef[2]	Pick off 2nd opnd of sublist
&n	SETA	&Nbr(&Syslist)	Done for efficiency ?
&i	SETA	2	Cases start at 2nd parameter
.*
	IF &UpCase(&Def) <> 'IF' THEN
.*			
	ADD	&Dreg,&Dreg	
	MOVE	Case&SysNdx(&Dreg),&Dreg 
	JMP	Case&SysNdx(&Dreg)
Case&SysNdx
	WHILE &i <= &n DO	Process each case label
	IF &SysList[&i] <> '' THEN	
	DC.W	&SysList[&i]-Case&SysNdx
	ELSE		
	DC.W	&Def-Case&SysNdx
	ENDIF
&i	SETA	&i+1	Count off parameter
	ENDWHILE
	ELSE		Process (Cst,lbl) pairs
&Sz	SETC	&Default(&Size,'S') Setup size attribute
	WHILE &i <= &n DO	Process each (Cst,lbl) pair
	CMPI	#&SysList[&i,1],&Dreg
	BEQ.&Sz	&SysList[&i,2]
&i	SETA	&i+1	Count off parameter
	ENDWHILE
	ENDIF
.*	
	PRINT	Pop	Restore original print status
	ENDM
	
;
;=================================================================
;Function ReadyToRun(ThePtr: TPtr): boolean;
;=================================================================
; Regarde si la tache pointee est prete a tourner
                EXPORT  ReadyToRun
				
StatusWord		equ		74
PendAdr			equ		84
PendStr			equ		88
True			equ		$0100

ReadyToRun
				; dc.w	$face				; debugger entry
				
                move.l  4(sp),a1	        ; Get ThePtr
				
				move.w	StatusWord(a1),d0	; Get StatusWord
				
				Case# (d0,NotReady),\
						ReturnTrue,\		;	0	ReadyCst
						,\					;	1	DelayCst
						,\					;	2	IOWaitCst
						,\					;	3	IOTWaitCst
						,\					;	4	ChrCst
						,\					;	5	ChrTCst
						PendTest,\			;	6	PdCst
						PendTest,\			;	7	PdTCst
						SPendTest,\			;	8	StrPdCst
						SPendTest,\			;	9	StrPdTCst
						,\					;	10	NetCst
						,\					;	11	NetTCst
						,\					;	12	WOutCst
						,\					;	13	not used
						StartRun,\			;	14	StartCst
						,\					;	15	not used
						PostTest,\			;	16	PostCst
						PostTest,\			;	17	PostTCst
						,\					;	18	SuspendCst
						,\					;	19	not used
						PendWTest,\			;	20	PendWCst
						,\					;	21	not used
						,\					;	22	WDataCst
						,\					;	23	WDataTCst
						,\					;	24	WComCst
						,\					;	25	WComTCst
						,\					;	26	WOBuffCst
						,\					;	27	not used
						PendBTest,\			;	28	PendBCst
						PendBTest,\			;	29	PendBTCst
						PostBTest,\			;	30	PostBCst
						PostBTest,\			;	31	PostBTCst
						,\					;	32	ADSPWaitCst
						,\					;	33	RunModeCst
						,					;	34  BaseWaitCst
						
				nop
				nop
PostBTest
											; is byte empty ???
				move.l	PendAdr(a1),a0
				tst.b	(a0)
				bne.s	NotReady
				bra.s 	ReturnReady
				
				
PendBTest
											; is byte full ???
				move.l	PendAdr(a1),a0
				tst.b	(a0)
				beq.s	NotReady
				bra.s 	ReturnReady
				
				
PendWTest									; is byte full ???
				move.l	PendAdr(a1),a0
				tst.w	(a0)
				beq.s	NotReady
				bra.s 	ReturnReady
				
				
PendTest									; is mailbox full ???
				move.l	PendAdr(a1),a0
				tst.l	(a0)
				beq.s	NotReady
				bra.s 	ReturnReady
				
				
SPendTest									; is string according to pattern ???
				move.l	PendAdr(a1),a0
				move.l	(a0),d0
				and.l	#$00ffffff,d0
				cmp.l	PendStr(a1),d0
				bne.s	NotReady
				bra.s 	ReturnReady
				
				
				IMPORT	SetCurSt
StartRun									; restart task
				move.l	a1,-(sp)			; save ThePtr
				
				move.l	a1,-(sp)
				jsr		SetCurSt			; set CurStPtr
				
				jsr		RunTask
				move.l (sp)+,a1				; restore ThePtr
				bra.s	ReturnReady
				
PostTest									; is mailbox NULL ???
				move.l	PendAdr(a1),a0
				tst.l	(a0)
				bne.s	NotReady
				; bra.s 	ReturnReady
				
				
ReturnReady
				move.w	#0,StatusWord(a1)	; set StatusWord to Ready
ReturnTrue
				move.l	(sp)+,a0			; return address
				addq.l	#4,sp				; remove parameters
                move.w  #True,(sp)		    ; return True
                jmp     (a0)		        ; Return to caller
				

NotReady
				move.l	(sp)+,a0			; return address
				addq.l	#4,sp				; remove parameters
                clr.w  	(sp)		    	; Return False
                jmp     (a0)		        ; Return to caller


;
;=================================================================
;Procedure SetPtr(TheP: Ptr;ThePtr: TPtr); external;
;=================================================================
                EXPORT  SetPtr
SetPtr
                move.l  (sp)+,a0	        ; Get Return address
                move.l  (sp)+,d0	        ; Get ThePtr
                move.l  (sp)+,a1	        ; Get TheP
				
				move.l	d0,(a1)				; Set the pointer

                jmp     (a0)		        ; Return to caller

;

;
;=================================================================

               ENDPROC
			   END
