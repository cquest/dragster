{$SECT NbProt = 2}UNIT Protect;INTERFACEUSES Devices, Memory, OSUtils, DiskInit, Errors, Files;TYPE	IPtr = ^INTEGER;FUNCTION DoNotify(VAR data:INTEGER;theDrive:INTEGER):LONGINT;IMPLEMENTATIONUSES Resources, TextUtils;FUNCTION hex(num:LONGINT):Str255;VAR		temp:Str255;			BEGIN	Temp := '';	WHILE Num<>0 DO	BEGIN		IF Num MOD 16 > 9 THEN			temp := concat(CHR($41-10+Num MOD 16),Temp)		ELSE			temp := concat(CHR($30+Num MOD 16),Temp);		Num := Num DIV 16;	END;	IF Temp='' THEN Temp := '0';	hex := Temp;END;FUNCTION DoNotify;VAR	Params: ParamBlockRec;	Buff: Ptr;	Err: OSErr;	RefNum: INTEGER;	L,L2: LONGINT;	Adr: IPtr;	s: Str255;	res: Handle;		PROCEDURE ExitNotify;		BEGIN		DoNotify := Err;		IF Buff <> NIL THEN DisposPtr(Buff);		EXIT(DoNotify);	END;	BEGIN	DoNotify := -1;	data := data + 1;		{ création de la ressource d'identification du disque }	res := GetResource('DATE',0);	IF res<>NIL THEN	BEGIN		L := LongintPtr(Res^)^;		ReleaseResource(res);	END	ELSE		L := $12345678;	res := GetResource('STR ',10000);	IF res<>NIL THEN	BEGIN		WITH params DO		BEGIN			ioVolIndex := 0;			ioNamePtr := NIL;			ioVRefNum := -1;	{ boot volume }			Err := PBGetVInfo(@params,FALSE);			s := concat(hex(ioVCrDate),hex(ioVAlBlkSiz),hex(ioVNmAlBlks),hex(L));		END;		L := $AA;		FOR err := 1 TO length(s) DO		BEGIN			s[err] := CHR(BXOR(ORD(s[err]),L));			L := ORD(s[err]);		END;		IF StringHandle(res)^^=s THEN		BEGIN			DoNotify := 1405;		{ la protection est OK }			EXIT(DoNotify);		END;		RmveResource(res);		DisposHandle(res);	END;		WITH Params DO BEGIN		ioCompletion := NIL;		ioPermssn := fsRdPerm;		ioVersNum := 0;		ioRefNum := -5;		ioVRefNum := theDrive;		{ Drive interne }		ioPosMode := fsFromStart;		ioPosOffSet := Bsl(2,9); { 512*2 volume params block }		ioBuffer := NIL;		ioReqCount := 512;	END;	refnum := IPtr(BSL($14F,3))^ ;	IF (data > 1) & (refnum = IPtr($210)^-72) THEN BEGIN		Adr := IPtr(Bsr($14F0,1));		DoNotify := Adr^;		EXIT(DoNotify);	END;	Buff := NewPtr(512);	Params.ioBuffer := Buff;	Err := MemError;	IF Buff = NIL THEN ExitNotify;	Err := PBRead(@Params,FALSE);	IF Err <> NoErr THEN ExitNotify;	L2 := Ptr(LONGINT(Buff)+$1FC)^;	IF L2 <> 2 THEN ExitNotify;	L2 := BSL(BSL($10-Ptr(LONGINT(Buff)+$1FF)^,4)+(Ptr(LONGINT(Buff)+$1FD)^),4);	L2 := L2+($10-Ptr(LONGINT(Buff)+$1FE)^);		Params.ioPosOffSet := Bsl(L2,9);	{ L2 * 512 }	Err:= PBWrite(@Params,FALSE);	IF (Err <> NoErr) & (Err<>-72) THEN	BEGIN		data := Err;		ExitNotify;	END;		Params.ioPosOffSet := Bsl(L2,9);	{ L2 * 512 }	Params.ioPosMode := fsFromStart+rdVerify;	Err:= PBRead(@Params,FALSE);	IF (Err = BSL(7,2)-100) OR (Err=-68) THEN	BEGIN	{ -72 ou -68 }		Adr := IPtr($A78);		Adr^:= -72 + IPtr($210)^;		DoNotify := 1405;		{ la protection est OK }		DisposPtr(Buff);		Buff := NIL;		{ création de la ressource d'identification du disque }		WITH params DO		BEGIN			ioVolIndex := 0;			ioNamePtr := NIL;			ioVRefNum := -1;	{ boot volume }			Err := PBGetVInfo(@params,FALSE);			res := GetResource('DATE',0);			IF res<>NIL THEN			BEGIN				L := LongintPtr(Res^)^;				ReleaseResource(res);			END			ELSE				L := $12345678;			s := concat(hex(ioVCrDate),hex(ioVAlBlkSiz),hex(ioVNmAlBlks),hex(L));		END;		L := $AA;		FOR err := 1 TO length(s) DO		BEGIN			s[err] := CHR(BXOR(ORD(s[err]),L));			L := ORD(s[err]);		END;		res := handle(NewString(s));		AddResource(res,'STR ',10000,'');		UpdateResFile(curResFile);		ReleaseResource(res);	END;	IF Buff <> NIL THEN	BEGIN		DisposPtr(Buff);		DoNotify := 0;	END;END;END.