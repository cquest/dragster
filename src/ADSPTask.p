{$SETC DEBUG = FALSE }UNIT ADSPTask;INTERFACEUSES	MemTypes,QuickDraw ,OSIntf ,ToolIntf ,PackIntf, AppleTalk, ADSP, TextUtils;PROCEDURE TheTask;IMPLEMENTATION     {$I DragsterTCB.p}CONST	TaskQueue = ADSPQ;	FUNCTION GetCurSt: TPtr;{ GetCurSt rend CurStPtr, qui pointe sur le TCB actif }EXTERNAL;PROCEDURE SwapTasks(AdRegs1,AdRegs2: Ptr);{ Sauvegarde contexte courant dans AdRegs1 et restaure AdRegs2 }EXTERNAL;PROCEDURE AsmCompletion;{ IOCompletion qui donne l'adresse de la tache appelante }EXTERNAL;PROCEDURE YieldCpu;BEGIN	WITH GetCurSt^ DO SwapTasks(@RegArea, @RegAreaF);END;PROCEDURE WaitDelay(Num1: Longint);BEGIN        WITH GetCurSt^ DO          BEGIN                DelayValue:=Num1;                StatusWord:=DelayCst;                SwapTasks(@RegArea,@RegAreaF);          END;END;PROCEDURE SetRunMode(NewMode: Integer);	VAR		SaveStatus: Integer;	BEGIN		WITH GetCurSt^ DO			BEGIN				SaveStatus := StatusWord;				RunMode := NewMode;				StatusWord := ReadyCst;				WHILE CurRunMode > RunMode DO					SwapTasks(@RegArea, @RegAreaF);				StatusWord := SaveStatus;			END;	END;PROCEDURE DebugNum(str: Str255; Num: Longint; Go: boolean);VAR	Chaine: Str255;BEGIN	NumToString(Num, Chaine);	IF Go THEN Chaine := Concat(Chaine, ';G');	DebugStr(Concat(str, Chaine));END;PROCEDURE TheTask;  { Tache de gestion d'ADSP }CONST ErrCode      =       -1;     { mauvais code action }VAR	ThePtr	    : TPtr;	TheRequest	: TQEPtr;	MPPPB : RECORD		Tcb		: TPtr;		MPP		: MPPParamBlock;	END;	ADSPRefNum	: INTEGER;	CCB			: TRCCB;	i			: Integer;	Registered	: BOOLEAN;	PROCEDURE ADSPWaitConnect;	VAR Err : INTEGER;	BEGIN{$IFC DEBUG}	DebugStr('ADSP Waitconnect');	{$ENDC}				WITH GetCurSt^ DO		BEGIN			{ •••• Initialisation et Identification sur le réseau •••• }			IF NOT Registered THEN			BEGIN								{ •• Ouverture Driver ADSP •• }				Err := OpenDriver('.DSP',ADSPRefNum);{$IFC DEBUG}	DebugNum('ADSP OpenDriver=',err,(err=0));	{$ENDC}							{ •• Init d'un connection listener •• }				IOCompFlag := 1;				StatusWord := IOWaitCst;				Infos^.PB.TCBPtr := GetCurSt;				WITH Infos^.PB.ADSPPB DO				BEGIN					ioCompletion := @AsmCompletion;					ioCRefNum := ADSPRefNum;					csCode := dspClInit;					ccbPtr := @CCB;					userRoutine		:= nil;		{client routine to call on event}					sendQSize		:= 0;				{size of send queue (0..64K bytes)}					sendQueue		:= nil;			{client passed send queue buffer}					recvQSize		:= 0;				{size of receive queue (0..64K bytes)}					recvQueue		:= nil;			{client passed receive queue buffer}					attnPtr			:= nil;			{client passed receive attention buffer}					localSocket := 0;				END;				Err := PBControl(@Infos^.PB.ADSPPB,TRUE);{$IFC DEBUG}	DebugNum('ADSP dspCLInit Err=',err,(err=0));	{$ENDC}				YieldCPU;{$IFC DEBUG}	DebugNum('ADSP dspCLInit ioResult=',Infos^.PB.ADSPPB.ioResult,(Infos^.PB.ADSPPB.ioResult=0));	{$ENDC}								{ •• Enregistrement du Socket dans le NTE (Bidouille)•• }				PStr64(PTSVars)^[7]:=CHAR(Infos^.PB.ADSPPB.LocalSocket);								{ •• Enregistrement du listener sur le réseau •• }				IOCompFlag := 1;				StatusWord := IOWaitCst;								MPPPB.Tcb := GetCurSt;								WITH MppPB.MPP DO	{set up PRegisterName parameters}				BEGIN					ioCompletion := @AsmCompletion;					interval := 7;						{retransmit every 7*8=56 ticks}					count := 3;								{and retry 3 times}					nbpPtrs := PTSVars;				{name to register}					verifyFlag := 1;					{always TRUE see TN#225}				END;				Err := PRegisterName(@MppPB.MPP, TRUE);	{register this name}{$IFC DEBUG} DebugNum('PRegisterName Error=',Err,(err=0)); {$ENDC}				YieldCpu;				Registered := TRUE;			END;	{ IF NOT Registered }							{ •• attente d'une demande de connexion •• }			IOCompFlag := 1;			StatusWord := IOWaitCst;					Infos^.PB.TCBPtr := GetCurSt;				WITH Infos^.PB.ADSPPB DO			BEGIN				ioCompletion := @AsmCompletion;				csCode := dspCLListen;				filterAddress := AddrBlock(0);			END;			Err := PBControl(@Infos^.PB.ADSPPB,TRUE);{$IFC DEBUG}	DebugNum('ADSP dspCLListen err=',err,(err=0));	{$ENDC}			YieldCPU;{$IFC DEBUG}	DebugNum('ADSP dspCLListen ioResult=',Infos^.PB.ADSPPB.ioResult,(Infos^.PB.ADSPPB.ioResult=0));	{$ENDC}					{ •• on rempli le CCB de la tâche appelante •• }			WITH TheRequest^.Eowner^.Infos^.PB.ADSPPB,Infos^.PB DO			BEGIN				ocMode := ocAccept;				remoteCID := ADSPPB.RemoteCID;				remoteAddress := ADSPPB.remoteAddress;				sendSeq := ADSPPB.SendSeq;				sendWindow := ADSPPB.SendWindow;				attnSendSeq := ADSPPB.attnSendSeq;			END;		END	{ WITH GetCurSt^ }	END;	{ ADSPWaitConnect }BEGIN		{SetRunMode(0);}	{ 17/10/95 }    Registered := FALSE;	 	ThePtr:=GetCurSt;		{ initialisation de notre queue }		WITH ThePtr^,TheQueues^[TaskQueue] DO		BEGIN			QOwner:=ThePtr;			QFirst:=Nil;			QEnd:=Nil;			QNumber:=0;		END;				WITH ThePtr^ DO		WHILE true DO		BEGIN			{ on attend une requete }			WHILE (TheQueues^[TaskQueue].QFirst = NIL) OR (TheQueues^[TaskQueue].QNumber < 1)			DO WaitDelay(10);			{$IFC DEBUG}	DebugStr('ADSPTask…');	{$ENDC}			TheRequest := TheQueues^[TaskQueue].QFirst;					{ on traite la requete en cours }			{ param1 contient le code de la requete }			{ param2 contient le pointeur Infos de la tâche appelante }			WITH TheRequest^ DO			BEGIN				ZoneNumber := ECode;				MaxTime := ORD4(EOwner);				CASE ECode OF					ReqADSPWaitConnect:	ADSPWaitConnect;				END;	{ CASE }				{$IFC Debug}	DebugStr('Appel accepté'); {$ENDC}				ZoneNumber := 0;				MaxTime := 0;				EOwner^.StatusWord:=ReadyCst;      END;				WITH TheQueues^[TaskQueue] DO		BEGIN			QFirst := QFirst^.QLink;			IF QFirst = NIL THEN			BEGIN				QEnd := Nil;				QNumber := 0;			END;			IF QNumber > 0 THEN QNumber := QNumber -1;		END;				WaitDelay(1);		     END;END;END. {of Dragster Run Time}