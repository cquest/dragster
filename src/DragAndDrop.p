VAR	theDragRef: DragReference;{$S DragAndDrop}PROCEDURE DrawCaret(hTE: TEHandle; offset: INTEGER);VAR	thePoint: Point;	oldClip: RgnHandle;	BEGIN	IF offset>=0 THEN	BEGIN		oldClip := NewRgn;		GetClip(oldClip);		ClipRect(hTE^^.viewRect);		thePoint := TEGetPoint(offset,hTE);		PenMode(patXor);		MoveTo(thePoint.h - 1, thePoint.v - 1);		Line(0, 1 - hTE^^.lineHeight);		PenNormal;		SetClip(oldClip);		DisposeRgn(oldClip);	END;END;{$S DragAndDrop}FUNCTION DoDragTrack(theMessage: DragTrackingMessage;												theWindow: WindowPtr;												theEcran: HandleEcran;												theDrag: DragReference):OsErr;VAR	b: BOOLEAN;	i: INTEGER;	theItemRef: ItemReference;	theFlags : FlavorFlags;	L: LONGINT;	nb: INTEGER;	mouse: Point;	pinnedMouse: Point;	attributes: DragAttributes;	hiliteRgn: RgnHandle;	r: Rect;	offset: INTEGER;	BEGIN	Err := GetDragAttributes(theDrag, attributes);		CASE theMessage OF		dragTrackingEnterWindow:		BEGIN			b := FALSE;			Err := CountDragItems (theDragRef, nb);			FOR i := 1 TO nb DO			BEGIN				IF GetDragItemReferenceNumber (theDrag, i, theItemRef)=NoErr THEN				BEGIN					Err := GetFlavorFlags (theDrag, theItemRef, 'TEXT', theFlags);					IF Err=NoErr THEN					BEGIN						theEcran^^.dragAccepted := TRUE;						theEcran^^.dragItem := theItemRef;						theEcran^^.dragTime := 0;						theEcran^^.DragCaretVisible := FALSE;						Leave;					END;				END				ELSE					Leave;			END;			theEcran^^.dragOffset := -1;		END;				dragTrackingInWindow:		BEGIN				Err := GetDragMouse(theDrag, mouse, pinnedMouse);      GlobalToLocal(mouse);      IF (theEcran^^.dragAccepted) & PtInRect(mouse, theEcran^^.hTE^^.viewRect) THEN			BEGIN	      IF BAND(attributes,dragHasLeftSenderWindow)<>0 THEN				BEGIN					hiliteRgn := NewRgn;					r := theEcran^^.hTE^^.viewRect;					WITH r DO					BEGIN						left := left-4;						right := right+5;						bottom := bottom+1;					END;					RectRgn(hiliteRgn, r);					Err := ShowDragHilite(theDrag, hiliteRgn, true);					DisposeRgn(hiliteRgn);				END;								offset := TEGetOffset(mouse,theEcran^^.hTE);									{ on est dans la sélection de départ ? }				IF (BAND(attributes,dragInsideSenderWindow)<>0) & (offset>theEcran^^.hTE^^.selStart) & (offset<theEcran^^.hTE^^.selEnd) THEN				BEGIN					IF theEcran^^.DragCaretVisible THEN					BEGIN						DrawCaret(theEcran^^.hTE, theEcran^^.DragOffset);						theEcran^^.DragCaretVisible := FALSE;					END;					theEcran^^.DragOffset := -1;					EXIT(DoDragTrack);				END;								IF offset<>theEcran^^.DragOffset THEN	{ on a bougé }				BEGIN					IF theEcran^^.DragCaretVisible THEN						DrawCaret(theEcran^^.hTE, theEcran^^.DragOffset);	{ efface l'ancien }					theEcran^^.DragOffset := offset;					DrawCaret(theEcran^^.hTE, theEcran^^.DragOffset);	{ dessine le nouveau }					theEcran^^.DragTime := TickCount;					theEcran^^.DragCaretVisible := TRUE;				END				ELSE				IF TickCount>theEcran^^.DragTime+GetCaretTime THEN				BEGIN					theEcran^^.DragCaretVisible := NOT theEcran^^.DragCaretVisible;					theEcran^^.DragTime := TickCount;					DrawCaret(theEcran^^.hTE, theEcran^^.DragOffset);	{ clignotement }				END;      END			ELSE			BEGIN				IF theEcran^^.DragCaretVisible THEN				BEGIN					DrawCaret(theEcran^^.hTE, theEcran^^.DragOffset);					theEcran^^.DragCaretVisible := FALSE;				END;				theEcran^^.DragOffset := -1;				Err := HideDragHilite(theDrag);			END;		END;				dragTrackingLeaveWindow:		BEGIN			IF theEcran^^.dragAccepted THEN			BEGIN				IF theEcran^^.DragCaretVisible THEN				BEGIN					DrawCaret(theEcran^^.hTE, theEcran^^.DragOffset);					theEcran^^.DragCaretVisible := FALSE;				END;				theEcran^^.DragOffset := -1;				Err := HideDragHilite(theDrag);				theEcran^^.dragAccepted := FALSE;			END;		END;	END;	{ CASE theMessage }END;{$S DragAndDrop}FUNCTION DoDragReceive(	theWindow : WindowPtr;														theEcran: HandleEcran;														theDragRef : DragReference) : OSErr;VAR	dataPtr: Ptr;	dataSize: Size;	oldFen: WindowPtr;	movetext: BOOLEAN;	attributes: DragAttributes;	modifiers : INTEGER;	mouseDownModifiers : INTEGER;	mouseUpModifiers : INTEGER;	oldStart: INTEGER;BEGIN	IF theEcran^^.dragAccepted & (theEcran^^.DragOffset>=0) THEN	BEGIN		Err := GetDragAttributes (theDragRef, attributes);		Err := GetDragModifiers (theDragRef, modifiers, mouseDownModifiers, mouseUpModifiers);		moveText := (BAND(attributes,dragInsideSenderWindow)<>0) & (BAND(mouseUpModifiers, optionKey)=0);		Err := GetFlavorDataSize (theDragRef, theEcran^^.dragItem, 'TEXT', dataSize);		{ on limite la longueur pour éviter de dépasser 32000 caractères }		IF dataSize>32000-theEcran^^.Hte^^.teLength THEN dataSize :=32000-theEcran^^.Hte^^.teLength;		dataPtr := NewPtr(dataSize);		Err := GetFlavorData(theDragRef, theEcran^^.dragItem, 'TEXT', dataPtr, dataSize, 0);				IF (Err=NoErr) & (dataSize>0) THEN		BEGIN			{ on vire l'hilite }			IF theEcran^^.DragCaretVisible THEN			BEGIN				DrawCaret(theEcran^^.hTE, theEcran^^.DragOffset);				theEcran^^.DragCaretVisible := FALSE;			END;			Err := HideDragHilite(theDragRef);						{ mémorisation des infos pour l'annulation… }			SaveForUndo(theEcran^);						{ déplacement… on efface l'ancien texte }			IF moveText THEN			BEGIN				IF theEcran^^.Hte^^.selStart<theEcran^^.dragOffset THEN		{ décalage de la réception si besoin }					theEcran^^.dragOffset := theEcran^^.dragOffset-dataSize;				TEDelete(theEcran^^.Hte);	{ effacement }			END;						{ on met le texte reçu à l'emplacement du drag }			TESetSelect(theEcran^^.dragOffset,theEcran^^.dragOffset,theEcran^^.Hte);			TEInsert(dataPtr,dataSize,theEcran^^.Hte);			TESetSelect(theEcran^^.dragOffset,theEcran^^.dragOffset+dataSize,theEcran^^.Hte);			DoDragReceive := NoErr;			theEcran^^.DragOffset := -1;			theEcran^^.modification := TRUE;			theEcran^^.ErrFlag := TRUE;	{ source à analyser }		END;		IF Err<>NoErr THEN SysBeep(60);				IF DataPtr<>NIL THEN DisposPtr(dataPtr);	END;END;{$S DragAndDrop}PROCEDURE DoDragInit;BEGINEND;{$S DragAndDrop}PROCEDURE DoDragStart(theEvent: EventRecord; hTE: TEHandle);VAR	Err: OsErr;	TErgn: RgnHandle;	TempRgn: RgnHandle;	pt: Point;	BEGIN	IF WaitMouseMoved(theEvent.where) THEN	BEGIN		IF NewDrag(theDragRef)<>NoErr THEN EXIT(DoDragStart);		Err := AddDragItemFlavor(theDragRef, 0, 'TEXT', Ptr(ORD4(hTE^^.hText^)+hTE^^.SelStart), hTE^^.SelEnd-hTE^^.SelStart, 0);		IF Err=NoErr THEN		BEGIN			{ on récupère la région correspondant au texte sélectionné }			TERgn := NewRgn;			tempRgn := NewRgn;			Err := TEGetHiliteRgn(TERgn, hTE);			{ on ne garde que le contour de cette région }			CopyRgn(TERgn, tempRgn);			InsetRgn(tempRgn, 1, 1);      DiffRgn(TERgn, tempRgn, TERgn);			DisposeRgn(tempRgn);      SetPt(pt,0,0);			LocalToGlobal(pt);			OffsetRgn(TERgn, pt.h, pt.v);			{ on démarre le drag… }			Err := TrackDrag(theDragRef, theEvent, TERgn);			{ on libère les régions }			DisposeRgn(TERgn);		END;		Err := DisposeDrag(theDragRef);	END;END;