{$IFC UNDEFINED Debug}{$SETC Debug = FALSE }{$ENDC}{$IFC UNDEFINED Demo}	{ DragsterBootDémo }{$SETC Demo = FALSE }{$ENDC}{$IFC UNDEFINED LIGHT}	{ MacARBO Junior ou Démo }{$SETC LIGHT = FALSE }{$ENDC}{$SETC SERIAL = TRUE }{$SETC Debug = FALSE }{$SETC Debug2 = FALSE }UNIT DragsterInit2;INTERFACE{***********************************************************************}{*								       																						   *}{*	      Fichier Implementation Boot Background Videotex	 	      	   *}{*								       								 															 *}{***********************************************************************}USES	MemTypes,QuickDraw ,OSIntf ,ToolIntf ,PackIntf, SysEqu, AppleTalk, ADSP, TextUtils,		INITdrgutil,		DragsterInitProt,		{$U $$Shell(PUtilities) } Utilities;FUNCTION Init2Proc(PROCEDURE ShowMsg(Msg:INTEGER); DrgPtr:Ptr; DrgSize:LONGINT):OsErr;VAR		DrgGlobs : RECORD		started: BOOLEAN;		PortAUsed: BOOLEAN;											{ utilisation port modem }		PortBUsed: BOOLEAN;											{ utilisation port imprimante }		NBPData: EntityName;										{ datas d'NBP }		ADSPData: ARRAY [0..32] OF ParmBlkPtr;	{ datas d'ADSP }		DrvrRef: INTEGER;												{ RefNum du driver de Dragster }		FirstTCB: Ptr;													{ premier TCB }		MemoryHold: BOOLEAN;										{ vérouillage pour VM ? }		JumpTable: Ptr;													{ adresse de la JumpTable }		SpyerPtr: Ptr;													{ adresse du Spyer }	END;IMPLEMENTATIONUSES GestaltEqu;{$S Phase2}CONST	ExtType = 'DEXT';	{ routines externes "normales" }	ExtType2 = 'DEXC';	{ routines externes pour code "compilé" }	ExtJumpType = 'EXJT';{$IFC Demo}	MainDemoFlag = TRUE;{$ELSEC}	MainDemoFlag = FALSE;{$ENDC}TYPE	IPtr = ^Integer;	IHandle = ^IPtr;	LIPtr  = ^Longint;	LIHdle = ^LIPtr;{$I DragsterTCB.p }FUNCTION Concatnum(str:str255; num:longint):str255;VAR	tempStr:Str255;BEGIN	numtostring(num,tempstr);	concatnum := concat(str,tempstr);END;PROCEDURE MySpyerStart(ThePtr1: Ptr; ThePtr2: TPtr; ThePtr3: Ptr); EXTERNAL;PROCEDURE MonCallProc(TheP0,TheP1: Ptr); EXTERNAL;PROCEDURE Align(VAR p:Ptr);{ aligne sur une adresse divisible par 4 (optimisation 68020 et suivants…) }VAR off: INTEGER;BEGIN	off:= BAND(ORD4(p),3);	IF off<>0 THEN p:=ptr(ORD4(p) + 4-off);END;FUNCTION Init2Proc;  { 2e phase du boot }	CONST 	MaxServDesc = 20;		TYPE	ServDesc	= RECORD				TSKPH			:  TSKPHdle;				TSKCH			:  Handle;				PredTask	:  Integer;				BaseSCode,				BaseSShared,				BaseSLoc,				BaseSStack,				BaseSRW,				BaseSDB		: Ptr;		END;			VAR		RefR	     	:   Integer;		TheServ 		: 	ARRAY [1..MaxServDesc] OF ServDesc;		TheDrvRef		: 	integer;		BaseIOBuf,		BaseSerQ,		BaseMessQ,		BaseShared,		BaseCode,		BaseRT,		BaseRTExt,		BaseRTx,		BaseORB,		BaseADSP,		BaseLoc,		BaseStack,		BaseRW,		BaseDB,		BaseServer,		BaseIP,		BaseSpyer,		InputBuf		: 	Ptr;		NbTask,		NbServTask	: 	Integer;		Termine			: 	Boolean;		TheTPT			:	TPTPtr;		NPTY,PPTY		:	Integer;		HSpyer			:	Handle;		NbRT,RTidx	:	Integer;		TheIPool		:	PBuffPtr;		TheIBuff		:	iBuffPtr;		TheMods  		:	ModsArray;		NbHard			:	Longint;	{ nb de voies de communication }		NbModem			:	Longint;	{ nb de voies Modem }		NbMuxASM		:	Longint;	{ nb de voies ASM }		NbMuxASM2		:	Longint;	{ nb de voies ASM - deuxieme port serie }		TheLJump 		:	Ptr;		SerRefIn,		SerRefOut		:	Integer;		SerRefIn2,					{ deuxième port série }		SerRefOut2	:	INTEGER;		FlagMaster	:	boolean;	{ indique si il y a des voies Dragster }		FlagSerial	:	boolean;	{ indique si on utilise le port série directement }		Count,		SzRunTime		:	Longint;		StartPtr,		EndPtr			:	Ptr;		Err					:	OSErr;		TheXFile		:	XFileRecord;		ThePtr,		TheSPtr,		TheFPtr			:	TPtr;		TheJPtr			:	TJumpPtr;    OurStor	    :   TConfHdle;    OurRT	      :   Handle;    TheDRVR	    :   Handle;    TheBigSize,    TheOffset   :   Longint;    nbOff	      :   Longint;    NbAux				:   longint;    Error	      : 	Integer;    SnFlag	    : 	Boolean;    MySn	      : 	SNH;		AppName			: 	Str255;		i,j					: 	Longint;    TestSn			: 	Str255;    fndrInfo		: 	Finfo;    MaxRes	    : 	longint;    TSN,TSNT    : 	longint;		TheRF				:	Integer;		ResFile			:	Integer;	{ •••• fichier contenant les routines externes •••• }		ADSPRefNum	:	INTEGER;		ADSPDatas		:	InfoPtr;		TempStr			:	Str255;		TempStr2		:	Str255;    MyLaunch : RECORD				{ démarrage d'une appli }              	pfname:^Str255;              	param: integer;             	  END;		CodeName		:	Str255;		AppRefNum		:	INTEGER;				NbMods			: INTEGER;		demoFlag		: BOOLEAN;		{ indique si on est en version de démo }		demoCode		: BOOLEAN;		{ indique que le code compilé est un code de démo }		GardeFou		: LIPtr;				TheRes			:	Handle;    pb 				: 	RECORD						{12 byte header used by the file and IO system}						qLink: QElemPtr;			{queue link in header}						qType: INTEGER;				{type byte for safety check}						ioTrap: INTEGER;			{FS: the Trap}						ioCmdAddr: Ptr;				{FS: address to dispatch to}		 						{common header to all variants}						ioCompletion: ProcPtr;		{completion routine addr (0 for synch calls)}						ioResult: OSErr;			{result code}						ioNamePtr: StringPtr;		{ptr to Vol:FileName string}						ioVRefNum: INTEGER;			{volume refnum (DrvNum for Eject and MountVol)}		 						ioRefNum: INTEGER;			{refNum for I/O operation}						CSCode: INTEGER;			{word for control status code}						CSParam: Ptr;  				{operation-defined parameters}				 	END;		gHasVM : BOOLEAN;		{ indique si la mémoire virtuelle est active }		Junior : BOOLEAN;		{ indique si l'on est en MacARBO Junior ou Démo }		TypeASM: INTEGER;		{ type d'ASM }				EveKey : BOOLEAN;		XorKey : INTEGER;		{ clé pour décoder le code compilé }		OrigPtr: Ptr;				PROCEDURE MyExit(theError:INTEGER);		BEGIN		Init2Proc := theError;		EXIT(Init2Proc);	END;		FUNCTION SizeExt:LONGINT;		VAR		Res: Handle;		ResName: Str255;		ResIndex: INTEGER;		TheSize: LONGINT;			BEGIN		ResIndex := 0;		TheSize := 0;		REPEAT			ResIndex := ResIndex+1;			GetIndString(ResName,128,ResIndex);			IF ResName <> '' THEN			BEGIN				Res := GetNamedResource(ExtType2,ResName);				IF Res=NIL THEN Res := GetNamedResource(ExtType,ResName);				TheSize := TheSize + SizeResource(Res);				ReleaseResource(Res);				IF Odd(TheSize) THEN TheSize := TheSize + 1;			END;		UNTIL ResName='';		SizeExt := TheSize;	END;	PROCEDURE AddExternals;		TYPE		JT = PACKED ARRAY [0..300] OF RECORD			Jump: INTEGER;			Addr: LONGINT;		END;				JTPtr = ^JT;			VAR		Res: Handle;		ResName: Str255;		ResIndex: INTEGER;		BaseExt: Ptr;		TheJT: JTPtr;		ExtJT: INTEGER;			BEGIN{$IFC Debug}	DebugStr('Chargement des routines externes');{$ENDC}		Res := GetResource(ExtJumpType,128);		IF Res<>NIL THEN ExtJt := IHandle(Res)^^ ELSE ExtJt := 176;		ReleaseResource(Res);		ShowMsg(16);				ResIndex := 0;		BaseExt := BaseRTExt;		TheJT := JTPtr(ORD4(BaseRT)+20);		REPEAT			ResIndex := ResIndex+1;			GetIndString(ResName,128,ResIndex);			IF ResName <> '' THEN			BEGIN				Res := GetNamedResource(ExtType2,ResName);				IF Res=NIL THEN Res := GetNamedResource(ExtType,ResName);				BlockMove(Ptr(Res^),BaseExt,SizeResource(Res));				TheJT^[ExtJt+ResIndex].Addr:=LONGINT(BaseExt);				BaseExt := Ptr(ORD4(BaseExt) + SizeResource(Res));				ReleaseResource(Res);				IF Odd(LONGINT(BaseExt)) THEN BaseExt := Ptr(ORD4(BaseExt) + 1);			END;		UNTIL ResName='';	END;	PROCEDURE RemoveTask(theTask:INTEGER);	VAR	i,j: INTEGER;		Termine: BOOLEAN;			BEGIN		{ on vire la tache demandée }		j := 1; Termine:=False;		FOR j := 1 TO MaxRes DO			IF TheServ[j].TSKPH^^.TSKCNumber=theTask THEN			BEGIN				Termine := TRUE;				Leave;			END;				IF Termine THEN	{ on a trouvé la tâche à supprimer… }		BEGIN			{ j est l'indice de la tache à supprimer }			ReleaseResource(Handle(TheServ[j].TSKPH));			ReleaseResource(Handle(TheServ[j].TSKCH));			FOR i:=j+1 TO MaxRes DO			BEGIN				TheServ[i-1]:=TheServ[i];			END;			{ une tache de moins }			MaxRes := MaxRes-1;		END;	END;	PROCEDURE TestGardeFou;		BEGIN		IF GardeFou^<>$87654321 THEN DebugStr('Garde fou !!!');	END;	BEGIN{$IFC Debug}	 DebugStr('Entree dans Init2Proc');{$ENDC}	nbModem := 0;	nbLocal := 0;	nbMuxAsm := 0;	NbMuxASM2 := 0;	nbAux := 0;{$IFC DEMO=FALSE}(*EveKey := (EveStatus=0);	{ clé EvE présente ? }*){$ENDC}	GetNbLocal;	EveKey := (NbLocal2 = 0);	WITH DrgGlobs DO	BEGIN		started := FALSE;		PortAUsed := FALSE;		PortBUsed := FALSE;		NBPdata.objStr := '';		FOR i := 0 TO 32 DO ADSPData[i] := NIL;		MemoryHold := FALSE;	END;		{ mémoire virtuelle présente ? }	gHasVM := BTst(GetGestaltResult(gestaltVMAttr),gestaltVMPresent);		{------------- raz de la mémoire destinée à Dragster ------------}	ShowMsg(6);	{$IFC Debug}	DebugStr(concatnum('DrgSize=',DrgSize));	DebugStr('raz mémoire Dragster');{$ENDC}	StartPtr := DrgPtr;	OrigPtr := DrgPtr;	Align(StartPtr);	FOR i := 1 TO (DrgSize DIV 4) DO	BEGIN		LongintPtr(StartPtr)^:=0;		StartPtr:=Ptr(Ord4(StartPtr)+4);	END;	{------------- mise en place du "garde fou" -------------}		GardeFou := LIPtr(ORD4(DrgPtr)+DrgSize-4);	GardeFou^:= $87654321;		 {---------------- On recherche le driver du serveur ------------}	 TheDrvRef:=-(RechDrag+1);	     {--------- recherche de la ressource de configuration ----------}{$IFC Debug}	DebugStr('Ressource de configuration');{$ENDC}    {------------- on choppe la ressource de configuration --------------}     SetResLoad(TRUE);	 ourStor := TConfHdle(GetResource('CONF',256));     IF (ourStor = Nil) | (ResError<>NoErr) THEN MyExit(1);     HnoPurge(Handle(OurStor));    {------------ verification du type du fichier executable -----------}	AppName:=OurStor^^.TheXScreen;	Junior := OurStor^^.TheXScreen='';	{$IFC Debug}	DebugStr(Concat('Nom du code: "',OurStor^^.TheXScreen,'"'));{$ENDC}    	IF NOT Junior THEN	BEGIN		Err:=GetFInfo(OurStor^^.TheXScreen,0,fndrInfo);		WITH fndrInfo DO		BEGIN			IF ((fdType<>'CODE') | ((fdCreator<>'DRG0') & (fdCreator<>'DRG1')))				& (fdType<>'CODd') & (fdCreator<>'DRGd') THEN				MyExit(5);			IF fdType = 'CODd' THEN	{ c'est un code compilé "démo" }				XorKey := $1405			ELSE				XorKey := 0;	{ pas de cryptage du code compilé }		END;		demoCode := (XorKey<>0);	END	ELSE		XorKey := 0;	CodeName := OurStor^^.TheXScreen;	IF CodeName = '' THEN GetAppParms(CodeName,AppRefNum,HSpyer);	HSpyer := NIL;	    {------------------ ouverture du fichier executable ----------------}{$IFC Debug}     DebugStr('Ouverture fichier executable');{$ENDC}	 Err:=FSOpen(CodeName,0,RefR);     IF Err<>0 THEN MyExit(2);	 SetResLoad(FALSE);	{ on ne veut pas des pre-load }	 ResFile := OpenResFile(OurStor^^.TheXScreen);	 SetResLoad(TRUE);	     {------------ lecture des parametres du fichier executable -----------}{$IFC Debug}     DebugStr('Lecture des parametres');{$ENDC}	 	 Count:=SizeOf(XFileRecord);     Err:=FSRead(RefR,Count,@TheXFile);     IF Err<>0 THEN	 BEGIN	 	Err:=FSClose(RefR);	 	MyExit(3);     END;	     {------------------------ recup port serie ------------------------}     CASE OurStor^^.Serport OF				0:			 BEGIN			 			SerRefIn :=-6;						SerRefOut:=-7;						SerRefIn2:=0;						SerRefOut2:=0;						DrgGlobs.PortAUsed := TRUE;				END;								1:				BEGIN					SerRefIn :=-8;					SerRefOut:=-9;					SerRefIn2:=0;					SerRefOut2:=0;					DrgGlobs.PortBUsed := TRUE;				END;								-1:	{ utilisation des deux port série }				BEGIN					SerRefIn :=-6;					SerRefOut:=-7;					SerRefIn2 :=-8;					SerRefOut2:=-9;					DrgGlobs.PortAUsed := TRUE;					DrgGlobs.PortBUsed := TRUE;				END;								OTHERWISE				BEGIN					Err := OpenDriver(concat('.',chr($41+OurStor^^.Serport),'Out'),SerRefOut);					Err := OpenDriver(concat('.',chr($41+OurStor^^.Serport),'In'),SerRefIn);					SerRefIn2 :=0;					SerRefOut2:=0;					DrgGlobs.PortAUsed := FALSE;					DrgGlobs.PortBUsed := FALSE;				END;     END;{$IFC Debug}	DebugStr('Init AppleTalk et ADSP');{$ENDC}     {---------------- on compte le nombre de modems ----------------}	ShowMsg(7);	demoFlag := TRUE;	{ nbLocal := 0; // 13/9/99 }{$IFC DEMO=FALSE}	IF NOT EveKey THEN NbX25Key := 0;	{ pas de clé = pas de voies X25 ASM }	{ nb voies ASM = voies de la clé si nb en config=0 ou > à nb dans la clé }	IF (OurStor^^.X25Number=0) | (NbX25Key < OurStor^^.X25Number) THEN		OurStor^^.X25Number := NbX25Key;{$ENDC}	IF (MPPOpen = NoErr) & (OpenDriver('.DSP',ADSPRefNum)=NoErr) THEN{$IFC Demo=FALSE}		IF NOT Junior THEN	{ autre que démo et junior }		BEGIN			IF (NbLocal=0) | (NOT EveKey) | (NbLocal>32) THEN			BEGIN				NbLocal := 1;		{ une voie locale de démo }				NbLocal2 := 255;			END			ELSE				DemoFlag := FALSE;	{ une clé de protection est présente }		END		ELSE		BEGIN						{ démo ou junior = 1 voie }			GetNbLocal;			IF (EveKey) AND (NbLocal2=-1) THEN DemoFlag := FALSE;	{ Junior }			NbLocal := 1;			NbLocal2 := 255;		END	ELSE		BEGIN			IF Junior THEN			BEGIN				GetNbLocal;				IF (EveKey) AND (nbLocal2=-1) THEN DemoFlag := FALSE;			END;			Nblocal := 0;	{ ADSP ou AppleTalk indisponible ! }		END;{$ELSEC}	BEGIN	{ DragsterBootDémo }		NbLocal := 1;		NbLocal2 := 255;		DemoFlag := TRUE;	END	ELSE		NbLocal := 0;{$ENDC}		{$IFC debug}	DebugStr(concatnum('NbLocal=',nblocal));{$ENDC}		{$IFC Debug}	IF NbLocal = 0 THEN DebugStr('Pas de voie locale');    DebugStr('Comptage des modems en ligne');{$ENDC}		FlagSerial := FALSE;	FlagMaster := FALSE;	NbMods:=0;	{$IFC Demo=FALSE}	NbModem:=CountModem(SerRefOut,FlagMaster,TheMods,NbMods,OurStor);	IF EveKey & (demoCode=FALSE) & (NbModem=0) & (BAND(OurStor^^.WModNumber,1)=0) THEN	BEGIN		{ Réglage paramètres de comm. pour modem Hayes }		IF TestHayes(SerRefOut) THEN		BEGIN			NbMods := NbMods+1;			NbModem := NbModem+1;			TheMods[NbMods].ModNum := 0;			TheMods[NbMods].ModRef:=SerRefOut;	{ driver pour y accéder }			TheMods[NbMods].ModType:=modemHayes;		END;	END;		{ deuxième port ? on compte aussi dessus… }	IF OurStor^^.SerPort=-1 THEN	BEGIN		NBModem:=CountModem(SerRefOut2,FlagMaster,TheMods,NbMods,OurStor);					IF EveKey & (demoCode=FALSE) & (BAND(OurStor^^.WModNumber,1)=1) THEN		IF (NbModem=0) | ((NbModem>0) & (TheMods[NbModem].ModRef<>SerRefOut2)) THEN		BEGIN			{ Réglage paramètres de comm. pour modem Hayes }			IF TestHayes(SerRefOut2) THEN			BEGIN				NbMods := NbMods+1;				NbModem := NbModem+1;				TheMods[NbMods].ModNum := 0;				TheMods[NbMods].ModRef:=SerRefOut2;	{ driver pour y accéder }				TheMods[NbMods].ModType:=modemHayes;			END;		END;	END;{$ELSEC}	NbModem := 0;{$ENDC}{$IFC Demo=FALSE AND LIGHT=FALSE}	IF EveKey & (demoCode=FALSE) & (NbModem=0) THEN	{ pas de modem Dragster en ligne !! }	BEGIN{$IFC Debug}DebugStr('comptage des voies ASM');{$ENDC}		IF NOT Junior & (OurStor^^.SerSpeed<>0) THEN	{ détection voies ASM… }		BEGIN			NbMuxAsm:=CountMuxAsm(SerRefOut,TheMods, nbMods, OurStor);			FlagMaster := FALSE;			TypeASM := TheMods[1].ModType;{$IFC debug}	DebugStr(concatnum('Nb voies ASM=',NbMuxAsm));{$ENDC}			IF (ourStor^^.SerPort=-1) THEN				NbMuxAsm2:=CountMuxAsm(SerRefOut2,TheMods, nbMods, OurStor)-NbMuxAsm;		END;	END;{$ENDC}	IF (NbModem=0) & (NbMuxAsm=0) THEN { pas de modems ni de voies ASM }	BEGIN{$IFC SERIAL}		IF OurStor^^.SerSpeed<>0 THEN	{ on reconfigure pour un minitel en local }		BEGIN			IF OurStor^^.SerSpeed<>-1 THEN			BEGIN				NbModem := 1;				TheMods[1].ModRef := SerRefOut;				TheMods[1].ModType := SerialLink;				FlagSerial := TRUE;{$IFC Demo=FALSE}				IF EveKey THEN					demoFlag := FALSE;	{ 6/3/95 - DragsterBoot sur Minitel2 }{$ENDC}								IF ourStor^^.SerPort=-1 THEN				BEGIN					NbModem := 2;					TheMods[2].ModRef := SerRefOut2;					TheMods[2].ModType := SerialLink;				END;			END;		END;		FlagMaster := FALSE;	{ pas de modem Dragster en ligne !! }{$ELSEC}		IF Nblocal<2 THEN MyExit(6);	{ pas de modem, ni de clé EvE }{$ENDC}	END;	 	NbHard := NbModem+NbMuxASM+NbMuxASM2+NbLocal;	IF NbHard = 0 THEN MyExit(6);	{ aucune voie !! }	IF NbHard=NBLocal THEN	{ que des voies AppleTalk… on ferme le port série }	BEGIN		IF SerRefIn<>0 THEN Err :=CloseDriver(SerRefIn);		IF SerRefOut<>0 THEN Err :=CloseDriver(SerRefOut);		IF SerRefIn2<>0 THEN Err :=CloseDriver(SerRefIn2);		IF SerRefOut2<>0 THEN Err :=CloseDriver(SerRefOut2);		DrgGlobs.PortAUsed := FALSE;		DrgGlobs.PortBUsed := FALSE;	END;	{$IFC Demo=FALSE}	IF FlagMaster = TRUE THEN	{ un modem maitre Dragster est présent }	BEGIN		ShowMsg(8);		DemoFlag := FALSE;		{--------------------- on verifie l'identite --------------------}   {$IFC Debug}		DebugStr('Verification identite');   {$ENDC}				SnFlag:=False;   		GetIndString(TestSn,259,1);   		MySN:=SNH(GetResource('WINY',256));		HLock(Handle(MySn));   		{-------------------- calcul de coherence sn --------------------}		WITH MySN^^ DO		BEGIN			TSN:=BXOR(TheMask,TheSN);		END;   		TSNT:=0;		FOR i:=0 TO 7 DO			TSNT:=BOR(TSNT,(BSL(BAND(ord(TestSN[5+i]),$0F),28-(i*4))));		SNFlag:=TSNT<>TSN;   		IF SnFlag THEN 		BEGIN{$IFC Debug} DebugStr('Mauvais SNFlag apres coherence'); {$ENDC}		   MyEXIT(8);		END;				{ détection modem maitre }		Err:=WordAlign(SerRefOut,SNFlag,MySN);		IF SnFlag THEN 		BEGIN{$IFC Debug} DebugStr('Mauvais SNFlag apres WordAlign'); {$ENDC}		   MyEXIT(8);		END;				IF OurStor^^.SerPort=-1 THEN	{ deuxième port }		BEGIN		  Err:=WordAlign(SerRefOut2,SNFlag,MySN);		  IF SnFlag THEN 		  BEGIN{$IFC Debug} DebugStr('Mauvais SNFlag apres WordAlign (2)'); {$ENDC}		   	MyEXIT(8);		  END;		END;	END;{$ENDC}	      {---------------------- on choppe la RunTime ---------------------}	ShowMsg(9);	 (* taille de la table de Jump *){$IFC Debug}     DebugStr('Chargement DRJT=256');{$ENDC}	 	 ourRT := GetResource('DRJT',256);     SzRunTime:=SizeResource(ourRT);	 ReleaseResource(OurRT);			 (* taille des RunTimes *){$IFC Debug}     DebugStr('Chargement DRRTs');{$ENDC}	 	 NbRT:=CountResources('DRRT');	 FOR RTidx:=1 TO NbRT DO	 BEGIN     	ourRT := GetIndResource('DRRT',RTidx);     	SzRunTime:=SzRunTime+SizeResource(OurRT);		ReleaseResource(OurRT);	 END;	 TheFPtr:=TPtr(DrgPtr);	{ adresse du bloc de mémoire de Dragster }     ThePtr:=TheFPtr;     TheSPtr:=TheFPtr;     {-------------------- on choppe les serveurs ---------------------}     ShowMsg(10);	 { ===> on veut connaitre le nombre de taches <=== }{$IFC Debug}	 DebugStr('Chargement TSKPs/TSKCs');{$ENDC}	 	 NbTask:=0;     MaxRes:=CountResources('TSKP');     FOR i:=1 TO MaxRes DO	 BEGIN     	 WITH TheServ[i] DO		 BEGIN			TSKPH:=TSKPHdle(GetIndResource('TSKP',i));			HnoPurge(Handle(TSKPH));			TSKCH:=GetResource('TSKC',TSKPH^^.TSKCNumber);			HPurge(Handle(TSKCH));		 END;		{ on reorganise la table par tasknumbers croissants }		j := 1; Termine:=False;		WHILE (j<>i) AND NOT termine DO		BEGIN			Termine := TheServ[i].TSKPH^^.TSKCNumber<TheServ[j].TSKPH^^.TSKCNumber;			IF NOT Termine THEN j := j + 1;		END;		IF j<>i THEN		BEGIN			{ on backup }			TheServ[MaxServDesc]:=TheServ[i];			{ on decale }			BlockMoveData(@TheServ[j],@TheServ[j+1],sizeof(ServDesc)*(i-j));			{ on insere }			TheServ[j]:=TheServ[MaxServDesc];		END;	 END;	 	 { si ADSP indisponible, on retire la tâche ADSP }	 IF NbLocal=0 THEN RemoveTask(1031);	 	 { si la taille zone de communication=0, on ne met pas la	   tache de gestion de base de données }	 IF OurStor^^.DBComSize=0 THEN RemoveTask(1030);			 { si on utilise un seul port, on ne met pas la	   deuxième tache de gestion d'I/O "Dragster" }	 IF (MainDemoFlag=TRUE) | (FlagMaster=FALSE) | (OurStor^^.Serport<>-1) THEN RemoveTask(1026);		 { si on utilise pas de modems Dragster, on retire la tâche d'I/O Dragster }	 IF (MainDemoFlag=TRUE) | (FlagMaster=FALSE) THEN RemoveTask(1024);	 	 { si on n'utilise pas de voies ASM, on retire la tâche d'I/O des voies ASM }	 IF (MainDemoFlag=TRUE) | (NbMuxAsm=0) THEN RemoveTask(1027);	 	 { si on n'utilise pas de voies ASM, on retire la tâche d'I/O des voies ASM }	 IF (MainDemoFlag=TRUE) | (NbMuxAsm2=0) THEN RemoveTask(1028);	 	 FOR i:=1 TO MaxRes DO	 WITH TheServ[i],TSKPH^^ DO	 BEGIN		 PredTask:=NbTask;		 NbTask:=NbTask+TNumber;	 END;	 	 NbServTask:=NbTask;	 NbTask:=NbTask+NbHard+OurStor^^.NbAux;	 	 {-----------------------------------------------------------------	 	    TheSPtr pointe sur le premier Task Control Block				La map memoire va etre la suivante:			TheSPtr	->	*-----------*							!           !	Servers Task Control Blocks							*-----------*							!           !									…			…							!           !							*-----------*							!           !	Normal Task Control Blocks							*-----------*									…			…		ADSP / Serial TCB							!           !							*-----------*							!           !	Auxiliaries Task Control Blocks							*-----------*						BaseIOBuf->	*-----------*							!           !	Serial IO Buffers							*-----------*	InputBuf->	*-----------*							!           !	Input Buffers pool							*-----------*	BaseSpyer->	*-----------*							!           !	Spyer and Bound Checker							*-----------*	BaseSerQ->	*-----------*							!           !	Server Queues							*-----------*	BaseMessQ->	*-----------*							!           !	Inter Task Message Queues							*-----------*	BaseShared->*-----------*							!           !	Shared Variables							*-----------*	BaseCode->	*-----------*							!           !	Compiled Code							*-----------*	BaseRT->	CurStPtr	   = TCB actif                TheStPtr	   = premier TCB                TheLStPtr	   = dernier TCB                TheFSTPtr	   = TCBs libres  ??? inutilisé ???							???? LONGINT							*-----------*  <- MyJump (dans le Driver Dragster)							!           !	Dragster Run Time							*-----------*	BaseRTExt-> *-----------*							!						!	•••• Routines externes ••••							*-----------*		BaseORB->		*-----------*							!           !	Output Ring Buffers ou Buffers de sortie							*-----------*							!           !	Buffers ADSP							*-----------*													!						!	Normal tasks									…			…							!						!							*-----------*							!           !							*-----------*	BaseLoc->		*-----------*	BaseStack->	!           !	Locals, Stack, RW Buffer, DB Buffer	BaseRW->		*-----------*	BaseDB->		!						!	Normal & auxiliary tasks									…			…							!						!							*-----------*							!           !							*-----------*	BaseServer->					For each Type of Server Task					BaseIP->	BaseSCode->		*-----------*   								!           !	Code								*-----------*		BaseSShared->	*-----------*   								!           !	Globals								*-----------*		BaseSLoc->		*-----------*	BaseSStack->	!           !	Locals, Stack, RW Buffer, DB Buffer	BaseSRW->			*-----------*	BaseSDB->			!						!	* TNumber										…			…								!						!								*-----------*								!           !								*-----------*	}			{---------------- Calcul des pointeurs intermediaires --------------}	ShowMsg(11);		Align(Ptr(TheSPtr));		WITH OurStor^^ DO	BEGIN			BaseIOBuf:=Ptr(Ord4(TheSPtr)+Ord4(NbTask)*SizeOf(TRecord));			InputBuf:=Ptr(Ord4(BaseIOBuf)+Ord4(SerBufSz)*2); { deux buffers série, un pour chaque port }				IF InBuffSz<InBuffSzMin THEN	{ 16/7/97 }			InBuffSz := InBuffSzMin;				IF (NbMuxAsm+NbMuxAsm2)>0 THEN			BaseSpyer:=Ptr(Ord4(InputBuf)+Ord4((NbMuxAsm+NbMuxAsm2)*2+InBuffSz)*Ord4(sizeOf(iBuffRec))+Ord4(SizeOf(PBuffRec)))		ELSE			BaseSpyer:=Ptr(Ord4(InputBuf));{$IFC Debug}	DebugStr('Chargement du Spyer');{$ENDC}		HSpyer	:=GetResource('DRGC',256);		IF (HSpyer <> Nil) THEN		BEGIN			Hnopurge(HSpyer);			BaseSerQ:=Ptr(Ord4(BaseSpyer)+ GetHandleSize(HSpyer));			BlockMove(HSpyer^,BaseSpyer,GetHandleSize(HSpyer));			ReleaseResource(HSpyer);			Align(BaseSerQ);			DrgGLobs.SpyerPtr := BaseSpyer;		END		ELSE		BEGIN			BaseSerQ := BaseSpyer;	{ pas de spyer ! }			DrgGlobs.SpyerPtr := NIL;		END;				BaseMessQ:=Ptr(	Ord4(BaseSerQ)+ SizeOf(TQRec));			BaseShared:=Ptr(Ord4(BaseMessQ)+SizeOf(MQRec)+Ord4(MessSize)*(NbHard+NbAux));		Align(BaseShared);				WITH TheXFile DO		BEGIN			BaseCode:=Ptr(Ord4(BaseShared)+SzSVars);			BaseRT:=Ptr(Ord4(BaseCode)+						Ord4(SzOffScreen)+						Ord4(SzNameScreen)+						Ord4(SzStringCsts)+						SzVCode+						SzCode);		END;				BaseRTExt := Ptr(Ord4(BaseRT) + SzRunTime);				{ •••• adresse des routines externes •••• }				BaseORB:=Ptr(Ord4(BaseRTExt)+ SizeExt);						{ •••• Taille des routines externes •••• }		BaseADSP:=Ptr(Ord4(BaseORB)+Ord4(NbHard)*140);		{ •••• Buffers de sortie •••• }				BaseLoc:=Ptr(ORD4(BaseADSP)+ORD4(ORD4(NbMuxASM+NbMuxAsm2+NbLocal+LONGINT(NbLocal>0))*SizeOf(InfoRec)));	{ •••• ADSP •••• }				Align(BaseLoc);				WITH TheXFile DO		BEGIN			BaseStack:=Ptr(Ord4(BaseLoc)+Ord4(SzVars)*(NbHard+NbAux));			Align(BaseStack);			BaseRW:=Ptr(Ord4(BaseStack)+Ord4(SzStack)*(NbHard+NbAux));			Align(BaseRW);		END;				BaseDB:=Ptr(Ord4(BaseRW)+Ord4(RWBSize)*(NbHard+NbAux));		BaseServer:=Ptr(Ord4(BaseDB)+Ord4(DBComSize)*(NbHard+NbAux));		BaseIP:=BaseServer;				FOR i:=1 TO MaxRes DO		WITH TheServ[i] DO		BEGIN				BaseSCode:=BaseIP;						BaseSShared:=Ptr(Ord4(BaseSCode)+SizeResource(Handle(TSKCH)));						WITH TSKPH^^ DO			BEGIN				BaseSLoc:=Ptr(Ord4(BaseSShared)+SzGlobs);				BaseSStack:=Ptr(Ord4(BaseSLoc)+Ord4(SzLocs) * TNumber);				BaseSRW:=Ptr(Ord4(BaseSStack)+Ord4(SzStack) * TNumber);				BaseSDB:=Ptr(Ord4(BaseSRW)+Ord4(NeedsRW) * Ord4(RWBSize) * TNumber);				BaseIP:=Ptr(Ord4(BaseSDB)+Ord4(NeedsDB) * Ord4(DBComSize) * TNumber);			END; { with TSKPH ^^ }		END; { with TheServ[i] }			END; { with OurStor^^ }{$IFC Debug}DebugStr(concatnum('Size=',ord4(BaseIP)-ord4(OrigPtr)));{$ENDC}	IF gHasVM THEN	{ hold de tout sauf du code compilé }	BEGIN{$IFC Debug}		DebugStr('HoldMemory pour mem. virtuelle');{$ENDC}		{ mém. virtuelle: Hold sur les TCB, buffers, Queues, spyer }		Err := HoldMemory(TheSPtr,ORD4(BaseShared)-ORD4(TheSPtr));		{ hold sur: RunTime, Rout. Externes, Output buffers, Buffers ADSP }		{ hold sur buffer RW et DB et les TSKC avec leurs var., pile, buffers… }		IF Err=NoErr THEN Err := HoldMemory(BaseRT,ORD4(GardeFou)-ORD4(BaseRT));{$IFC Debug}		DebugStr('Pb avec HoldMemory');{$ENDC}		IF Err<>NoErr THEN MyExit(14);	{ "Problème avec la mémoire virtuelle" }		DrgGlobs.MemoryHold := TRUE;	END;	{$IFC Debug}	DebugStr('Chargement du code compile');{$ENDC}	ShowMsg(12);		{----------------------- Code compile ----------------------}		{ on copie la table d'offsets }		{ on copie la table de noms }		{ on copie la table de constantes }		{ on copie les ecrans Videotex }		{ on copie le code executable }{$IFC Debug}		WITH TheXFile DO			Count:=	Ord4(SzOffScreen)+					Ord4(SzNameScreen)+					Ord4(SzStringCsts)+					SzVCode+					SzCode;	DebugStr(concatnum('Taille du code: ',count));{$ENDC}		WITH TheXFile DO		BEGIN			Count:=	Ord4(SzOffScreen)+					Ord4(SzNameScreen)+					Ord4(SzStringCsts)+					SzVCode+					SzCode;			Err :=FSRead(RefR,Count,BaseCode);			Err :=FSClose(RefR);			IF XorKey<>0 THEN			BEGIN				i :=	ORD4(BaseCode)+							Ord4(SzOffScreen)+							Ord4(SzNameScreen)+							Ord4(SzStringCsts)+							SzVCode;				j := i;				WHILE i<j + SzCode DO				BEGIN					IntegerPtr(i)^:=BXor(IntegerPtr(i)^,XorKey);					i := i + 2;				END;			END;		END;	{ WITH TheXFile }			ShowMsg(13);	{------------------------ Init chaine de TCBs ---------------------}	TheFPtr:=	TheSPtr;	WITH OurStor^^ DO	FOR i:=1 TO NbTask DO	WITH TheFPtr^ DO	BEGIN		{---- initialisations des données non dependantes des taches ----}		MagicN1		:=	$12345678;		IF i=1 THEN			PredTCB	:=	Nil		ELSE			PredTCB	:=	TPtr(	Ord4(TheFPtr)-SizeOf(TRecord));		IF i<NbTask THEN			NextTCB	:=	TPtr(	Ord4(TheFPtr)+SizeOf(TRecord))		ELSE			NextTCB	:=	Nil;					PtOffScreen	:=	Nil;		PtNameScreen:=	Nil;		PtStringCsts:=	Nil;		PtScreens		:=	Nil;		PtCode			:=	Nil;		PtJump			:=	Nil;		PtSVars			:=	Nil;		PtLVars			:=	Nil;		PtOrgStk		:=	Nil;		TheQueues		:=	TQPtr(BaseSerQ);		TheMQueues	:=	MQPtr(BaseMessQ);		TheAuxBuffPtr:=	Ptr(Ord4(BaseIOBuf)+SerBufSz);		InBuffPool	:=  PBuffPtr(InputBuf);		InBuffEnd		:=	Nil;		InBuffNb		:=	0;		InBuffSt		:=	NIL;		InSilentFlag:=	false;		LocalMode		:=	True;		EchoFlag		:=	True;		OutPutFlag	:=	True;		StatusWord	:=	StartCst;		DelayValue	:=	0;		IOCompFlag	:=	0;		Error				:=	0;		StartTime		:=	0;		MaxTime			:=	60*60*4;		ZoneNumber	:=	0;		RtId				:=	TSN;		NbZones			:=	0;		XCallDatas	:=	'                          ';		(* InBuff		:=	''; *)		WBuffFlag		:=	False;		ConFlag			:=	False;		XConFlag		:=	False;		IsTeletel		:=	False;		RWSz				:=	RWBSize;		RWCount			:=	0;		RWIdx				:=	1;		DBSz				:=	DBComSize;		HardType		:=	0;		OPFlag			:=	0;		TheFPtr^.SerSpeed 	:=	OurStor^^.serSpeed;		Infos				:=	NIL;		RunMode			:=	1;		{ VBL autorisées pour le départ }		RndMemo			:= 	0;		{ 10/2/99 - année pivot pour An 2000 }				FilterFlag	:= False;		TrPrintFlag := False;		    IF (i<=NbHard) THEN		BEGIN			TheFPtr^.SerRefIn	:=	TheMods[i].ModRef+1;    	TheFPtr^.SerRefOut:=	TheMods[i].ModRef;		END		ELSE		BEGIN			TheFPtr^.SerRefIn := SerRefIn;			TheFPtr^.SerRefOut := SerRefOut;		END;			  FOR j:=1 TO MaxFile DO	  WITH TheFiles[j] DO	  BEGIN	      FileRef	:=0;	      FileRLen:=1;	      FilePos	:=0;	  END;		    { TCB suivant }    TheFPtr:=NextTCB;	END; { For i:=1 to NbTask }		{$IFC Debug}	DebugStr('Init des TCB des taches serveur');{$ENDC}	{----------------- Init des TCB des taches serveurs ----------------}	FOR i:=1 TO MaxRes DO	WITH TheServ[i] DO	BEGIN		{---- TheFPtr pointe sur le premier TCB du groupe de taches ----}		TheFPtr:=TPtr(Ord4(TheSPtr)+Ord4(PredTask)*SizeOf(TRecord));							WITH TSKPH^^ DO		FOR j:=1 TO TNumber DO		BEGIN			{---- ThePtr pointe sur le TCB courant ----}			ThePtr:=TPtr(Ord4(TheFPtr)+ Ord4(j-1)*SizeOf(TRecord));			WITH ThePtr^, OurStor^^ DO			BEGIN				{---- on initialise le TCB ----}								{---- pointeurs vitaux ----}				PtCode	:= BaseSCode;				PtJump	:= Ptr(Ord4(BaseRT)+SizeOf(TJumpRec)+4); { utile pour le debogueur spyer }				PtSVars	:= BaseSShared;				PtLVars	:= Ptr(Ord4(BaseSLoc)+Ord4(j-1)*SzLocs);				PtOrgStk:= Ptr(Ord4(BaseSStack)+Ord4(j)*SzStack-4);				RWPtr		:=	RWBPtr(Ord4(BaseSRW)+Ord4(j-1)*RWBSize);				DBPtr		:=	DBBPtr(Ord4(BaseSDB)+Ord4(j-1)*DBComSize);				{---- donnees complementaires ----}				TaskNumber	:= TSKCNumber+j-1;				TaskSNumber	:= j;				TaskPriority:= TPriority;								{---- données particulière pour chaque type de serveur ----}				IF Tasknumber=1027 THEN HardType := TypeASM;		{ type d'ASM pour la tâche d'entrée ASM }				IF Tasknumber=1028 THEN				BEGIN					HardType := TypeASM;		{ type d'ASM pour la tâche d'entrée ASM }					ThePtr^.SerRefIn := SerRefIn2;					ThePtr^.SerRefOut := SerRefOut2;				END;				IF TaskNumber=1031 THEN Infos := InfoPtr(BaseADSP);			END; { with ThePtr^ }		END; { For j:=1 ... }	END; { For i:=1 ... }	{$IFC Debug}	DebugStr('Init TCB des taches');{$ENDC}	{------------------------ Init des TCB des voies --------------------}  FOR j:=1 TO NbHard+OurStor^^.NbAux DO	BEGIN		{---- ThePtr pointe sur le TCB courant ----}		ThePtr:=TPtr(Ord4(TheSPtr)+Ord4(NbServTask+j-1)*SizeOf(TRecord));						WITH ThePtr^, TheXFile, OurStor^^ DO		BEGIN			{---- on initialise le TCB ----}						{---- pointeurs vitaux ----}			PtCode	:=	BaseCode;			PtSVars	:=	BaseShared;			PtLVars	:=	Ptr(Ord4(BaseLoc)+Ord4(j-1)*SzVars);			PtOrgStk:=	Ptr(Ord4(BaseStack)+Ord4(j)*SzStack-4);			RWPtr	:=	RWBPtr(	Ord4(BaseRW)+Ord4(j-1)*RWBSize);			DBPtr	:=	DBBPtr(	Ord4(BaseDB)+Ord4(j-1)*DBComSize);			IF j<=NbHard THEN			BEGIN				{ •••• Def. des buffers de sortie •••• }				OPPtr	:=	OutBufPtr(	Ord4(BaseORB)+Ord4(j-1)*140);				OPPtr^:='';				IF j>NbModem THEN	{ •••• Def. Buffers ADSP & X25 •••• }					Infos := InfoPtr(Ord4(BaseADSP) + Ord4(Ord4(j-NbModem)*SizeOf(InfoRec)));			END;			{---- pointeurs specifiques ----}			PtOffScreen	:=	TPtOffScreen(Ord4(BaseCode));			PtNamescreen:=	TPtNameScreen(										Ord4(BaseCode)+									Ord4(SzOffScreen)							);			PtStringCsts:=	TPtStringCsts(										Ord4(BaseCode)+									Ord4(SzOffScreen)+									Ord4(SzNameScreen)							);			PtScreens:=		Ptr(	Ord4(BaseCode)+									Ord4(SzOffScreen)+									Ord4(SzNameScreen)+									Ord4(SzStringCsts)							);			PtCode:=		Ptr(	Ord4(BaseCode)+									Ord4(SzOffScreen)+									Ord4(SzNameScreen)+									Ord4(SzStringCsts)+									SzVCode							);			PtJump		:=	Ptr(	Ord4(BaseRT)+									SizeOf(TJumpRec)+									4							);						TraceFile := 0;	{ pas de fichier de trace au démarrage }			{---- donnees complementaires ----}			IF j<=NbHard THEN			BEGIN	{ •••• Voies de communication •••• }				TheModem :=	TheMods[j].ModNum;	{ N° de voie du modem }				HardType := TheMods[j].ModType;	{ type de hard de cette voie }				SerRefOut := TheMods[j].ModRef;	{ driver de sortie }				SerRefIn := SerRefOut+1;				{ driver d'entrée }								IF SerRefIn<>SerRefIn2 THEN		{ N° Queue des I/O }					IOQueue := IOQ		{ première queue }				ELSE					IOQueue := IOQ2;	{ deuxième queue }				DemoCount := 0;				IF FlagSerial = TRUE THEN	{ port série }				BEGIN					HardType := SerialLink;{$IFC Demo=FALSE}					IF demoFlag | demoCode THEN democount := 1;	{ version démo }{$ELSEC}					DemoCount := 1;	{ DragsterBootDémo }{$ENDC}				END;								IF j>NbModem+NbMuxASM+NbMuxAsm2 THEN	{ •••• Voie locale ADSP •••• }				BEGIN{$IFC Demo=FALSE}					IF NOT EveKey THEN DemoCount := 1;	{ pas de clé AppleTalk }{$ELSEC}					DemoCount := 1;	{ DragsterBootDémo }{$ENDC}					TheModem := -1;					SerRefIn := ADSPRefNum;					SerRefOut := ADSPRefNum;					HardType := ADSPLink;					IF NbLocal=256-Nblocal2 THEN DemoCount := 1;				END;				TaskNumber	:=	j;				TaskSNumber	:=	j;				TaskPriority:=	40;							END			ELSE			BEGIN	{ •••• Tâches annexes •••• }				TheModem	:=	0;				HardType	:= 0;				TaskNumber	:=	255-NbHard+j;				TaskSNumber	:=	255-NbHard+j;				TaskPriority:=	60;			END;						{---- protection ----}			ProtCount:=2000 - abs(TickCount) MOD 700;			{$IFC Debug}DebugStr(concatnum('DemoCount=',DemoCount));DebugStr(concatnum('HardType=',HardType));{$ENDC}		END; { with ThePtr^ }			END; { For j:=1 ... }			 {$IFC Debug}	DebugStr('Copie des codes et init des datas');{$ENDC}	ShowMsg(14);	 	{-------- copie des codes et init des zones de donnees --------}		TheFPtr:=TheSPtr;		WHILE TheFPtr<>Nil DO		WITH TheFPtr^ DO		BEGIN					{---- si tache annexe, i contient l'indice dans TheServ ----}{$IFC Debug2}	DebugStr(Concatnum('Tache No: ',TaskNumber));{$ENDC}			IF TaskNumber>1000 THEN			BEGIN{$IFC Debug2}	DebugStr('Recherche tache > 1000');{$ENDC}				{ on trouve la tache correspondante }				i:=0; termine:=false;				WHILE (i<MaxRes) AND (NOT termine) DO				BEGIN					i:=i+1;					WITH TheServ[i].TSKPH^^ DO						Termine:=	(TaskNumber>=TSKCNumber) AND									(TaskNumber<TSKCNumber+TNumber);				END;			END; { If TaskSNumber>1000 }						{----				  on ne copie le code que sur la premiere occurence			      d'un groupe de tache.				  ainsi que pour l'initialisation des shared			----}			IF TaskSNumber=1 THEN			BEGIN				{---- copie du code ----}{$IFC Debug2}	DebugStr('Copie du code');{$ENDC}				IF TaskNumber>1000 THEN				BEGIN					WITH TheServ[i] DO					BEGIN						{ on loade le code }						LoadResource(Handle(TSKCH));						{ on copie le code }        		BlockMove(TSKCH^, PtCode, SizeResource(Handle(TSKCH)));						{ on le vire de la memoire }						ReleaseResource(Handle(TSKCH));					END;				END;								TestGardeFou;				{$IFC Debug2}	DebugStr('Init des Shared');{$ENDC}				{---- init des shared ----}				StartPtr:=PtSVars;				IF TaskNumber>1000 THEN					EndPtr:=Ptr(	Ord4(StartPtr)+									TheServ[i].TSKPH^^.SzGlobs								)				ELSE					EndPtr:=Ptr(	Ord4(StartPtr)+									TheXFile.SzSVars								);				WHILE StartPtr<>EndPtr DO					BEGIN						StartPtr^:=0;						StartPtr:=Ptr(Ord4(StartPtr)+1);					END;							END; { If TaskSNumber=1 }						TestGardeFou;			        	{---- on skippe le pointeur TCB ----}			IF TaskNumber>1000 THEN        		PtCode:=Ptr(Ord4(PtCode)+4);						{$IFC Debug2}	DebugStr('Init des locales');{$ENDC}			{---- init des locales ----}							{ on met a zero la zone de variables }			StartPtr:=PtLVars;			IF TaskNumber>1000 THEN				EndPtr:=Ptr(	Ord4(StartPtr)+								TheServ[i].TSKPH^^.SzLocs							)			ELSE				EndPtr:=Ptr(	Ord4(StartPtr)+								TheXFile.SzVars							);			WHILE StartPtr<>EndPtr DO				BEGIN					StartPtr^:=0;					StartPtr:=Ptr(Ord4(StartPtr)+1);				END;			TestGardeFou;				{$IFC Debug2}	DebugStr('Init des Stack');{$ENDC}			{---- init des stack ----}    		{ on met a zero la zone de pile }			IF TaskNumber>1000 THEN				WITH TheServ[i].TSKPH^^ DO				BEGIN					StartPtr:=Ptr(Ord4(PtOrgStk)-SzStack+4);					EndPtr:=Ptr(	Ord4(StartPtr)+									SzStack								)				END			ELSE				WITH TheXFile DO				BEGIN					StartPtr:=Ptr(Ord4(PtOrgStk)-SzStack+4);					EndPtr:=Ptr(	Ord4(StartPtr)+									SzStack								);				END;			WHILE StartPtr<>EndPtr DO				BEGIN					StartPtr^:=0;					StartPtr:=Ptr(Ord4(StartPtr)+1);				END;			TestGardeFou;			{ on passe au suivant }			ThePtr:=TheFPtr;			TheFPtr:=NextTCB;					END; { With TheFPtr^ }	{$IFC Debug}	DebugStr('Init des queues');{$ENDC}		{------------------------ init des queues --------------------}		{ init des queues internes }		FOR i := 0 TO MaxQueues DO		WITH TQPtr(BaseSerQ)^[i] DO		BEGIN			QOwner := NIL;	{ sera rempli par le TSKC correspondant }			QFirst := NIL;			QEnd := NIL;			QNumber := 0;		END;				{ on mets les queues de message a jour }		WITH OurStor^^ DO		BEGIN		  FOR i:=1 TO NbHard DO		  WITH MQPtr(BaseMessQ)^[i] DO		  BEGIN			MFirst:=0;			MFree:=0;			MNb:=0;			MMax:=MessSize;			MPtr:=MXQPtr(	Ord4(BaseMessQ)+							SizeOf(MQRec)+							ord4(MessSize)*Ord4(i-1)						);		  END;		  		  FOR i:=NbHard+1 TO MaxTasks DO		  WITH MQPtr(BaseMessQ)^[i] DO		  BEGIN				MFirst:=0;				MFree:=0;				MNb:=0;				MMax:=MessSize;				MPtr:=Nil;		  END;		  		  FOR i:=1 TO NbAux DO		  WITH MQPtr(BaseMessQ)^[MaxTasks+i] DO		  BEGIN				MFirst:=0;				MFree:=0;				MNb:=0;				MMax:=MessSize;				MPtr:=MXQPtr(	Ord4(BaseMessQ)+								SizeOf(MQRec)+								Ord4(MessSize)*Ord4(NbHard+i-1)							);		  END;		  		  FOR i:=NbAux+1 TO MaxAux DO		  WITH MQPtr(BaseMessQ)^[MaxTasks+i] DO		  BEGIN				MFirst:=0;				MFree:=0;				MNb:=0;				MMax:=MessSize;				MPtr:=Nil;		  END;		  		END; { With OurStor^^ }		TestGardeFou;{$IFC Debug}	DebugStr('Mise a jour offset des ecrans');{$ENDC}		{------------- on mets les offsets écran a jour ---------------}		NbOff:=(Ord4(TheXFile.SzOffScreen) DIV 8)-1;		  FOR i:=0 TO NbOff DO			WITH TPtOffScreen(BaseCode)^[i], TheXFile DO			BEGIN				OffCode:=	OffCode+						 	Ord4(BaseCode)+							Ord4(SzOffScreen)+							Ord4(SzNameScreen)+							Ord4(SzStringCsts)+							SzVCode;				OffVCode:=	OffVCode+						 	Ord4(BaseCode)+							Ord4(SzOffScreen)+							Ord4(SzNameScreen)+							Ord4(SzStringCsts);			END;			TestGardeFou;	  {$IFC DEBUG}	DebugStr('Copie de la runtime');{$ENDC}	ShowMsg(15);		{--------------------- on copie la RunTime ------------------}				BaseRTx:=BaseRT;			 	(* taille de la table de Jump *)     	ourRT := GetResource('DRJT',256);		BlockMove(Ptr(Ord4(OurRT^)),BaseRTx,SizeResource(ourRT));		BaseRTx:=Ptr(Ord4(BaseRTx)+SizeResource(ourRT));	 	ReleaseResource(OurRT);	 	(* taille des RunTimes *)	 	NbRT:=CountResources('DRRT');	 	FOR RTidx:=1 TO NbRT DO	 	BEGIN     		ourRT := GetIndResource('DRRT',RTidx);			BlockMove(Ptr(Ord4(OurRT^)),BaseRTx,SizeResource(ourRT));			{ on init la Unit de cette Run Time }			MonCallProc(Ptr(Ord4(BaseRT)+SizeOf(TJumpRec)),BaseRTx);			BaseRTx:=Ptr(Ord4(BaseRTx)+SizeResource(ourRT));			ReleaseResource(OurRT);	 	END;			TestGardeFou;	  {$IFC Debug}	DebugStr('Chargement des DEXT');{$ENDC}	ShowMsg(16);		{ •••• Chargement des routines externes •••• }				AddExternals;		IF ResFile <> AppRefNum THEN CloseResfile(ResFile);			TestGardeFou;	  {$IFC Debug}	DebugStr('Init buffer série');{$ENDC}		{----------------- on prepare le buffer d'io ----------------}  Err:=SerSetBuf(SerRefIn,BaseIOBuf,SerBufSz);		  IF OurStor^^.Serport = -1 THEN		Err:=SerSetBuf(SerRefIn2,Ptr(Ord4(BaseIOBuf)+SerBufSz),SerBufSz);		{ on prend le buffer du deuxieme port }	IF NbMuxASM > 0 THEN	BEGIN		TestGardeFou;	  {$IFC Debug}DebugStr('Init pool de buffers ASM');{$ENDC}		{----------------- on prepare le pool d'input buffers ----------------}		TheIPool:=PBuffPtr(InputBuf);		TheIPool^.Link:=iBuffPtr(Ord4(TheIPool)+4);		TheIBuff:=TheIPool^.Link;		WITH OurStor^^ DO		FOR i:=1 TO (NbMuxASM+NbMuxASM2)*2+InBuffSz-1 DO		BEGIN			TheIBuff^.Link:=iBuffPtr(Ord4(TheIBuff)+ord4(SizeOf(iBuffRec)));			TheIBuff:=TheIBuff^.Link;		END;		TheIBuff^.Link:=Nil;	END;	TestGardeFou;{$IFC Debug}	DebugStr('Init pointeurs RunTime');{$ENDC}		{---------- initialiser les pointeurs de la RunTime ----------}		TheJPtr:=TJumpPtr(BaseRT);		WITH TheJPtr^ DO		BEGIN			CurStPtr:=Nil;			TheStPtr:=TheSPtr;			TheLStPtr:=ThePtr;			TheFStPtr:=Nil;		END;	TestGardeFou;	  {$IFC Debug}	DebugStr('Init table de priorite');{$ENDC}		{------ on choppe le pointeur sur la table de priorités --------}		WITH pb DO		BEGIN			ioRefNum:=TheDrvRef;			csCode:=252;			csParam:=@TheTPT;		END;		Err:=PbStatus(@Pb,False);		IF Err<>0 THEN MyExit(Err);				{------ on construit la table de priorité --------}		FOR i:=0 TO 255 DO		WITH TheTPT^[i] DO		BEGIN			PredPTY	:=	-1;			NextPTY	:=	-1;			LastTCB	:=	Nil;		END;		ThePtr	:=	TheSPtr;		WHILE ThePtr<>Nil DO		BEGIN			WITH TheTPT^[ThePtr^.TaskPriority] DO			BEGIN				LastTCB:=ThePtr;			END;			ThePtr	:=	ThePtr^.NextTCB;		END;		{ mise a jour de la liste dans un sens }		PPty:=-1;				FOR i:=0 TO 255 DO		WITH TheTPT^[i] DO		BEGIN			IF LastTCB<>Nil THEN			BEGIN				PredPTY	:=	PPty;				PPty	:=	i;			END;		END;		{ mise a jour de la liste dans l'autre sens }		NPty:=-1;		FOR i:=255 DOWNTO 0 DO		WITH TheTPT^[i] DO		BEGIN			IF LastTCB<>Nil THEN			BEGIN				NextPTY	:=	NPty;				NPty	:=	i;			END;		END;				{----------------- on initialise les datas d'ADSP ----------------}	TestGardeFou;	  {$IFC Debug}	DebugStr('Init des datas d''ADSP');{$ENDC}	IF NbLocal>0 THEN	BEGIN		ShowMsg(17);		TempStr2 := '';		theRes := Handle(GetString(128));		IF theRes<>NIL THEN TempStr2:=StringHandle(theRes)^^;	{ Type pour NBP = STR 128 }		IF TempStr2 = '' THEN TempStr2 := 'ADSP';		TempStr:='';		theRes := Handle(GetString(-16413));	{ Nom du Mac }		IF theRes=NIL THEN theRes := Handle(GetString(-16096));	{ Nom de l'utilisateur }		IF theRes<>NIL THEN TempStr := StringHandle(theRes)^^;		IF TempStr='' THEN TempStr := 'Dragster';		FOR i := 1 TO MaxRes DO		IF (TheServ[i].TSKPH<>NIL)		 & (TheServ[i].TSKPH^ <> NIL)		 & (TheServ[i].TSKPH^^.QNumber=ADSPQ) THEN		BEGIN			NBPSetNTE(TheServ[i].BaseSShared,TempStr,TempStr2,'*',0);	{ pour PRegisterName ! }			NBPSetEntity(@DrgGlobs.NBPData,TempStr,TempStr2,'*');			Leave;		END;				WITH InfoPtr(BaseADSP)^ DO			DrgGlobs.ADSPData[0]:=@PB.ADSPPB;	{ Adresse du Connection Listener… }				FOR i := 1 TO NbLocal DO		BEGIN			ADSPDatas := InfoPtr(ORD4(BaseADSP)+ORD4(NbMuxASM+NbMuxASM2+i)*SizeOf(InfoRec));{			IF (NbLocal=BXOR(BSR(BAND(1024*63,NbLocal2),10),37)) | (NbLocal2=256-NbLocal) THEN }			IF (NbLocal2=0) | (NbLocal2=256-NbLocal) THEN			WITH ADSPDatas^ DO			BEGIN				{ Init du CCB, il nous faut le N° de socket pour NBP }				WITH PB.ADSPPB DO				BEGIN					ioCRefNum := ADSPRefNum;		{ADSP driver ref num}					csCode := dspInit;					ccbPtr := @theCCB;				{pointer to CCB}					userRoutine := NIL;				{no user routine}					sendQSize := DSPSendSize;		{size of send queue}					sendQueue := @SendBuff;			{send-queue buffer}					recvQSize := DSPRecvSize;		{size of receive queue}					recvQueue := @RecvBuff;			{receive-queue buffer}					attnPtr := @AttnBuff;			{receive-attention buffer}					localSocket := 0;				{let ADSP assign socket}				END;				Err := PBControl(@PB.ADSPPB, FALSE);	{establish a connection}{$IFC DEBUG}				IF Err <> NoERR THEN DebugStr(concatnum('dspInit, Err:',Err));{$ENDC}				DrgGlobs.ADSPData[i]:=@PB.ADSPPB;	{ conserve un pointeur sur datas d'ADSP }			END;		END;	END;	{ déchargeons ce qui n'est plus nécessaire de garder en mémoire }	FOR i := 1 TO MaxRes DO ReleaseResource(Handle(theServ[i].TSKPH));		ShowMsg(18);	TestGardeFou;	  {$IFC Debug}	DebugStr('Activation du Spyer');{$ENDC}	{----------------- on demarre le spyer ----------------}	{ on demarre le spyer }	{ HSpyer:=GetResource('TIME',256); }	{ DebugStr('Avant Spyer Start'); }	IF BaseSpyer <> BaseSerQ THEN		MySpyerStart(BaseSpyer,TheSPtr,Ptr(Ord4(BaseRT)));	{ DebugStr('Apres Spyer Start'); }	{ ReleaseResource(HSpyer); }			{------ on donne la version du système au Driver -------}	WITH pb DO	BEGIN		ioRefNum:=TheDrvRef;		csCode:=252;		csParam:=@i;	{ LONGINT }	END;	Err:=PbStatus(@Pb,False);	IF Err<>0 THEN MyExit(Err);	i := i-6;	LongIntPtr(i)^:=Longint(gHasVM);	{ mém. virtuelle: flag pour le Driver }		{------ on lui donne le pointeur sur la table de jump -------}	WITH pb DO	BEGIN		ioRefNum:=TheDrvRef;		csCode:=255;		csParam:=Ptr(Ord4(BaseRT)+SizeOf(TJumpRec)+4);		DrgGlobs.JumpTable := Ptr(Ord4(BaseRT)+SizeOf(TJumpRec)+4);	END;	TestGardeFou;	  {$IFC Debug}	DebugStr('Avant init drvr');{$ENDC}	Err:=PbStatus(@Pb,False);	IF Err<>0 THEN MyExit(Err);	TestGardeFou;	  {$IFC Debug}	DebugStr('apres init drvr');{$ENDC}	{------ on choppe le pointeur sur la table de jump --------}	WITH pb DO	BEGIN		ioRefNum:=TheDrvRef;		csCode:=254;		csParam:=@TheLJump;	END;	TestGardeFou;	  {$IFC Debug}	DebugStr('Avant init drvr 2');{$ENDC}	Err:=PbStatus(@Pb,False);	IF Err<>0 THEN MyExit(Err);	TestGardeFou;	  {$IFC Debug}	DebugStr('apres init drvr 2');	DebugStr('Fin de InitProc2');{$ENDC}	{ mise à jour de DrgGlobs }	DrgGlobs.DrvrRef := theDrvRef;	{ refnum du Driver de Dragster }		{ récupération du premier TCB }	WITH pb DO	BEGIN		ioRefNum:=TheDrvRef;		csCode:=251;		csParam:=@DrgGlobs.FirstTCB;	END;	Err:=PbStatus(@Pb,False);	IF Err<>0 THEN DrgGlobs.FirstTCB:=NIL;		DrgGlobs.Started := TRUE;	END;    { Init2Proc }END.