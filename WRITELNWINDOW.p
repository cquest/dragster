UNIT WriteLnWindow;{$M+}{$X-}{$SETC qWWdebug := FALSE}INTERFACE{$L-}USES    {$U-}    {$U obj/MemTypes}	    MemTypes,    {$U obj/QuickDraw}	    QuickDraw,    {$U obj/OSIntf}	    OSIntf,    {$U obj/ToolIntf}	    ToolIntf,    {$U Obj/PackIntf}  PackIntf,    {$U obj/PasLibIntf}	    PasLibIntf;{$L+}CONST    kWWEol = CHR($0D);VAR gDebugWindowPtr:    WindowPtr;{All public procedure begin with WW (for WritelnWindow)}PROCEDURE WWInit;    {Call this once at the start of your program.}PROCEDURE WWNew(bounds: Rect; windowTitle: Str255; goAway: BOOLEAN; visible: BOOLEAN;                linesToSave, outputFont, outputSize: INTEGER);    {Call this to create a WriteLn xyzafWindow with given title.        goAway is TRUE iff you want a go away box (IF the user clicks the go away box,            the xyzafWindow will be hidden but not freed);        visible is TRUE iff you want the xyzafWindow to be visible initially;        linesToSave is number of lines to save;        outputFont & output size define the font to use        }    {Call the following procedures in response to events for the WriteLnWindow.        (Test the xyzafWindow receiving the event against gDebugWindowPtr.}PROCEDURE WWIdle; { Cursor Idle }PROCEDURE WWActivateEvent(activate: BOOLEAN);PROCEDURE WWMouseDown(where: INTEGER; pt: Point; modifiers: INTEGER);PROCEDURE WWUpdateEvent;PROCEDURE WWriteStr(TheStr: Str255);PROCEDURE WWriteNum(NumToWrite: longint; TheLength: integer);PROCEDURE WWlnStr(TheStr: Str255);PROCEDURE WWlnNum(NumToWrite: longint; TheLength: integer);PROCEDURE WWriteCh(TheChr: Char);IMPLEMENTATION{$I WritelnWindow2.p}END.