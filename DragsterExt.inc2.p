(*	Fichier:	DragsterExt.inc.p	Contenu:	Définitions des callBack à utiliser dans les routines externes de						Dragster (à partir de la version 1.93) mode compilé.	Ecrit par:	Christian QUEST	Copyright:	1991 JCA Télématique / Ch. QUEST	Historique:				27/05/92	CQ		Suppression de l'utilisation de $A78. L'adresse de la												JumpTable se trouve sur la pile (dernier paramètre).												Modif. du compilateur pour que celui-ci mette cette												adresse sur la pile avant d'appeler l'externe												MOVE.L A3,-(A7)				21/05/92	CQ		Version utilisant $A78 à la place de A5												pour compatibilité en interpretté.				15/08/91	CQ		Première ébauche des callbacks de Dragster*){ INLINES…		205F = MOVE.L (A7)+,A0		4EA8 xxxx = JSR xxxx(A0)		700x = MOVEQ x,D0		203C xxxx xxxx = MOVE.L xxxxxxxx,D0	Remarques:	=========	Les routines suivies de <comp> ne sont disponibles qu'en mode compilé.	Les autres routines sont utilisables dans les deux modes.}{ ••••• Instructions d'affichage et de présentation ••••• }	PROCEDURE Drg_PrintChar (theChar: CHAR; JT:Ptr);	INLINE		$205F, $4EA8, $000C;	PROCEDURE Drg_PrintNum (theNum: LONGINT; JT:Ptr);	INLINE		$205F, $4EA8, $0012;	PROCEDURE Drg_PrintStr (theStr: Str255; JT:Ptr);	INLINE		$205F, $4EA8, $0018;	PROCEDURE Drg_PrintScreen (theStr: Str255; JT:Ptr);	INLINE		$205F, $4EA8, $034E;	PROCEDURE Drg_Message(Ligne, Colonne, Tempo: LONGINT; theStr: Str255; JT:Ptr);	INLINE		$205F, $4EA8, $01D4;	{ ••••• Gestion des saisies ••••• }	PROCEDURE Drg_ResetZones(JT:Ptr);	INLINE		$205F, $4EA8, $015C;			PROCEDURE Drg_Zone(ZPosX, ZPosY, ZLen: Longint; TheVar: Ptr; ZTkVar: Integer; TheColor: Longint; JT:Ptr);	INLINE		$205F, $4EA8, $01CE;			PROCEDURE Drg_Wait(zoneNum:INTEGER; JT:Ptr);	INLINE		$205F, $4EA8, $01BC;		PROCEDURE Drg_Input(VAR str:Str255; JT:Ptr);	INLINE		$205F, $4EA8, $0036;	{ ••••• Gestion du temps et multi-tâche ••••• }	CONST		MaxZones = 40;		{ nombre maxi de zones }		MaxFile = 12;			{ nombre maxi de fichiers }	TYPE		FRecord = RECORD				FileRef: Integer;      	{ Numero de reference interne du fichier }				FileRLen: Integer;      { Longueur d'un record (acces dir) }				FilePos: Longint;      	{ Prochaine pos à lire, ou record courant }				BaseFlag: Boolean;			{ base ou fichier ? }			END;		RSZone = RECORD			{ définition d'une ZONE }				PosX, PosY, Len: Integer;				TkVar: Integer;	{ type de variable (Alpha ou Num ?) }				AdVar: Ptr;			{ Ptr vers la variable }				Color: Integer;			END;		TCBPtr = ^TCBRec;		TCBRec = RECORD				Reserv1: Longint;							{ tjrs = $12345678 }				NextTCB: TCBPtr;	        		{ prochain TCB dans la liste }				PredTCB: TCBPtr;							{	TCB précédent }				PtOffScreen: Ptr;					 		{ offset des codes + videotex}				PtNameScreen: Ptr;						{ noms des ecrans}				PtStringCsts: Ptr;						{ Ptr vers constantes chaine}				PtSVars: Ptr;		        			{ Ptr variables shared }				PtLVars: Ptr;	       					{ Ptr variables locales }				PtCode: Ptr;									{ Ptr code application }				PtScreens: Ptr;								{ Ptr écrans Videotex }				PtJump: Ptr;	        				{ jump table Run Time }				PtOrgStk: Ptr;								{ pile de départ }				TheNScreen: Longint;					{ Numero ecran courant}				TheVScreen: Ptr;	        		{ Ecran VideoTex Courant}				TheQueues: Ptr;        				{ Queues des serveurs }				TheMQueues: Ptr; 		    	   	{ Queues des messages }				TheAuxBuffPtr: Ptr;          	{ Buffer serial port }				TheModem: Integer;      			{ Numero du modem associé }				SerRefIn: integer;						{ RefNum Driver In  }				SerRefOut: Integer;     		 	{ RefNum Driver Out }				StatusWord: Integer;    	  	(* état de la tâche																											 0: ready																											 1: waiting delay																											 2: waiting IOCompletion																											 3: waiting IOCompletion with TimeOut																											 4: waiting char																											 5: waiting char with TimeOut																											 6: pending for mailbox																											 7: pending for mailbox with TimeOut																											 8: pending for string																											 9: pending for string with TimeOut																											10: waiting network response																											11: waiting network response with TimeOut																											12: waiting for OutPut allowing																											14: waiting for Start																									*)				DelayValue: Longint;				{ Nombre de Ticks à attendre }				IOCompFlag: Integer;      	{ 0: IO terminée, 1: IO en cours }				Error: Integer;      				{ Code d'Erreur }				PendAdr: Ptr;	        			{ Var Adress for pend }				PendStr: Longint;      			{ Str Pattern to wait }				StartTime: Longint;     	 	{ 'secs' à la connexion }				MaxTime: Longint;      			{ TimeOut }				ZoneNumber: Integer;      	{ Zone de sortie du Wait}				TaskNumber: Integer;      	{ Numero de la tache/voie logique}				TaskPriority: Integer;      { Priorité de la tache }				TheNLine: Integer;					{ Numero de ligne dans le module }				TheNInst: Integer;					{ Numero d'intruction dans la ligne }				LocalMode: Boolean;      		{ mode local ou non }				EchoFlag: Boolean;      		{ echo ou non }				OutPutFlag: Boolean;				FrOutPut: Boolean;					{ vrai si FrontScreen en cours }				StarFlag: Boolean;      		{ si * seule en saisie }				StoppedFlag: Boolean;				{ vrai si la tache a été arrêtée }				TaskSNumber: Integer;				HardType: Integer;					{ Type de HardWare }				OPFlag: Integer;				OPFirst: Integer;				Infos: Ptr;							{ pointeur vers infos supplémentaires }				OPPtr: Ptr;									{ pointeur vers buffer de sortie }				RegArea: ARRAY[0..16] OF Ptr; 	{ registres tache background }				RegAreaF: ARRAY[0..16] OF Ptr; 	{ registres tache principale }				NbZones: Integer;      			{ Nb Zones de saisie }				TheZones: ARRAY[1..MaxZones] OF RSZone;				Res2: Longint;				Res3: Integer;				Res4: Integer;				XCallDatas: STRING[26]; 		{ données d'appel Transpac }				Res5: LONGINT;				Res6: Ptr;				Res7: Ptr;				Res8: Integer;				Res9: Integer;				Res10: Boolean;				Res11: Boolean;				ConFlag: Boolean;      			{ valide si voie connectée }				XConFlag: Boolean;				Res12: Integer;				FilterFlag: boolean;				{ vrai si FILTER }				TrPrintFlag: boolean;				{ print "transparent" ? }				RWSz: Integer;							{ Taille buffer Read/Write des fichiers }				RWPtr: Ptr;									{ Pointer sur Buffer Read/Write }				RWCount: Integer;						{ nb octets lus/écrits }				RWIdx: Integer;							{ Index dans RW buffer 1..RWSz }				DBPtr: Ptr;									{ Pointer to data base Buffer }				DBSz: Longint;							{ Data Base com area size }				DBCount: Longint;						{ com area actual size }				DBRef: Longint;							{ record reference }				DBIdx: Longint;							{ com area actual index }				IOQueue: Integer;						{ N° Queue pour I/O }				RndMemo: Longint;						{ random seed 1 }				RndCount: Longint;					{ random seed 2 }				Res13: Longint;				Res14: Ptr;				TheFiles: ARRAY[1..MaxFile] OF FRecord;		{ tableau des fichiers de la tâche }			END;	FUNCTION Drg_GetTCB(JT:Ptr): TCBPtr;	INLINE		$205F, $4EA8, $0060;	PROCEDURE Drg_Delay(Delay: LONGINT; JT:Ptr);	INLINE		$205F, $4EA8, $00BA;	PROCEDURE Drg_YieldCpu(JT:Ptr);	INLINE		$205F, $4EA8, $02D0;	FUNCTION Drg_RunFlags(JT:Ptr): Str255;	INLINE		$205F, $4EA8, $0420;{ ••••• Gestion des fichiers ••••• }	TYPE		MyParamBlockRec = RECORD				TCB: TCBPtr;				PB: ParamBlockRec;			END;		MyParamBlockPtr = ^MyParamBlockRec;		MyHParamBlockRec = RECORD				TCB: TCBPtr;				HPB: HParamBlockRec;			END;		MyHParamBlockPtr = ^MyHParamBlockRec;	PROCEDURE Drg_Open (NumLog: LONGINT; Nom: Str255; JT:Ptr);		{ <comp> }	INLINE		$205F, $4EA8, $014A;	PROCEDURE Drg_OpenRF (NumLog: LONGINT; Nom: Str255; JT:Ptr);		{ <comp> }	INLINE		$205F, $4EA8, $0426;	PROCEDURE Drg_Close (NumLog: LONGINT; JT:Ptr);		{ <comp> }	INLINE		$205F, $4EA8, $009C;	FUNCTION Drg_FSRead (NumLog: LONGINT; VAR count: LONGINT; Buffer: Ptr; JT:Ptr): OsErr;		{ <comp> }	INLINE		$7001, $205F, $4EA8, $0066;	FUNCTION Drg_FSWrite (NumLog: LONGINT; VAR count: LONGINT; Buffer: Ptr; JT:Ptr): OsErr;		{ <comp> }	INLINE		$7002, $205F, $4EA8, $0066;	FUNCTION Drg_Error(JT:Ptr): LONGINT;		{ <comp> }	INLINE		$205F, $4EA8, $00E4;	FUNCTION Drg_EOF (NumLog: LONGINT; JT:Ptr): LONGINT;		{ <comp> }	INLINE		$205F, $4EA8, $00DE;	FUNCTION Drg_GetEOF (NumLog: LONGINT; JT:Ptr): LONGINT;		{ <comp> }	INLINE		$205F, $4EA8, $0108;	PROCEDURE Drg_SetEOF (NumLog, LogEof: LONGINT; JT:Ptr);		{ <comp> }	INLINE		$205F, $4EA8, $017A;	FUNCTION Drg_FPos (NumLog: LONGINT; JT:Ptr): LONGINT;		{ <comp> }	INLINE		$205F, $4EA8, $0102;	PROCEDURE Drg_Seek (NumLog, Pos: LONGINT; JT:Ptr);		{ <comp> }	INLINE		$205F, $4EA8, $0174;	PROCEDURE Drg_RLen (NumLog, RecLen: LONGINT; JT:Ptr);		{ <comp> }	INLINE		$205F, $4EA8, $0168;	PROCEDURE Drg_RSeek (NumLog, NumRec: LONGINT; JT:Ptr);		{ <comp> }	INLINE		$205F, $4EA8, $016E;	PROCEDURE Drg_Create (Nom: Str255; JT:Ptr);		{ <comp> }	INLINE		$205F, $4EA8, $00A8;	PROCEDURE Drg_Kill (Nom: Str255; JT:Ptr);		{ <comp> }	INLINE		$205F, $4EA8, $011A;	PROCEDURE Drg_Rename (ancien, nouveau: Str255; JT:Ptr);		{ <comp> }	INLINE		$205F, $4EA8, $0156;	PROCEDURE Drg_Lock (NumLog: LONGINT; JT:Ptr);		{ <comp> }	INLINE		$205F, $4EA8, $0288;	PROCEDURE Drg_Unlock (NumLog: LONGINT; JT:Ptr);		{ <comp> }	INLINE		$205F, $4EA8, $028E;	PROCEDURE Drg_GetFile (VAR NomFicDos: Str255; NomDoss: Str255; Index: LONGINT; JT:Ptr);		{ <comp> }	INLINE		$205F, $4EA8, $032A;	PROCEDURE Drg_NewFolder (Nom: Str255; JT:Ptr);		{ <comp> }	INLINE		$205F, $4EA8, $039C;	PROCEDURE Drg_GetFInfo (Nom: Str255; VAR TypeCreat: Str255; VAR DataSz, RsrcSz, DateCr, DateMod: LONGINT; JT:Ptr);		{ <comp> }	INLINE		$205F, $4EA8, $03A2;	PROCEDURE Drg_SetFinfo (Nom: Str255; TypeCreate: Str255; JT:Ptr);		{ <comp> }	INLINE		$205F, $4EA8, $03A8;	PROCEDURE Drg_GetVol (VAR NomVol: Str255; Index: LONGINT; JT:Ptr);		{ <comp> }	INLINE		$205F, $4EA8, $03AE;	FUNCTION Drg_PBCall (theCall: INTEGER; thePB: MyParamBlockPtr; JT:Ptr): OsErr;	INLINE		$7003, $205F, $4EA8, $0066;	FUNCTION Drg_PBHCall (theCall: INTEGER; thePB: MyHParamBlockPtr; JT:Ptr): OsErr;	INLINE		$7004, $205F, $4EA8, $0066;	CONST     { requêtes du serveur de fichier }		ReqOpen = 1;	        { demande d'Open }		ReqClose = 2;	        { demande de Close }		ReqRename = 3;	      { demande de Rename† }		ReqDelete = 4;	      { demande de Delete† }		ReqRead = 5;	        { demande de Read }		ReqWrite = 6;	        { demande de Write }		ReqGetEof = 7;	      { demande de GetEof }		ReqSetEof = 8;	      { demande de SetEof }		ReqLock = 9;	        { demande de Lock }		ReqUnlock = 10;	      { demande de Unlock }		ReqCreate = 11;	      { demande de Create }		ReqGetFInfo = 12;	    { demande de GetFInfo† }		ReqSetFInfo = 13;	    { demande de SetFInfo† }		ReqOpWd = 14;					{ demande de OpenWD° }		ReqClWd = 15;					{ demande de CloseWD° }		ReqGetCat = 16;				{ demande de GetCatInfo }		ReqOpRsrc = 17;				{ demande de Open resource fork }		ReqDirCreate = 18;		{ demande de Creation de Folder }		ReqFlush = 19;				{ demande de FlushVol }		ReqNameOfId = 20;			{ demande de nom courant }		ReqGetVol =  21;			{ demande de GetVol }		ReqSetVol =  22;			{ demande de SetVol }		ReqGetVInfo =	23;			{ demande de GetVInfo }		ReqCatMove = 24;			{ demande de PBCatMove }				{ † PBHCall  }		{	° PBWDCall }	PROCEDURE Drg_SetRunMode (NewMode: INTEGER; JT:Ptr);		INLINE		$7005, $205F, $4EA8, $0066;		{ MOVE.L #5,D0 / MOVE.L (A7)+,A0 / JSR $66(A0) }			CONST		kNoInterrupt = 0;		kInterrupt = 1;		{ Appels à DragsterBoot… }{ allocation d'un Handle par DragsterBoot }FUNCTION Drg_NewHandle(size:LONGINT; JT:Ptr):Handle;INLINE	$203C, $0000, $0100, $205F, $4EA8, $0066;{ enregistrement de datas par DragsterBoot }FUNCTION Drg_StoreData(dataPtr:Ptr; dataName:Str255; JT:Ptr):OsErr;INLINE	$203C, $0000, $0101, $205F, $4EA8, $0066;{ récupération de datas conservées par DragsterBoot }FUNCTION Drg_RestoreData(dataName:Str255; JT:Ptr):Ptr;INLINE	$203C, $0000, $0102, $205F, $4EA8, $0066;{ suppression de datas conservées par DragsterBoot }PROCEDURE Drg_KillData(dataName:Str255; JT:Ptr);INLINE	$203C, $0000, $0103, $205F, $4EA8, $0066;{ installation procédure d'arrêt du serveur (ShutDownInstall) }PROCEDURE Drg_ShutDownInstall(procPtr,dataPtr: Ptr; JT:Ptr);INLINE	$7006, $205F, $4EA8, $0066; { MOVE.L #6,D0 / MOVE.L (A7)+,A0 / JSR $66(A0) }{ procPtr --> PROCEDURE ShutDownProc(JT:Ptr; dataPtr:Ptr); }{ ••••••••••••• Protection Hard "EVE" ••••••••••••• }FUNCTION Drg_EVEReset(JT:Ptr) : INTEGER ;INLINE	$203C, $0000, $1000, $205F, $4EA8, $0066;	FUNCTION Drg_EVEStatus(JT:Ptr) : INTEGER ;INLINE	$203C, $0000, $1001, $205F, $4EA8, $0066;FUNCTION Drg_EVEEnable(VAR PASSWORD:STRING; JT:Ptr) : INTEGER ;INLINE	$203C, $0000, $1002, $205F, $4EA8, $0066;FUNCTION Drg_EVEChallenge(LOCK,VALUE : INTEGER; JT:Ptr) : INTEGER ;INLINE	$203C, $0000, $1003, $205F, $4EA8, $0066;FUNCTION Drg_EVEReadGPR(GPR : INTEGER; JT:Ptr) : INTEGER;INLINE	$203C, $0000, $1004, $205F, $4EA8, $0066;FUNCTION Drg_EVEWriteGPR(GPR,VALUE : INTEGER; JT:Ptr) : INTEGER ;INLINE	$203C, $0000, $1005, $205F, $4EA8, $0066;FUNCTION Drg_EVESetLock(LOCK,CHALLANGE,RESPONSE:INTEGER; JT:Ptr) : INTEGER ;INLINE	$203C, $0000, $1006, $205F, $4EA8, $0066;FUNCTION Drg_EVEReadCTR(JT:Ptr) : INTEGER ;INLINE	$203C, $0000, $1007, $205F, $4EA8, $0066;PROCEDURE GosubScreen(screen: Str255; JT:Ptr);{## à vérifier ##}	FUNCTION SeekScreen(screen:Str255; JT:Ptr):LONGINT;	INLINE		$205F, $4EA8, $0030;	PROCEDURE Push(data:LONGINT);		INLINE $4E71; { NOP (pour conserver l'info sur la pile) }	PROCEDURE Jsr(addr: ProcPtr); INLINE $205F,$4E90;	{ MOVE (A7)+,A0 ; JSR (A0) }		VAR	ScreenNum: LONGINT;	BEGIN	ScreenNum := SeekScreen(screen,JT);	WITH Drg_GetTCB(JT)^ DO	BEGIN		Push(TheNScreen);		{ on met le N° d'écran courant sur la pile }		TheVScreen := Ptr(ORD4(PtOffScreen)+8*ScreenNum+4);	{ addr. écran vidéotex }		Jsr(Ptr(ORD4(PtOffScreen)+8*ScreenNum));						{ addr. code exécutable }	END;END;